dmabufmanage/platform.h:4: * Copyright (C) 2020 Amlogic, Inc. All rights reserved.
dmabufmanage/platform.h:12:#define  LOG_TAG    "dmabufmanage"
dmabufmanage/platform.h:13:#include <log/log.h>
dmabufmanage/platform.h:14:#define DMABUF_INFO(fmt, ...)  ALOGI("%s-%d " fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__)
dmabufmanage/platform.h:15:#define DMABUF_ERROR(fmt, ...) ALOGE("%s-%d " fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__)
dmabufmanage/platform.h:16:#define DMABUF_DEBUG(fmt, ...) ALOGD("%s-%d " fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__)
dmabufmanage/platform.h:19:#define ALOGE(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)
dmabufmanage/platform.h:20:#define ALOGI(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)
dmabufmanage/platform.h:21:#define ALOGD(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)
dmabufmanage/dmabufmanage.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
dmabufmanage/test/main.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
dmabufmanage/test/test.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
dmabufmanage/Android.bp:29:        "liblog",
dmabufmanage/Android.bp:55:       "liblog",
dmabufmanage/Android.bp:78:      "liblog",
dmabufmanage/Android.bp:111:      "liblog",
dmabufmanage/dmabufmanage.c:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
OTT-55012.patch:2:Author: “sining.huang” <sining.huang@amlogic.com>
OTT-55012.patch:13:    optimize the logic of discontinue
OTT-55012.patch:19:    Signed-off-by: “sining.huang” <sining.huang@amlogic.com>
OTT-55012.patch:33:+              //  MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"discontinue, mStartFlag:%d", mStartFlag);
OTT-55012.patch:49:                     MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
OTT-55012.patch:61:                     MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
doc/AmTsPlayer/AmTsplayer_user_guide.md:10:<img src="./images/amlogic-logo.png" style="zoom:10%"; >
doc/AmTsPlayer/AmTsplayer_user_guide.md:44:© 2024 Amlogic. All rights reserved. No part of this document may be reproduced, transmitted, transcribed, or translated into any language in any form or by any means without the written permission of Amlogic.
doc/AmTsPlayer/AmTsplayer_user_guide.md:50:<img src="./images/amlogic-logo.png" style="zoom:5%;" />, and other Amlogic icons are trademarks of Amlogic companies. All other trademarks and registered trademarks are property of their respective holders.
doc/AmTsPlayer/AmTsplayer_user_guide.md:56:Amlogic may make improvements and/or changes in this document or in the product described in this document at any time and without notice. 
doc/AmTsPlayer/AmTsplayer_user_guide.md:58:This product is not intended for use in medical, life saving, or life sustaining applications, nor in applications where failure or malfunction of an Amlogic product can reasonably be expected to result in personal injury, death or severe property or environmental damage.
doc/AmTsPlayer/AmTsplayer_user_guide.md:60:Circuit diagrams and other information relating to products of Amlogic are included as a means of illustrating typical applications. Consequently, complete information sufficient for production design is not necessarily given. Though every effort has been made to ensure that this document is current and accurate, Amlogic makes no representations or warranties with respect to the accuracy or completeness of the contents presented in this document. 
doc/AmTsPlayer/AmTsplayer_user_guide.md:62:Amlogic products may be subject to unidentified vulnerabilities or may support established security standards or specifications with known limitations. Amlogic accepts no liability for any vulnerability.
doc/AmTsPlayer/AmTsplayer_user_guide.md:64:Use of the materials may require a license of intellectual property from a third party or from Amlogic. This document conveys no express or implied licenses to any intellectual property rights belonging to Amlogic or any other party. Any links to third-party websites included in this document are for your convenience only. Amlogic does not endorse and is not responsible for such websites and their practices, including privacy practices, availability, and content.
doc/AmTsPlayer/AmTsplayer_user_guide.md:66:Amlogic shall in no event be liable for any claims relating to or arising out of this document or any use or inability to use hereof.
doc/AmTsPlayer/AmTsplayer_user_guide.md:72:* Website: [www.amlogic.com](http://www.amlogic.com/)
doc/AmTsPlayer/AmTsplayer_user_guide.md:74:* Pre-sales consultation: [contact@amlogic.com](mailto:ailto:contact@amlogic.com)
doc/AmTsPlayer/AmTsplayer_user_guide.md:76:* Technical support: [support@amlogic.com](mailto:support@amlogic.com)
doc/AmTsPlayer/AmTsplayer_user_guide.md:257:path:vendor/amlogic/common/mediahal_sdk
doc/AmTsPlayer/AmTsplayer_user_guide.md:387:We have added reference rules in /device/amlogic/common/media.mk to auto install these libs.
doc/AmTsPlayer/AmTsplayer_user_guide.md:435:We have added reference rules in buildroot/configs/amlogic/xxxxx.config  to auto install these libs.
doc/AmTsPlayer/AmTsplayer_user_guide.md:449:cd /vendor/amlogic/common/mediahal_sdk
doc/AmTsPlayer/AmTsplayer_user_guide.md:594:    AM_TSPLAYER_KEY_SET_LOGGER_LEVEL, //set logger level
doc/AmTsPlayer/AmTsplayer_user_guide.md:1577:am_tsplayer_result AmTsPlayer_setAudioMute(am_tsplayer_handle Hadl, bool_t analog_mute, bool_t digital_mute);
doc/AmTsPlayer/AmTsplayer_user_guide.md:1580:@param [in] analog_mute:If analog mute or unmute
doc/AmTsPlayer/AmTsplayer_user_guide.md:1589:am_tsplayer_result AmTsPlayer_getAudioMute(am_tsplayer_handle Hadl, bool_t *analog_unmute, bool_t*digital_unmute);
doc/AmTsPlayer/AmTsplayer_user_guide.md:1592:@param [out] analog_unmute: If analog mute or unmute
doc/AmTsPlayer/AmTsplayer_user_guide.md:1915:logcat -s TsPlayer
Android.mk.in:2:ifeq (,$(wildcard hardware/amlogic/media_hal))
.git/hooks/prepare-commit-msg.sample:3:# An example hook script to prepare the commit log message.
.git/hooks/commit-msg.sample:3:# An example hook script to check the commit log message.
.git/hooks/applypatch-msg.sample:3:# An example hook script to check the commit log message taken by
.git/hooks/pre-push.sample:19:# This sample shows how to prevent push of commits where the log message starts
.git/FETCH_HEAD:1:6301f9ee347dbac4dd3a7f3fa970937c3826c194		branch 'master' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:2:1d2ff74ac11fc87a6363bcfbaa67afe9ebd078ca	not-for-merge	branch 'Linux' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:3:dbab8085aadcda44eacd943515caeecc9606412e	not-for-merge	branch 'feature-android-v4l2-stream-mode' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:4:465197317c05bd6ef3fd387e23ea408fd48d271d	not-for-merge	branch 'openlinux/ott/r-amlogic' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:5:78e50a03411a3408a1ae9a400920fed2700688ef	not-for-merge	branch 'openlinux/ott/r-amlogic-hybrid-v3.4' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:6:e451a1ad3d1ff405e1c8c14d331c66d3cad432fb	not-for-merge	branch 'openlinux/ott/s-amlogic-20211230' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:7:d3ef1dc6550732b93713a5d5ab137b0edbae8752	not-for-merge	branch 'openlinux/ott/s-amlogic-hybrid-v3.8' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:8:212a6162f6ca5842bf60af8318a5581ec0c51925	not-for-merge	branch 'openlinux/ott/t-amlogic-hybrid-v3.16' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:9:e631f41a368cb98166995c863d6b8f0dc9079474	not-for-merge	branch 'openlinux/ott/yocto-amlogic' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:10:4925644a0ce00ba86ca5a94650f4875c74f4f3b5	not-for-merge	branch 'openlinux/ott/zapper-amlogic' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:11:1ae9cc8089b353ac2b54a5346faaadb90bd3ed5a	not-for-merge	branch 'openlinux/tv/p-amlogic-fireos-v3.12' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:12:dfc4fdb95bf12d6017d5e5c306de2b9d20a1e1a6	not-for-merge	branch 'project/tv/linux-roku-roxton-v3.5' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:13:a5447d3df09edafc8a035da1f3bc1c45e61d9ae2	not-for-merge	branch 'project/tv/p-amazon-almond-v3.0' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:14:b0995f830ad26e14b546871e5e00eb4f5b256d6a	not-for-merge	branch 'projects/p-amlogic-iptv' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:15:162a9b651319f2da7f6294b989c398409fb3d363	not-for-merge	branch 'v3.11-for-linux-openlinux' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:16:a940977cf5c1e864afcec1a69c91500587bfdab6	not-for-merge	branch 'v3.14-for-android-openlinux' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:17:d8c3541f234b2deac4091f7c3271eb5f9687778c	not-for-merge	branch 'v3.20-for-android-openlinux' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:18:1edb4093166526a6c97aec04dd54fb6791153743	not-for-merge	branch 'v3.24-for-android-openlinux' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:19:f0dc92739d8cc30765bdd198035ce1a1cb2a3707	not-for-merge	branch 'v3.26-for-android-openlinux' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:20:1aad60f235d94140e59fba672b65c4a5b53972d3	not-for-merge	branch 'v3.28-for-android-openlinux' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:21:130fccb790230cc1f5d0f7be9d7e4f2109ee2ce8	not-for-merge	branch 'v3.30-for-android-project' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:22:e10fd3db48a8b6fa0f8829c2016df23781b3952c	not-for-merge	branch 'v3.32-for-android-openlinux' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:23:5783f0bd70d885d26bb357716877651ac6c00ae2	not-for-merge	branch 'v3.36-for-android-openlinux' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:24:a5d5f32c35c0f19ee6b5e6cef2cd832b982153c3	not-for-merge	branch 'v3.40-for-android-openlinux' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/FETCH_HEAD:25:159b18ebb6e0c8fb0082bcfa524ff88bab62eeca	not-for-merge	branch 'v3.9-for-linux-project' of ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/packed-refs:4:c2fe99d790db46820b839680f66faf50321abcfc refs/remotes/origin/openlinux/ott/r-amlogic
.git/packed-refs:5:78e50a03411a3408a1ae9a400920fed2700688ef refs/remotes/origin/openlinux/ott/r-amlogic-hybrid-v3.4
.git/packed-refs:6:e451a1ad3d1ff405e1c8c14d331c66d3cad432fb refs/remotes/origin/openlinux/ott/s-amlogic-20211230
.git/packed-refs:7:1c7f04c36bbfb3ed8453512329c725adf65e5f2d refs/remotes/origin/openlinux/ott/s-amlogic-hybrid-v3.8
.git/packed-refs:8:212a6162f6ca5842bf60af8318a5581ec0c51925 refs/remotes/origin/openlinux/ott/t-amlogic-hybrid-v3.16
.git/packed-refs:9:e631f41a368cb98166995c863d6b8f0dc9079474 refs/remotes/origin/openlinux/ott/yocto-amlogic
.git/packed-refs:10:4925644a0ce00ba86ca5a94650f4875c74f4f3b5 refs/remotes/origin/openlinux/ott/zapper-amlogic
.git/packed-refs:11:1ae9cc8089b353ac2b54a5346faaadb90bd3ed5a refs/remotes/origin/openlinux/tv/p-amlogic-fireos-v3.12
.git/config:5:	logallrefupdates = true
.git/config:7:	url = ssh://lingzhi.bi@scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/config:13:[branch "openlinux/ott/s-amlogic-hybrid-v3.8"]
.git/config:15:	merge = refs/heads/openlinux/ott/s-amlogic-hybrid-v3.8
.git/logs/HEAD:1:0000000000000000000000000000000000000000 ab69202e0ce7a3e8904fee81ff3022bcb0db4567 lingzhi.bi <lingzhi.bi@amlogic.com> 1725516219 +0800	clone: from ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/logs/HEAD:2:ab69202e0ce7a3e8904fee81ff3022bcb0db4567 de0f03967a6442085b2bb60ea53593d59e024a9b lingzhi.bi <lingzhi.bi@amlogic.com> 1725525814 +0800	checkout: moving from master to FETCH_HEAD
.git/logs/HEAD:3:de0f03967a6442085b2bb60ea53593d59e024a9b ab69202e0ce7a3e8904fee81ff3022bcb0db4567 lingzhi.bi <lingzhi.bi@amlogic.com> 1725526990 +0800	checkout: moving from de0f03967a6442085b2bb60ea53593d59e024a9b to master
.git/logs/HEAD:4:ab69202e0ce7a3e8904fee81ff3022bcb0db4567 1c7f04c36bbfb3ed8453512329c725adf65e5f2d lingzhi.bi <lingzhi.bi@amlogic.com> 1725527028 +0800	checkout: moving from master to origin/openlinux/ott/s-amlogic-hybrid-v3.8
.git/logs/HEAD:5:1c7f04c36bbfb3ed8453512329c725adf65e5f2d ab69202e0ce7a3e8904fee81ff3022bcb0db4567 lingzhi.bi <lingzhi.bi@amlogic.com> 1725527063 +0800	checkout: moving from 1c7f04c36bbfb3ed8453512329c725adf65e5f2d to master
.git/logs/HEAD:6:ab69202e0ce7a3e8904fee81ff3022bcb0db4567 1c7f04c36bbfb3ed8453512329c725adf65e5f2d lingzhi.bi <lingzhi.bi@amlogic.com> 1725527106 +0800	checkout: moving from master to openlinux/ott/s-amlogic-hybrid-v3.8
.git/logs/HEAD:7:1c7f04c36bbfb3ed8453512329c725adf65e5f2d ab69202e0ce7a3e8904fee81ff3022bcb0db4567 lingzhi.bi <lingzhi.bi@amlogic.com> 1725528094 +0800	checkout: moving from openlinux/ott/s-amlogic-hybrid-v3.8 to master
.git/logs/HEAD:8:ab69202e0ce7a3e8904fee81ff3022bcb0db4567 41e20501acc42e47c305bd1e38cef72c52c8123b lingzhi.bi <lingzhi.bi@amlogic.com> 1725937208 +0800	checkout: moving from master to FETCH_HEAD
.git/logs/HEAD:9:41e20501acc42e47c305bd1e38cef72c52c8123b ab69202e0ce7a3e8904fee81ff3022bcb0db4567 lingzhi.bi <lingzhi.bi@amlogic.com> 1725937607 +0800	checkout: moving from 41e20501acc42e47c305bd1e38cef72c52c8123b to master
.git/logs/HEAD:10:ab69202e0ce7a3e8904fee81ff3022bcb0db4567 e9fcf54111f1b24debb98478b314ad5c6ef71b6f lingzhi.bi <lingzhi.bi@amlogic.com> 1725937618 +0800	pull: Fast-forward
.git/logs/HEAD:11:e9fcf54111f1b24debb98478b314ad5c6ef71b6f e9fcf54111f1b24debb98478b314ad5c6ef71b6f lingzhi.bi <lingzhi.bi@amlogic.com> 1725950046 +0800	reset: moving to HEAD
.git/logs/HEAD:12:e9fcf54111f1b24debb98478b314ad5c6ef71b6f 87e683ca41fbc7199c81f4e7ba13faec299e8996 lingzhi.bi <lingzhi.bi@amlogic.com> 1725950099 +0800	commit: add debug modify for OTT-45403
.git/logs/HEAD:13:87e683ca41fbc7199c81f4e7ba13faec299e8996 3cd4531ed7c1f1f94fccc1d51c65779e0f78c2a7 lingzhi.bi <lingzhi.bi@amlogic.com> 1725950164 +0800	commit (amend): add debug modify for OTT-45403
.git/logs/HEAD:14:3cd4531ed7c1f1f94fccc1d51c65779e0f78c2a7 4bee2064d013e3e58c74b430cb285a94ad7584a0 lingzhi.bi <lingzhi.bi@amlogic.com> 1725950361 +0800	commit (amend): add debug modify for OTT-45403
.git/logs/HEAD:15:4bee2064d013e3e58c74b430cb285a94ad7584a0 18b52bf130a6d5f4abab60376b15b3a8f6b348bb lingzhi.bi <lingzhi.bi@amlogic.com> 1725950572 +0800	commit (amend): add debug modify for OTT-45403
.git/logs/HEAD:16:18b52bf130a6d5f4abab60376b15b3a8f6b348bb 6d9f332d9734c3fc2f933583470193c1d71bba69 lingzhi.bi <lingzhi.bi@amlogic.com> 1725950628 +0800	cherry-pick: mediasync: video slower than the box just started several seconds after stress test [1/1]
.git/logs/HEAD:17:6d9f332d9734c3fc2f933583470193c1d71bba69 79f2b9c0d0dd190318a0e8ae8ab18049b0808563 lingzhi.bi <lingzhi.bi@amlogic.com> 1725951727 +0800	commit: 1
.git/logs/HEAD:18:79f2b9c0d0dd190318a0e8ae8ab18049b0808563 a6e6e19b81848eb9931c978a2c6fec9a76d1b7f3 lingzhi.bi <lingzhi.bi@amlogic.com> 1725951733 +0800	commit (amend): mediasync: Two boxes start play at the same time and the video are inconsistent [1/1]
.git/logs/HEAD:19:a6e6e19b81848eb9931c978a2c6fec9a76d1b7f3 da6312da3dcd629e2fe04f6b3482d8646d42c540 lingzhi.bi <lingzhi.bi@amlogic.com> 1725951824 +0800	commit (amend): mediasync: Two boxes start play at the same time and the video are inconsistent [1/1]
.git/logs/HEAD:20:da6312da3dcd629e2fe04f6b3482d8646d42c540 a3029a8c00e2f3003a55c411a521a1b5ba2d92f8 lingzhi.bi <lingzhi.bi@amlogic.com> 1725952465 +0800	cherry-pick: mediasync:Sometimes the slope is changed and does not recover [1/1]
.git/logs/HEAD:21:a3029a8c00e2f3003a55c411a521a1b5ba2d92f8 18b52bf130a6d5f4abab60376b15b3a8f6b348bb lingzhi.bi <lingzhi.bi@amlogic.com> 1726218206 +0800	reset: moving to 18b52bf130a6d5f4abab60376b15b3a8f6b348bb
.git/logs/HEAD:22:18b52bf130a6d5f4abab60376b15b3a8f6b348bb 18b52bf130a6d5f4abab60376b15b3a8f6b348bb lingzhi.bi <lingzhi.bi@amlogic.com> 1726218222 +0800	reset: moving to HEAD
.git/logs/HEAD:23:18b52bf130a6d5f4abab60376b15b3a8f6b348bb 38d3529a42d784b160d12f4ffd4220010fee3ab4 lingzhi.bi <lingzhi.bi@amlogic.com> 1726218233 +0800	commit (amend): add debug modify for OTT-45403
.git/logs/HEAD:24:38d3529a42d784b160d12f4ffd4220010fee3ab4 372db383906e72d6b4f343d78351177adfdc2b31 lingzhi.bi <lingzhi.bi@amlogic.com> 1726218671 +0800	commit (amend): mediasync: Sound and picture are out of sync [1/1]
.git/logs/HEAD:25:372db383906e72d6b4f343d78351177adfdc2b31 606046f0d1b4aee61ece35222459de8a91fd4c25 lingzhi.bi <lingzhi.bi@amlogic.com> 1726221582 +0800	commit (amend): mediasync: Sound and picture are out of sync [1/1]
.git/logs/HEAD:26:606046f0d1b4aee61ece35222459de8a91fd4c25 e9fcf54111f1b24debb98478b314ad5c6ef71b6f lingzhi.bi <lingzhi.bi@amlogic.com> 1768879894 +0800	reset: moving to e9fcf54111f1b24debb98478b314ad5c6ef71b6f
.git/logs/HEAD:27:e9fcf54111f1b24debb98478b314ad5c6ef71b6f 6301f9ee347dbac4dd3a7f3fa970937c3826c194 lingzhi.bi <lingzhi.bi@amlogic.com> 1768879920 +0800	pull: Fast-forward
.git/logs/refs/heads/master:1:0000000000000000000000000000000000000000 ab69202e0ce7a3e8904fee81ff3022bcb0db4567 lingzhi.bi <lingzhi.bi@amlogic.com> 1725516219 +0800	clone: from ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/logs/refs/heads/master:2:ab69202e0ce7a3e8904fee81ff3022bcb0db4567 e9fcf54111f1b24debb98478b314ad5c6ef71b6f lingzhi.bi <lingzhi.bi@amlogic.com> 1725937618 +0800	pull: Fast-forward
.git/logs/refs/heads/master:3:e9fcf54111f1b24debb98478b314ad5c6ef71b6f 87e683ca41fbc7199c81f4e7ba13faec299e8996 lingzhi.bi <lingzhi.bi@amlogic.com> 1725950099 +0800	commit: add debug modify for OTT-45403
.git/logs/refs/heads/master:4:87e683ca41fbc7199c81f4e7ba13faec299e8996 3cd4531ed7c1f1f94fccc1d51c65779e0f78c2a7 lingzhi.bi <lingzhi.bi@amlogic.com> 1725950164 +0800	commit (amend): add debug modify for OTT-45403
.git/logs/refs/heads/master:5:3cd4531ed7c1f1f94fccc1d51c65779e0f78c2a7 4bee2064d013e3e58c74b430cb285a94ad7584a0 lingzhi.bi <lingzhi.bi@amlogic.com> 1725950361 +0800	commit (amend): add debug modify for OTT-45403
.git/logs/refs/heads/master:6:4bee2064d013e3e58c74b430cb285a94ad7584a0 18b52bf130a6d5f4abab60376b15b3a8f6b348bb lingzhi.bi <lingzhi.bi@amlogic.com> 1725950572 +0800	commit (amend): add debug modify for OTT-45403
.git/logs/refs/heads/master:7:18b52bf130a6d5f4abab60376b15b3a8f6b348bb 6d9f332d9734c3fc2f933583470193c1d71bba69 lingzhi.bi <lingzhi.bi@amlogic.com> 1725950628 +0800	cherry-pick: mediasync: video slower than the box just started several seconds after stress test [1/1]
.git/logs/refs/heads/master:8:6d9f332d9734c3fc2f933583470193c1d71bba69 79f2b9c0d0dd190318a0e8ae8ab18049b0808563 lingzhi.bi <lingzhi.bi@amlogic.com> 1725951727 +0800	commit: 1
.git/logs/refs/heads/master:9:79f2b9c0d0dd190318a0e8ae8ab18049b0808563 a6e6e19b81848eb9931c978a2c6fec9a76d1b7f3 lingzhi.bi <lingzhi.bi@amlogic.com> 1725951733 +0800	commit (amend): mediasync: Two boxes start play at the same time and the video are inconsistent [1/1]
.git/logs/refs/heads/master:10:a6e6e19b81848eb9931c978a2c6fec9a76d1b7f3 da6312da3dcd629e2fe04f6b3482d8646d42c540 lingzhi.bi <lingzhi.bi@amlogic.com> 1725951824 +0800	commit (amend): mediasync: Two boxes start play at the same time and the video are inconsistent [1/1]
.git/logs/refs/heads/master:11:da6312da3dcd629e2fe04f6b3482d8646d42c540 a3029a8c00e2f3003a55c411a521a1b5ba2d92f8 lingzhi.bi <lingzhi.bi@amlogic.com> 1725952465 +0800	cherry-pick: mediasync:Sometimes the slope is changed and does not recover [1/1]
.git/logs/refs/heads/master:12:a3029a8c00e2f3003a55c411a521a1b5ba2d92f8 18b52bf130a6d5f4abab60376b15b3a8f6b348bb lingzhi.bi <lingzhi.bi@amlogic.com> 1726218206 +0800	reset: moving to 18b52bf130a6d5f4abab60376b15b3a8f6b348bb
.git/logs/refs/heads/master:13:18b52bf130a6d5f4abab60376b15b3a8f6b348bb 38d3529a42d784b160d12f4ffd4220010fee3ab4 lingzhi.bi <lingzhi.bi@amlogic.com> 1726218233 +0800	commit (amend): add debug modify for OTT-45403
.git/logs/refs/heads/master:14:38d3529a42d784b160d12f4ffd4220010fee3ab4 372db383906e72d6b4f343d78351177adfdc2b31 lingzhi.bi <lingzhi.bi@amlogic.com> 1726218671 +0800	commit (amend): mediasync: Sound and picture are out of sync [1/1]
.git/logs/refs/heads/master:15:372db383906e72d6b4f343d78351177adfdc2b31 606046f0d1b4aee61ece35222459de8a91fd4c25 lingzhi.bi <lingzhi.bi@amlogic.com> 1726221582 +0800	commit (amend): mediasync: Sound and picture are out of sync [1/1]
.git/logs/refs/heads/master:16:606046f0d1b4aee61ece35222459de8a91fd4c25 e9fcf54111f1b24debb98478b314ad5c6ef71b6f lingzhi.bi <lingzhi.bi@amlogic.com> 1768879894 +0800	reset: moving to e9fcf54111f1b24debb98478b314ad5c6ef71b6f
.git/logs/refs/heads/master:17:e9fcf54111f1b24debb98478b314ad5c6ef71b6f 6301f9ee347dbac4dd3a7f3fa970937c3826c194 lingzhi.bi <lingzhi.bi@amlogic.com> 1768879920 +0800	pull: Fast-forward
.git/logs/refs/heads/openlinux/ott/s-amlogic-hybrid-v3.8:1:0000000000000000000000000000000000000000 1c7f04c36bbfb3ed8453512329c725adf65e5f2d lingzhi.bi <lingzhi.bi@amlogic.com> 1725527106 +0800	branch: Created from origin/openlinux/ott/s-amlogic-hybrid-v3.8
.git/logs/refs/stash:1:0000000000000000000000000000000000000000 c76cd0fc3df86612f8b330b82718f9f7ceb1862a lingzhi.bi <lingzhi.bi@amlogic.com> 1726218222 +0800	WIP on master: 18b52bf1 add debug modify for OTT-45403
.git/logs/refs/remotes/origin/v3.11-for-linux-openlinux:1:4ac969e2d3e6792dc9e36cac0a2ffefe5271f346 162a9b651319f2da7f6294b989c398409fb3d363 lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: fast-forward
.git/logs/refs/remotes/origin/v3.36-for-android-openlinux:1:0000000000000000000000000000000000000000 5783f0bd70d885d26bb357716877651ac6c00ae2 lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: storing head
.git/logs/refs/remotes/origin/Linux:1:a3a0d87b6435366cfe09d3bae195d065bde54407 8d16a94914222e63862b54adb523d9502f9d9c6b lingzhi.bi <lingzhi.bi@amlogic.com> 1725937561 +0800	pull: fast-forward
.git/logs/refs/remotes/origin/Linux:2:8d16a94914222e63862b54adb523d9502f9d9c6b 1d2ff74ac11fc87a6363bcfbaa67afe9ebd078ca lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: fast-forward
.git/logs/refs/remotes/origin/v3.14-for-android-openlinux:1:b0152dd62af2ed962a416c04d0d4840958d6d11c a940977cf5c1e864afcec1a69c91500587bfdab6 lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: fast-forward
.git/logs/refs/remotes/origin/master:1:ab69202e0ce7a3e8904fee81ff3022bcb0db4567 e9fcf54111f1b24debb98478b314ad5c6ef71b6f lingzhi.bi <lingzhi.bi@amlogic.com> 1725937561 +0800	pull: fast-forward
.git/logs/refs/remotes/origin/master:2:e9fcf54111f1b24debb98478b314ad5c6ef71b6f 6301f9ee347dbac4dd3a7f3fa970937c3826c194 lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: fast-forward
.git/logs/refs/remotes/origin/v3.32-for-android-openlinux:1:0000000000000000000000000000000000000000 e10fd3db48a8b6fa0f8829c2016df23781b3952c lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: storing head
.git/logs/refs/remotes/origin/project/tv/linux-roku-roxton-v3.5:1:5c4e53f3140fdac2996531b65f3689749a7c4eed dfc4fdb95bf12d6017d5e5c306de2b9d20a1e1a6 lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: fast-forward
.git/logs/refs/remotes/origin/v3.28-for-android-openlinux:1:0000000000000000000000000000000000000000 1aad60f235d94140e59fba672b65c4a5b53972d3 lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: storing head
.git/logs/refs/remotes/origin/v3.26-for-android-openlinux:1:32480f53502930f62df8e62eb706347b0c6aee53 f0dc92739d8cc30765bdd198035ce1a1cb2a3707 lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: fast-forward
.git/logs/refs/remotes/origin/HEAD:1:0000000000000000000000000000000000000000 ab69202e0ce7a3e8904fee81ff3022bcb0db4567 lingzhi.bi <lingzhi.bi@amlogic.com> 1725516219 +0800	clone: from ssh://scgit.amlogic.com:29418/av-restricted/platform/vendor/media_hal
.git/logs/refs/remotes/origin/v3.20-for-android-openlinux:1:18a01b6e8befcd1170779ac7da4309ca9f098bbb d8c3541f234b2deac4091f7c3271eb5f9687778c lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: fast-forward
.git/logs/refs/remotes/origin/v3.24-for-android-openlinux:1:0000000000000000000000000000000000000000 1edb4093166526a6c97aec04dd54fb6791153743 lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: storing head
.git/logs/refs/remotes/origin/v3.9-for-linux-project:1:797d37ea1766acba53e27a25fcd40055f4cc9662 159b18ebb6e0c8fb0082bcfa524ff88bab62eeca lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: fast-forward
.git/logs/refs/remotes/origin/feature-android-v4l2-stream-mode:1:0000000000000000000000000000000000000000 dbab8085aadcda44eacd943515caeecc9606412e lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: storing head
.git/logs/refs/remotes/origin/projects/p-amlogic-iptv:1:0000000000000000000000000000000000000000 b0995f830ad26e14b546871e5e00eb4f5b256d6a lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: storing head
.git/logs/refs/remotes/origin/v3.40-for-android-openlinux:1:0000000000000000000000000000000000000000 a5d5f32c35c0f19ee6b5e6cef2cd832b982153c3 lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: storing head
.git/logs/refs/remotes/origin/openlinux/ott/r-amlogic:1:c2fe99d790db46820b839680f66faf50321abcfc 465197317c05bd6ef3fd387e23ea408fd48d271d lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: fast-forward
.git/logs/refs/remotes/origin/openlinux/ott/s-amlogic-hybrid-v3.8:1:1c7f04c36bbfb3ed8453512329c725adf65e5f2d d3ef1dc6550732b93713a5d5ab137b0edbae8752 lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: fast-forward
.git/logs/refs/remotes/origin/v3.30-for-android-project:1:0000000000000000000000000000000000000000 130fccb790230cc1f5d0f7be9d7e4f2109ee2ce8 lingzhi.bi <lingzhi.bi@amlogic.com> 1768879806 +0800	pull: storing head
.git/COMMIT_EDITMSG:20:Signed-off-by: lingzhi.bi <lingzhi.bi@amlogic.com>
videodec/V4l2StreamModeAdaptor.cpp:5://#define LOG_NDEBUG 0
videodec/V4l2StreamModeAdaptor.cpp:6:#define LOG_TAG "V4l2StreamModeAdaptor"
videodec/V4l2StreamModeAdaptor.cpp:27:#include <utils/Log.h>
videodec/V4l2StreamModeAdaptor.cpp:59:            ALOGE("Component thread failed to start.");
videodec/V4l2StreamModeAdaptor.cpp:89:    ALOGI("V4l2StreamModeAdaptor::onInit");
videodec/V4l2StreamModeAdaptor.cpp:92:        ALOGE("Re-initialize() is not allowed");
videodec/V4l2StreamModeAdaptor.cpp:108:        ALOGE("Failed to initialize VDA");
videodec/V4l2StreamModeAdaptor.cpp:125:            ALOGD("%s setpriority error: %s, niceval:%d",  __func__, strerror(errno), niceval);
videodec/V4l2StreamModeAdaptor.cpp:136:    ALOGI("V4l2StreamModeAdaptor::initialize flags is 0x%x", flags);
videodec/V4l2StreamModeAdaptor.cpp:205:    ALOGI("onAssignPictureBuffers numOutputBuffers %d\n", numOutputBuffers);
videodec/V4l2StreamModeAdaptor.cpp:214:    ALOGI("assignPictureBuffers numOutputBuffers %d\n", numOutputBuffers);
videodec/V4l2StreamModeAdaptor.cpp:235:    ALOGI("onImportBufferForPicture pictureBufferId %d, dmabufFd %d, metaFd %d, plane size %d\n",
videodec/V4l2StreamModeAdaptor.cpp:243:        ALOGI("onImportBufferForPicture addr %p, stride %d, offset %d, size %" PRId64 "\n",
videodec/V4l2StreamModeAdaptor.cpp:252:    ALOGI("importBufferForPicture pictureBufferId %d, dmabufFd %d, metaFd %d\n",
videodec/V4l2StreamModeAdaptor.cpp:337:    ALOGV("sendCommand %d\n", index);
videodec/V4l2StreamModeAdaptor.cpp:343:            ALOGI("VDA_SET_STREAM_EOF %d\n", eof);
videodec/V4l2StreamModeAdaptor.cpp:346:                ALOGE("%s, msg == NULL",__func__);
videodec/V4l2StreamModeAdaptor.cpp:354:            ALOGW("unknown command:%d", idx);
videodec/V4l2StreamModeAdaptor.cpp:421:        ALOGE("not support input the codec now!");
videodec/V4l2StreamModeAdaptor.cpp:424:    ALOGI("V4l2StreamModeAdaptor::GetSupportedProfiles inputcoded %d, inputFormatFourcc %x\n",
videodec/V4l2StreamModeAdaptor.cpp:443:    LOG_ALWAYS_FATAL_IF(value == std::end(kSupportedPixelFormats),
videodec/V4l2StreamModeAdaptor.cpp:455:    ALOGI("V4l2StreamModeAdaptor::ProvidePictureBuffers %d\n", requested_num_of_buffers);
videodec/V4l2StreamModeAdaptor.cpp:479:    //ALOGI("NotifyEndOfBitstreamBuffer bitstream_buffer_id %d\n", bitstream_buffer_id);
videodec/V4l2StreamModeAdaptor.cpp:509:        ALOGE("Unknown error code: %d", static_cast<int>(error));
videodec/utils/Amlsysfsutils.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/utils/Amlsysfsutils.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/utils/Amlsysfsutils.cpp:12:#define LOG_TAG "AmlSysfsUtil"
videodec/utils/Amlsysfsutils.cpp:18:#include <utils/Log.h>
videodec/utils/Amlsysfsutils.cpp:25:#ifndef LOGD
videodec/utils/Amlsysfsutils.cpp:26:#define LOGV ALOGV
videodec/utils/Amlsysfsutils.cpp:27:#define LOGD ALOGD
videodec/utils/Amlsysfsutils.cpp:28:#define LOGI ALOGI
videodec/utils/Amlsysfsutils.cpp:29:#define LOGW ALOGW
videodec/utils/Amlsysfsutils.cpp:30:#define LOGE ALOGE
videodec/utils/Amlsysfsutils.cpp:51:        ALOGW("[%s] %s failed!",__FUNCTION__,path);
videodec/utils/Amlsysfsutils.cpp:72:        //ALOGW("[%s] %s failed!",__FUNCTION__,path);
videodec/utils/Amlsysfsutils.cpp:93:        ALOGW("[%s] %s failed!",__FUNCTION__,path);
videodec/utils/Amlsysfsutils.cpp:115:        ALOGW("[%s] %s failed!",__FUNCTION__,path);
videodec/utils/Amlsysfsutils.cpp:136:        ALOGW("[%s] %s failed!",__FUNCTION__,path);
videodec/utils/Amlsysfsutils.cpp:157:        ALOGW("[%s] %s failed!",__FUNCTION__,path);
videodec/utils/Amlsysfsutils.cpp:178:        ALOGW("[%s] %s failed!",__FUNCTION__,path);
videodec/utils/aml_uvm.cc:1:#define LOG_TAG  "AmUvm"
videodec/utils/aml_uvm.cc:14:#include <utils/Log.h>
videodec/utils/aml_uvm.cc:18:#define LOG_ERR 0
videodec/utils/aml_uvm.cc:19:#define LOG_INFO 1
videodec/utils/aml_uvm.cc:20:#define LOG_DEBUG_LEVEL1 2
videodec/utils/aml_uvm.cc:21:#define LOG_DEBUG_LEVEL2 4
videodec/utils/aml_uvm.cc:23:static unsigned int gLogLevel = 1;
videodec/utils/aml_uvm.cc:25:#define UvmLog(level, f, s...) \
videodec/utils/aml_uvm.cc:27:    if (level & gLogLevel) { \
videodec/utils/aml_uvm.cc:28:        if (level == LOG_INFO) \
videodec/utils/aml_uvm.cc:29:            ALOGI(""#f , ##s);\
videodec/utils/aml_uvm.cc:30:        else if (level == LOG_DEBUG_LEVEL1 || level == LOG_DEBUG_LEVEL2) \
videodec/utils/aml_uvm.cc:31:            ALOGD(""#f, ##s);\
videodec/utils/aml_uvm.cc:34:            ALOGE(""#f, ##s);\
videodec/utils/aml_uvm.cc:57:    VideoDec_propertyGetInt(PROPERTY_VIDEODEC_LOGlEVELS, PROPERTY_VIDEODEC_LOGlEVELS_OLD, (int*)&gLogLevel);
videodec/utils/aml_uvm.cc:83:        UvmLog(LOG_ERR,"open uvm dev fail");
videodec/utils/aml_uvm.cc:99:        UvmLog(LOG_ERR, "need open uvm first");
videodec/utils/aml_uvm.cc:115:        UvmLog(LOG_ERR,"uvm alloc error ret=%d, mUvmFd:%d, size:%d, stride:%d, width:%d, height:%d, flag:%d", ret, mUvmFd, size, stride, width, height, flag);
videodec/utils/aml_uvm.cc:126:        UvmLog(LOG_ERR,"uvm get metadata error, invalid arguments! mUvmFd:%d fd:%d meta:%p", mUvmFd, fd, meta);
videodec/utils/aml_uvm.cc:139:        UvmLog(LOG_ERR,"uvm get metadata error ret=%x", ret);
videodec/utils/aml_uvm.cc:153:        UvmLog(LOG_ERR,"uvm get metadata error, invalid arguments! mUvmFd:%d fd:%d meta:%p", mUvmFd, fd, meta);
videodec/utils/aml_uvm.cc:163:        UvmLog(LOG_ERR,"uvm get metadata error ret=%x", ret);
videodec/utils/aml_video_data.h:12:#define V4L2_CID_USER_AMLOGIC_BASE  (V4L2_CID_USER_BASE + 0x1100)
videodec/utils/aml_video_data.h:13:#define AML_V4L2_GET_DECINFO_SET (V4L2_CID_USER_AMLOGIC_BASE + 13)
videodec/utils/aml_video_data.h:226:     *            "linear", "log100", "log316", "iec61966-2-4",
videodec/utils/log_debug.h:1:#ifndef _LOG_DEBUG_H
videodec/utils/log_debug.h:2:#define _LOG_DEBUG_H
videodec/utils/log_debug.h:6:#include <utils/Log.h>
videodec/utils/log_debug.h:11:#define LOG_ERR 0
videodec/utils/log_debug.h:12:#define LOG_INFO 1
videodec/utils/log_debug.h:13:#define LOG_BUFFER 2
videodec/utils/log_debug.h:14:#define LOG_DEBUG_LEVEL1 4
videodec/utils/log_debug.h:15:#define LOG_DEBUG_LEVEL2 8
videodec/utils/log_debug.h:16:#define LOG_TRACE 16
videodec/utils/log_debug.h:18:static unsigned int gloglevel = 1;
videodec/utils/log_debug.h:19:#define VDLog(level, f, s...) \
videodec/utils/log_debug.h:21:    if (level & gloglevel) {\
videodec/utils/log_debug.h:22:        if (level == LOG_INFO)\
videodec/utils/log_debug.h:23:            ALOGI(f, ##s);\
videodec/utils/log_debug.h:24:        else if (level == LOG_BUFFER || level == LOG_DEBUG_LEVEL1 || level == LOG_DEBUG_LEVEL2) \
videodec/utils/log_debug.h:25:            ALOGD(f, ##s);\
videodec/utils/log_debug.h:28:            ALOGD(f, ##s);\
videodec/utils/log_debug.h:35:    if (gloglevel & LOG_TRACE) {\
videodec/utils/log_debug.h:46:    if (gloglevel & LOG_TRACE) {\
videodec/utils/log_debug.h:52:    if (gloglevel & LOG_TRACE) \
videodec/utils/log_debug.h:57:    if (gloglevel & LOG_TRACE) {\
videodec/utils/log_debug.h:64:    if (gloglevel & LOG_TRACE) {\
videodec/utils/file_io_dumper.cc:1:#define LOG_NDEBUG 0
videodec/utils/file_io_dumper.cc:2:#define LOG_TAG "FileIODumper"
videodec/utils/file_io_dumper.cc:6:#include <utils/Log.h>
videodec/utils/file_io_dumper.cc:12:#include "log_debug.h"
videodec/utils/file_io_dumper.cc:17:#define FDLog(level, f, s...) VDLog(level, f, ##s)
videodec/utils/file_io_dumper.cc:30:    VideoDec_propertyGetInt(PROPERTY_VIDEODEC_LOGlEVELS, PROPERTY_VIDEODEC_LOGlEVELS_OLD, (int*)&gloglevel);
videodec/utils/file_io_dumper.cc:60:       FDLog(LOG_ERR, "%s:%d create file %s failed, err %s", __func__, __LINE__, file_path,  strerror(errno));
videodec/utils/file_io_dumper.cc:86:        FDLog(LOG_ERR, "map error");
videodec/utils/file_io_dumper.cc:105:        FDLog(LOG_ERR, "map error");
videodec/utils/aml_video_data.cc:1:#define LOG_TAG "AmlVideoData"
videodec/utils/aml_video_data.cc:3:#include <utils/Log.h>
videodec/utils/aml_video_data.cc:14:#include "log_debug.h"
videodec/utils/aml_video_data.cc:19:#define AVDLog(level, f, s...) VDLog(level, f, ##s)
videodec/utils/aml_video_data.cc:63:        AVDLog(LOG_ERR, "unable to dlopen libmediaproxy_producer.so: %s", dlerror());
videodec/utils/aml_video_data.cc:70:        AVDLog(LOG_ERR, "have not found any function %s", dlerror());
videodec/utils/aml_video_data.cc:95:    VideoDec_propertyGetInt(PROPERTY_VIDEODEC_LOGlEVELS, PROPERTY_VIDEODEC_LOGlEVELS_OLD, (int*)&gloglevel);
videodec/utils/aml_video_data.cc:96:    AVDLog(LOG_INFO, "AmlVideoData");
videodec/utils/aml_video_data.cc:113:        AVDLog(LOG_ERR, "haven't found library libmediaproxy_producer or init method");
videodec/utils/aml_video_data.cc:118:    AVDLog(LOG_INFO, "~AmlVideoData fd =%d", proxy_fd);
videodec/utils/aml_video_data.cc:122:        AVDLog(LOG_ERR, "haven't found library libmediaproxy_producer or destroy method");
videodec/utils/aml_video_data.cc:128:        AVDLog(LOG_ERR, "haven't found library libmediaproxy_producer.so");
videodec/utils/aml_video_data.cc:132:        AVDLog(LOG_ERR, "write method not found");
videodec/utils/aml_video_data.cc:136:         AVDLog(LOG_ERR, "bad fd, will don't write data");
videodec/utils/aml_video_data.cc:145:            AVDLog(LOG_ERR, "send error data!!");
videodec/utils/aml_video_data.cc:151:        AVDLog(LOG_ERR, "inject video info failed err = %s ", strerror(errno));
videodec/utils/aml_video_data.cc:157:        AVDLog(LOG_ERR, "haven't found library libmediaproxy_producer.so");
videodec/utils/aml_video_data.cc:161:        AVDLog(LOG_ERR, "write method not found");
videodec/utils/aml_video_data.cc:165:         AVDLog(LOG_ERR, "bad fd, will don't write data");
videodec/utils/aml_video_data.cc:171:    AVDLog(LOG_DEBUG_LEVEL1, "sendVideoData messageType = %d", messageType);
videodec/utils/aml_video_data.cc:196:            AVDLog(LOG_ERR, "send error data!!");
videodec/utils/aml_video_data.cc:203:        AVDLog(LOG_ERR, "write video info failed err = %s ", strerror(errno));
videodec/utils/aml_video_data.cc:211:        AVDLog(LOG_ERR, "haven't found library libmediaproxy_producer.so");
videodec/utils/aml_video_data.cc:216:        AVDLog(LOG_ERR, "write method not found");
videodec/utils/aml_video_data.cc:221:         AVDLog(LOG_ERR, "bad fd, will don't write data");
videodec/utils/aml_video_data.cc:227:        AVDLog(LOG_ERR, "set vdec id failed err = %s ", strerror(errno));
videodec/utils/aml_video_data.cc:230:    AVDLog(LOG_INFO, "setInstanceId succeed:%d", instance_id);
videodec/utils/aml_video_data.cc:249:    AVDLog(LOG_DEBUG_LEVEL1, "AmlVideoData setResolution width = %d, height = %d", res.width, res.height);
videodec/utils/AmVideoDecProperty.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/utils/AmVideoDecProperty.h:16:#define PROPERTY_VIDEODEC_LOGlEVELS_OLD  "vendor.mediahal.loglevels"
videodec/utils/AmVideoDecProperty.h:17:#define PROPERTY_VIDEODEC_LOGlEVELS      "vendor.media.mediahal.videodec.loglevels"
videodec/utils/AmVideoDecProperty.h:18:#define PROPERTY_VIDEODEC_PTS_LOGlEVELS      "vendor.media.mediahal.videodec.pts.loglevels"
videodec/utils/AmVideoDecProperty.h:19:#define PROPERTY_VIDEODEC_LCEVC_LOGlEVELS      "vendor.media.mediahal.videodec.lcevc.loglevels"
videodec/utils/AmVideoDecProperty.h:65:#define PROPERTY_VIDEODEC_BUFFERPOOL_LOGLEVELS       "vendor.media.mediahal.bufferpool.loglevels"  /* bufferpool */
videodec/utils/aml_manage_pts.cc:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/utils/aml_manage_pts.cc:10:#define LOG_TAG "AmlManagePts"
videodec/utils/aml_manage_pts.cc:12:#include <utils/Log.h>
videodec/utils/aml_manage_pts.cc:19:#define LOG_ERR 0
videodec/utils/aml_manage_pts.cc:20:#define LOG_INFO 1
videodec/utils/aml_manage_pts.cc:21:#define LOG_DEBUG_LEVEL1 2
videodec/utils/aml_manage_pts.cc:22:#define LOG_DEBUG_LEVEL2 4
videodec/utils/aml_manage_pts.cc:23:#define LOG_DEBUG_LEVEL3 8
videodec/utils/aml_manage_pts.cc:25:static unsigned int gLogLevel = 1;
videodec/utils/aml_manage_pts.cc:27:#define PTSLog(level, f, s...) \
videodec/utils/aml_manage_pts.cc:29:    if (level & gLogLevel) { \
videodec/utils/aml_manage_pts.cc:30:        if (level == LOG_INFO) \
videodec/utils/aml_manage_pts.cc:31:            ALOGI("[%d]"#f, mInstanceNum, ##s);\
videodec/utils/aml_manage_pts.cc:32:        else if (level == LOG_DEBUG_LEVEL1 || level == LOG_DEBUG_LEVEL2 || level == LOG_DEBUG_LEVEL3) \
videodec/utils/aml_manage_pts.cc:33:            ALOGD("[%d]"#f, mInstanceNum, ##s);\
videodec/utils/aml_manage_pts.cc:36:            ALOGE("[%d]"#f, mInstanceNum, ##s);\
videodec/utils/aml_manage_pts.cc:57:    VideoDec_propertyGetInt(PROPERTY_VIDEODEC_PTS_LOGlEVELS, PROPERTY_VIDEODEC_PTS_LOGlEVELS, (int*)&gLogLevel);
videodec/utils/aml_manage_pts.cc:60:    PTSLog(LOG_INFO, "%s into\n", __func__);
videodec/utils/aml_manage_pts.cc:89:    PTSLog(LOG_INFO, "%s into\n", __func__);
videodec/utils/aml_manage_pts.cc:102:    PTSLog(LOG_INFO, "%s into size:%d\n", __func__, size);
videodec/utils/aml_manage_pts.cc:119:    PTSLog(LOG_DEBUG_LEVEL2, "%s into, [%d][%lld]mInPtsInvalid[%d]\n", __func__, bitStreamId, (long long)timestamp, mInPtsInvalid);
videodec/utils/aml_manage_pts.cc:124:        //PTSLog(LOG_INFO, "%s error occur, had insert, [%d][%lld] to queue\n", __func__, bitStreamId, (long long)timestamp);
videodec/utils/aml_manage_pts.cc:128:        PTSLog(LOG_INFO, "%s into, [%d] [%lld]  csd skip\n", __func__, bitStreamId, (long long)timestamp);
videodec/utils/aml_manage_pts.cc:134:            //PTSLog(LOG_INFO, "%s into, [%d][%lld] set mInPtsInvalid false\n", __func__, bitStreamId, (long long)timestamp);
videodec/utils/aml_manage_pts.cc:149:    PTSLog(LOG_INFO, "%s into\n", __func__);
videodec/utils/aml_manage_pts.cc:156:    PTSLog(LOG_INFO, "%s into\n", __func__);
videodec/utils/aml_manage_pts.cc:170:    PTSLog(LOG_INFO, "%s into\n", __func__);
videodec/utils/aml_manage_pts.cc:192:    PTSLog(LOG_INFO, "%s into\n", __func__);
videodec/utils/aml_manage_pts.cc:238:    PTSLog(LOG_DEBUG_LEVEL2, "%s in dur [%d] out dur:%d mUnstablePts:%d mIsAviDiscard:%d default dur:%d onlydefault:%d\n", __func__, in, out, mUnstablePts, mIsAviDiscard, mDuration, mOnlyCalculateUseDefaultDur);
videodec/utils/aml_manage_pts.cc:298:        PTSLog(LOG_DEBUG_LEVEL2, "%s dur [%d] count:%d\n", __func__, iter->first,iter->second);
videodec/utils/aml_manage_pts.cc:300:    PTSLog(LOG_DEBUG_LEVEL1, "%s max count dur [%d] count:%d\n", __func__, dur, count);
videodec/utils/aml_manage_pts.cc:334:    PTSLog(LOG_DEBUG_LEVEL2, "%s into list size:%d  type:%s\n", __func__, (int)list->size(), type == 0 ? "outpts":"inpts");
videodec/utils/aml_manage_pts.cc:341:        PTSLog(LOG_DEBUG_LEVEL1, "%s into type:%s last pts is %d\n", __func__, type == 0 ? "outpts":"inpts", (int)maxPts);
videodec/utils/aml_manage_pts.cc:363:        PTSLog(LOG_DEBUG_LEVEL1, "%s into type:%s error max %lld  min:%lld\n", __func__, type == 0 ? "outpts":"inpts", (long long)maxPts, (long long)minPts);
videodec/utils/aml_manage_pts.cc:376:        PTSLog(LOG_DEBUG_LEVEL1, "%s into list size:%d fDecoderDur:%f decoderDur:%d type:%s\n", __func__, (int)list->size(), fDecoderDur, decoderDur,type == 0 ? "outpts":"inpts");
videodec/utils/aml_manage_pts.cc:384:    PTSLog(LOG_DEBUG_LEVEL1, "%s into jumpPos:%d list size:%d max:%lld min:%lld i:%d decoderDur:%d type:%s\n", __func__, jumpPos, (int)list->size(),(long long)maxPts,(long long)minPts, i, decoderDur, type == 0 ? "outpts":"inpts");
videodec/utils/aml_manage_pts.cc:403:    PTSLog(LOG_DEBUG_LEVEL2, "%s --into, id[%d]csd[%d]mIsFirstFrameOutput[%d]mInPtsInvalid [%d]\n",
videodec/utils/aml_manage_pts.cc:417:            PTSLog(LOG_INFO, "%s id[%d] not found outPts[%lld]\n", __func__, bitStreamId, (long long)outPts);
videodec/utils/aml_manage_pts.cc:422:            PTSLog(LOG_DEBUG_LEVEL2, "%s id[%d] used last input pts\n", __func__, bitStreamId);
videodec/utils/aml_manage_pts.cc:431:        PTSLog(LOG_DEBUG_LEVEL2, "%s id[%d] used found input pts[%lld]\n", __func__, bitStreamId, (long long)outPts);
videodec/utils/aml_manage_pts.cc:453:            PTSLog(LOG_DEBUG_LEVEL2, "%s  push back inputTimestamp[%lld] outpts[%lld]\n", __func__, (long long)inputTimestamp, (long long)outPts);
videodec/utils/aml_manage_pts.cc:479:            PTSLog(LOG_DEBUG_LEVEL2, "%s  push back inputTimestamp[%lld] outpts[%lld]\n", __func__, (long long)inputTimestamp, (long long)outPts);
videodec/utils/aml_manage_pts.cc:483:        PTSLog(LOG_DEBUG_LEVEL2, "%s id[%d]input[%lld] outPts [%lld]mIsFirstFrameOutput[%d]\n", __func__, bitStreamId, (long long)inputTimestamp, (long long)outPts, mIsFirstFrameOutput);
videodec/utils/aml_manage_pts.cc:511:                    PTSLog(LOG_DEBUG_LEVEL2, "%s mSliceCountOneFrame[%d] dur[%d] id[%d]input[%lld] outPts [%lld] lastinput[%lld]\n",
videodec/utils/aml_manage_pts.cc:532:                    PTSLog(LOG_DEBUG_LEVEL2, "%s mSliceCountOneFrame[%d] dur[%d] id[%d]input[%lld] outPts [%lld]\n",
videodec/utils/aml_manage_pts.cc:546:            PTSLog(LOG_DEBUG_LEVEL2, "%s  push back inputTimestamp[%lld] outpts[%lld]\n", __func__, (long long)inputTimestamp, (long long)outPts);
videodec/utils/aml_manage_pts.cc:557:    PTSLog(LOG_DEBUG_LEVEL2, "%s id[%d]input[%lld] outPts [%lld]\n", __func__, bitStreamId, (long long)inputTimestamp, (long long)outPts);
videodec/utils/aml_manage_pts.cc:569:    PTSLog(LOG_DEBUG_LEVEL2, "%s --into, id[%d]csd[%d]mIsFirstFrameOutput[%d]mInPtsInvalid [%d]\n",
videodec/utils/aml_manage_pts.cc:600:            PTSLog(LOG_DEBUG_LEVEL2, "%s id[%d] used last input pts\n", __func__, bitStreamId);
videodec/utils/aml_manage_pts.cc:610:        PTSLog(LOG_DEBUG_LEVEL2, "%s id[%d] used found input pts[%lld]\n", __func__, bitStreamId, (long long)outPts);
videodec/utils/aml_manage_pts.cc:627:                    PTSLog(LOG_INFO, "%s slice count changed [%d]->[%d]\n", __func__, mSliceCountOneFrame, count);
videodec/utils/aml_manage_pts.cc:649:            PTSLog(LOG_DEBUG_LEVEL2, "%s push back inputTimestamp[%lld]\n", __func__, (long long)inputTimestamp);
videodec/utils/aml_manage_pts.cc:653:            PTSLog(LOG_DEBUG_LEVEL2, "%s push back lastPts[%lld]\n", __func__, (long long)lastPts);
videodec/utils/aml_manage_pts.cc:673:            PTSLog(LOG_DEBUG_LEVEL2, "%s  push back inputTimestamp[%lld] outpts[%lld]\n", __func__, (long long)inputTimestamp, (long long)outPts);
videodec/utils/aml_manage_pts.cc:700:            PTSLog(LOG_DEBUG_LEVEL2, "%s  push back inputTimestamp[%lld] outpts[%lld]\n", __func__, (long long)inputTimestamp, (long long)outPts);
videodec/utils/aml_manage_pts.cc:704:        PTSLog(LOG_DEBUG_LEVEL2, "%s id[%d]input[%lld] outPts [%lld]mIsFirstFrameOutput[%d]\n", __func__, bitStreamId, (long long)inputTimestamp, (long long)outPts, mIsFirstFrameOutput);
videodec/utils/aml_manage_pts.cc:736:                        //https://jira.amlogic.com/browse/SWPL-100925
videodec/utils/aml_manage_pts.cc:752:                    PTSLog(LOG_DEBUG_LEVEL2, "%s mSliceCountOneFrame[%d]step[%d] dur[%d] id[%d]input[%lld] outPts [%lld] lastinput[%lld]\n",
videodec/utils/aml_manage_pts.cc:783:                        PTSLog(LOG_DEBUG_LEVEL2, "%s id[%d]pts junmped input[%lld] last outPts [%lld]\n", __func__, bitStreamId, (long long)inputTimestamp, (long long)mLastOutPts);
videodec/utils/aml_manage_pts.cc:788:                        PTSLog(LOG_DEBUG_LEVEL2, "%s id[%d]pts junmped input[%lld] last outPts [%lld]\n", __func__, bitStreamId, (long long)inputTimestamp, (long long)mLastOutPts);
videodec/utils/aml_manage_pts.cc:793:                    PTSLog(LOG_DEBUG_LEVEL2, "%s mSliceCountOneFrame[%d]step[%d] diff[%d] dur[%d] id[%d]input[%lld] outPts [%lld]\n",
videodec/utils/aml_manage_pts.cc:817:                    //CtsMediaV2TestCases -t android.mediav2.cts.CodecDecoderSurfaceTest#testFlushNative[31(c2.amlogic.mpeg2.decoder_video/mpeg2)]
videodec/utils/aml_manage_pts.cc:837:                PTSLog(LOG_DEBUG_LEVEL2, "%s harfStep[%d] mSliceCountOneFrame[%d] dur[%d] id[%d]input[%lld] outPts [%lld]mLastOutPts[%lld]\n",
videodec/utils/aml_manage_pts.cc:862:            //add debug log
videodec/utils/aml_manage_pts.cc:873:            PTSLog(LOG_DEBUG_LEVEL2, "%s  push back inputTimestamp[%lld] outpts[%lld]\n", __func__, (long long)inputTimestamp, (long long)outPts);
videodec/utils/aml_manage_pts.cc:884:    PTSLog(LOG_DEBUG_LEVEL2, "%s id[%d]input[%lld] outPts [%lld]\n", __func__, bitStreamId, (long long)inputTimestamp, (long long)outPts);
videodec/utils/aml_manage_pts.cc:891:        PTSLog(LOG_INFO, "%s set duration[%d]type[%u]mDuration[%d]mIsInterlaced[%d]enable[%d]\n", __func__, duration, type, mDuration, mIsInterlaced, mEnableLockDurAndSliceCount);
videodec/utils/aml_manage_pts.cc:923:        //log error used default
videodec/utils/aml_manage_pts.cc:924:        PTSLog(LOG_INFO, "%s error duration[%d]type[%u]\n", __func__, duration, type);
videodec/utils/aml_manage_pts.cc:932:    PTSLog(LOG_INFO, "%s set interlace[%d]\n", __func__, interlace);
videodec/utils/aml_manage_pts.cc:938:    PTSLog(LOG_INFO, "%s set unstable[%d]\n", __func__, unstable);
videodec/utils/aml_manage_pts.cc:947:    PTSLog(LOG_INFO, "%s set avi discard[%d]\n", __func__, avi_discard);
videodec/utils/aml_manage_pts.cc:1000:            PTSLog(LOG_DEBUG_LEVEL2, "%s find same latestId [%d]\n", __func__, id);
videodec/utils/aml_manage_pts.cc:1004:            PTSLog(LOG_DEBUG_LEVEL2, "%s find not same lastestId: [%d] noteq:[%d]\n", __func__, id, bitStreamId);
videodec/utils/aml_manage_pts.cc:1010:            PTSLog(LOG_DEBUG_LEVEL2, "%s id not eq first: lastest:%d-lastestPushed:%d\n", __func__, id, bitStreamId);
videodec/utils/aml_manage_pts.cc:1017:            PTSLog(LOG_DEBUG_LEVEL2, "%s find same lastestPushedId [%d]as lastest pushed sliceCount:%d\n", __func__, latestPushedBitStreamId, sliceCount);
videodec/utils/aml_manage_pts.cc:1019:            PTSLog(LOG_DEBUG_LEVEL2, "%s find end sliceCount:%d  lastestPushedId[%d]lastestId[%d]\n", __func__, sliceCount, latestPushedBitStreamId, id);
videodec/utils/aml_manage_pts.cc:1025:    PTSLog(LOG_DEBUG_LEVEL2, "%s find end sliceCount:%d latest Id:%d size:%d\n", __func__, sliceCount, id, (int)mAmlOutBitStreamIdList->size());
videodec/utils/aml_manage_pts.cc:1038:            PTSLog(LOG_DEBUG_LEVEL3, "%s pts[%d]:%d jumped[%d]\n", __func__, i, (int)pts[i], jumpCount);
videodec/utils/aml_manage_pts.cc:1086:                        PTSLog(LOG_DEBUG_LEVEL3, "%s pts jumped posStart[%d]posEnd -1[%d]sum[%d]\n", __func__, posStart, posEnd -1, ptsCount);
videodec/utils/aml_manage_pts.cc:1096:                        PTSLog(LOG_DEBUG_LEVEL3, "%s pts jumped big posStart[%d]posEnd -1[%d]sum[%d]\n", __func__, posStart, posEnd -1, ptsCount);
videodec/utils/aml_manage_pts.cc:1105:            PTSLog(LOG_DEBUG_LEVEL3, "%s pts[%d]:%lld jump [%d]\n", __func__, i, (long long)pts[i], jumpCount);
videodec/utils/aml_manage_pts.cc:1123:        PTSLog(LOG_DEBUG_LEVEL2, "%s inPtsErrorCount:%d \n", __func__, inPtsErrorCount);
videodec/utils/aml_manage_pts.cc:1130:        PTSLog(LOG_DEBUG_LEVEL1, "%s into list size:%d posStart:%d posEnd:%d dur:%d mDuration:%d\n", __func__, (int)mAmlOutInputPtsList->size(),posStart,posEnd, (int)(pts[posEnd] - pts[posStart])/(posEnd - posStart), mDuration);
videodec/utils/aml_manage_pts.cc:1168:    //CtsMediaV2TestCases -t android.mediav2.cts.CodecDecoderValidationTest#testDecodeAndValidate[184(c2.amlogic.mpeg2.decoder_video/mpeg2)]
videodec/utils/aml_manage_pts.cc:1196:                PTSLog(LOG_DEBUG_LEVEL2, "%s [%d] diff:[%d] duration[%d] \n", __func__, (i - 1), diff, mDuration * (i - 1));
videodec/utils/aml_manage_pts.cc:1203:                PTSLog(LOG_DEBUG_LEVEL2, "%s [%d] maxPts:[%d] minPts[%d] duration[%d] mDuration[%d]\n", __func__, (i - 1), (int)maxPts, (int)minPts , dur, mDuration);
videodec/utils/aml_manage_pts.cc:1219:                    PTSLog(LOG_INFO, "%s pts jumped used default duration\n", __func__);
videodec/utils/aml_manage_pts.cc:1228:                PTSLog(LOG_DEBUG_LEVEL2, "%s [%d] maxPts:[%d]minPts[%d] duration[%d] mDuration[%d]\n", __func__, (i - 1), (int)maxPts, (int)minPts , dur, mDuration);
videodec/utils/aml_manage_pts.cc:1235:    PTSLog(LOG_DEBUG_LEVEL1, "%s find end duration:%d size:%d  i:%d jumpCount:%d\n", __func__, duration, (int)mAmlOutInputPtsList->size(), i, jumpCount);
videodec/utils/aml_manage_pts.cc:1257:    PTSLog(LOG_INFO, "%s  size:%d -- %d\n", __func__, size, (int)input_info_map_.size());
videodec/utils/aml_manage_pts.cc:1269:    PTSLog(LOG_INFO, "%s release\n", __func__);
videodec/utils/aml_manage_pts.cc:1277:        PTSLog(LOG_DEBUG_LEVEL3, "%s  free insert[%d]:[%d:%d]-%d:%d\n", __func__, mFreeId, input_info_map_[mFreeId].id,input_info_map_[mFreeId].flag,info.id, info.flag);
videodec/utils/aml_manage_pts.cc:1285:            PTSLog(LOG_DEBUG_LEVEL3, "%s  insert[%d]:[%d:%d]-%d:%d\n", __func__, (int)i, input_info_map_[i].id,input_info_map_[i].flag,info.id, info.flag);
videodec/utils/aml_manage_pts.cc:1294:        PTSLog(LOG_INFO, "%s  push:%d:%d\n", __func__, info.id, info.flag);
videodec/utils/aml_manage_pts.cc:1308:            PTSLog(LOG_DEBUG_LEVEL3, "%s  find[%d]:[%d:%d]\n", __func__, (int)i, input_info_map_[i].id,input_info_map_[i].flag);
videodec/utils/aml_manage_pts.cc:1317:        PTSLog(LOG_DEBUG_LEVEL3, "%s  erase[%d]:[%d:%d]\n", __func__, idx, input_info_map_[idx].id,input_info_map_[idx].flag);
videodec/utils/aml_manage_pts.cc:1341:    PTSLog(LOG_INFO, "%s size:%d  mCapability:%d instance:%d\n", __func__,size, mCapability, instance);
videodec/utils/aml_manage_pts.cc:1353:        PTSLog(LOG_DEBUG_LEVEL3, "%s  mCapability:%d mSize:%d\n", __func__, mCapability, mSize);
videodec/utils/aml_manage_pts.cc:1361:    PTSLog(LOG_DEBUG_LEVEL3, "%s  tmp-tail:%d list_info_[%d]:%d\n", __func__, tmp, mTail, (int)value);
videodec/utils/aml_manage_pts.cc:1368:        PTSLog(LOG_DEBUG_LEVEL3, "%s  mCapability:%d mSize:%d\n", __func__, mCapability, mSize);
videodec/utils/aml_manage_pts.cc:1376:    PTSLog(LOG_DEBUG_LEVEL3, "%s  tmp-head[%d]list_info_[%d]:%d\n", __func__, tmp, mHead, (int)value);
videodec/utils/aml_manage_pts.cc:1388:    PTSLog(LOG_DEBUG_LEVEL3, "%s  tmp-head:%d list_info_ head[%d]:size:%d\n", __func__, tmp, mHead, mSize);
videodec/utils/aml_manage_pts.cc:1400:    PTSLog(LOG_DEBUG_LEVEL3, "%s  tmp-tail:%dlist_info_ mTail[%d]:size:%d\n", __func__, tmp, mTail, mSize);
videodec/utils/aml_manage_pts.cc:1417:    PTSLog(LOG_DEBUG_LEVEL3, "%s  list_info_ mTail[%d]mHead[%d] idx:%d :info[%d]:%d size:%d\n", __func__,
videodec/utils/AmVideoDecProperty.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/utils/AmVideoDecProperty.cpp:16:#include <utils/Log.h>
videodec/utils/AmVideoDecProperty.cpp:29:        ALOGE("input parameter was NULL, VideoDec_propertyGetInt failed!");
videodec/utils/AmVideoDecProperty.cpp:35:        ALOGI("%s set = %d\n", newStr, *defaultValue);
videodec/utils/AmVideoDecProperty.cpp:41:            ALOGI("%s set = %d\n", oldStr, *defaultValue);
videodec/utils/AmVideoDecProperty.cpp:46:    ALOGI("%s is not set, used defaultValue = %d\n", oldStr, *defaultValue);
videodec/utils/AmVideoDecProperty.cpp:60:        ALOGE("input parameter was NULL, VideoDec_propertyGetBool failed!");
videodec/utils/AmVideoDecProperty.cpp:83:        ALOGE("input parameter was NULL, VideoDec_propertyGetInt32 failed!");
videodec/utils/ThreadUtil.cpp:1://#define LOG_NDEBUG 0
videodec/utils/ThreadUtil.cpp:2:#define LOG_TAG "ThreadUtil"
videodec/utils/ThreadUtil.cpp:3:#include <utils/Log.h>
videodec/utils/ThreadUtil.cpp:72:        ALOGD("%s:%d in", __func__, __LINE__);
videodec/utils/ThreadUtil.cpp:76:    ALOGD("%s:%d in", __func__, __LINE__);
videodec/utils/ThreadUtil.cpp:82:        ALOGD("%s:%d in", __func__, __LINE__);
videodec/utils/ThreadUtil.cpp:90:    ALOGD("%s:%d in", __func__, __LINE__);
videodec/utils/ThreadUtil.cpp:105:    ALOGD("%s:%d exit", __func__, __LINE__);
videodec/utils/ThreadUtil.cpp:111:    ALOGD("%s:%d in", __func__, __LINE__);
videodec/utils/ThreadUtil.cpp:148:    ALOGD("%s:%d threadid:%d", __func__, __LINE__, (int)mThread);
videodec/utils/ThreadUtil.cpp:153:    ALOGD("%s:%d in", __func__, __LINE__);
videodec/utils/ThreadUtil.cpp:160:                ALOGE("pthread on exit wait clean\n");
videodec/utils/ThreadUtil.cpp:171:        ALOGD("Worker is already running igonore start.");
videodec/utils/ThreadUtil.cpp:177:        ALOGE("pthread_create failed (err=%d)", ret);
videodec/utils/ThreadUtil.cpp:180:    ALOGD("%s:%d threadid:%d", __func__, __LINE__, (int)mThread);
videodec/utils/ThreadUtil.cpp:195:            ALOGW("pthread_join failed (err=%d)", ret);
videodec/utils/ThreadUtil.cpp:204:    ALOGD("%s:%d thread exit", __func__, __LINE__);
videodec/utils/ThreadUtil.cpp:220:    ALOGD("%s:%d in", __func__, __LINE__);
videodec/utils/ThreadUtil.cpp:230:    ALOGD("%s:%d in", __func__, __LINE__);
videodec/gitver.go:53:        dir = string(ctx.Config().Getenv("PWD")) + "/vendor/amlogic/common/" + "media_hal"
videodec/gitver.go:61:    buildname := " (" + string(ctx.Config().Getenv("LOGNAME")) + " "
videodec/gitver.go:99:    commitNumsCmd := "cd "+ getMediaHalRoot(ctx, sdkVersionInt) + " && git log | grep \"Change-Id: \" | grep -n " + strings.Replace(string(baseChangeIdout),"\n","",-1) + " | awk -F \":\" '{printf \"%d\", $1-1}'"
videodec/AmlDebugConfig.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/AmlDebugConfig.cpp:9:#define  LOG_TAG    "AmlDebugConfig"
videodec/AmlDebugConfig.cpp:12:#include <log/log.h>
videodec/AmlDebugConfig.cpp:22://     ALOGE("__AmlDebugConfig_init, mDebugServer:%p", mDebugServer);
videodec/AmlDebugConfig.cpp:25:static void onLogLevel(void *handler, const char *debug, int len) {
videodec/AmlDebugConfig.cpp:46:            resManHandle->resamn_add_debug_callback(mfd, onLogLevel, (void*)this);
videodec/AmlDebugConfig.cpp:50:        ALOGE("AmlDebugConfig init fail!");
videodec/AmlDebugConfig.cpp:57:        ALOGD("%s fd = %d", __FUNCTION__, mfd);
videodec/AmlDebugConfig.cpp:66:    ALOGI("AmlDebugConfig::report, MEDIAHAL_VERSION:%s, %s",
videodec/AmlDebugConfig.cpp:87:                mLogLevels[prop] = atoi(value.c_str());
videodec/AmlDebugConfig.cpp:90:            ALOGE("unknown debug command %s", cmd.c_str());
videodec/AmlDebugConfig.cpp:95:void AmlDebugConfig::addModuleLogLevel(void* moduleHandle, const string &propName, int logLevel) {
videodec/AmlDebugConfig.cpp:97:    ALOGD("adding handle:%p, propName: %s, level:%d", moduleHandle, propName.c_str(), logLevel);
videodec/AmlDebugConfig.cpp:98:    auto it = mModulesLogLevels.find(moduleHandle);
videodec/AmlDebugConfig.cpp:99:    if (it == mModulesLogLevels.end()) {
videodec/AmlDebugConfig.cpp:100:        if (mModulesLogLevels.size() >= kMaxModuleCount) {
videodec/AmlDebugConfig.cpp:101:            ALOGI("too many module log levels");
videodec/AmlDebugConfig.cpp:102:            auto item = mModulesLogLevels.begin();
videodec/AmlDebugConfig.cpp:103:            mLogLevels.erase(item->second);
videodec/AmlDebugConfig.cpp:104:            mModulesLogLevels.erase(item);
videodec/AmlDebugConfig.cpp:106:        mModulesLogLevels[moduleHandle] = propName;
videodec/AmlDebugConfig.cpp:107:        mLogLevels[propName] = logLevel;
videodec/AmlDebugConfig.cpp:109:        ALOGI("module handle %p already exists", moduleHandle);
videodec/AmlDebugConfig.cpp:110:        if (mLogLevels.find(propName) == mLogLevels.end()) {
videodec/AmlDebugConfig.cpp:111:            mLogLevels[propName] = logLevel;
videodec/AmlDebugConfig.cpp:113:            if (mLogLevels[propName] != logLevel) {
videodec/AmlDebugConfig.cpp:114:                mLogLevels[propName] = logLevel;
videodec/AmlDebugConfig.cpp:134:int AmlDebugConfig::getModuleLogLevel(void* moduleHandle) {
videodec/AmlDebugConfig.cpp:136:    auto it = mModulesLogLevels.find(moduleHandle);
videodec/AmlDebugConfig.cpp:137:    if (it == mModulesLogLevels.end()) {
videodec/AmlDebugConfig.cpp:138:        return kDefaultLogLevel;
videodec/AmlDebugConfig.cpp:140:    auto it2 = mLogLevels.find(it->second);
videodec/AmlDebugConfig.cpp:142:    return (it2 != mLogLevels.end()) ? it2->second : kDefaultLogLevel;
videodec/AmResManWrapper.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/AmResManWrapper.cpp:11:#define  LOG_TAG    "ResmanWrapper"
videodec/AmResManWrapper.cpp:15:// #include <log/log.h>
videodec/AmResManWrapper.cpp:16:#include <TspLogger.h>
videodec/AmResManWrapper.cpp:56:            ALOGE("dlsym error:%s", dlerror());
videodec/AmResManWrapper.cpp:61:            ALOGI("not support preempt");
videodec/AmResManWrapper.cpp:64:            ALOGI("not support codec mm estimate size");
videodec/AmResManWrapper.cpp:67:        ALOGW("dlopen libmediahal_resman.so error:%s", dlerror());
videodec/AmResManWrapper.cpp:87:        ALOGD("%s %s init, fd = %d", __FUNCTION__, appname, mfd);
videodec/AmResManWrapper.cpp:91:        ALOGE("%s init fail!", __FUNCTION__);
videodec/AmResManWrapper.cpp:98:        ALOGD("%s fd = %d", __FUNCTION__, mfd);
videodec/AmResManWrapper.cpp:157:        ALOGD("%s fd = %d", __FUNCTION__, mfd);
videodec/AmResManWrapper.cpp:166:        //ALOGD("%s fd = %d", __FUNCTION__, mfd);
videodec/AmResManWrapper.cpp:176:        ALOGD("%s fd = %d", __FUNCTION__, mfd);
videodec/amports/utils/JsonMsgGenerator.h:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videodec/amports/utils/debugSetup.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/utils/debugSetup.h:14:#include <utils/Log.h>
videodec/amports/utils/debugSetup.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/utils/debugSetup.cpp:12:#define LOG_NDEBUG 0
videodec/amports/utils/debugSetup.cpp:13:#define LOG_TAG "c2dbg"
videodec/amports/utils/debugSetup.cpp:28:        ALOGI("amcodec %s", sbuf);
videodec/amports/utils/debugSetup.cpp:54:    sDebugLevel = envGet("LOGLEVEL", 0);
videodec/amports/utils/debugSetup.cpp:70:                ALOGE("debugSetup for dumping received es stream failed.\n");
videodec/amports/utils/debugSetup.cpp:73:            ALOGE("debugSetup for dumping received es stream failed");
videodec/amports/utils/debugSetup.cpp:75:        ALOGV("vendor.media.omx.dumpRecv is disabled\n");
videodec/amports/utils/debugSetup.cpp:90:            ALOGE("debugSetup for dumping es stream written to hardware failed.\n");
videodec/amports/utils/debugSetup.cpp:92:        ALOGV("vendor.media.omx.dumpCodec is disabled\n");
videodec/amports/utils/JsonMsgGenerator.cpp:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videodec/amports/utils/JsonMsgGenerator.cpp:10:#define LOG_NDEBUG 0
videodec/amports/utils/JsonMsgGenerator.cpp:11:#define LOG_TAG "JsonMsgGenerator"
videodec/amports/utils/JsonMsgGenerator.cpp:18:#include <utils/Log.h>
videodec/amports/utils/JsonMsgGenerator.cpp:21:#define FLOGV(number,fmt,...) ALOGV("[No-%d]%s-%d " fmt, number, __FUNCTION__, __LINE__, ##__VA_ARGS__)
videodec/amports/utils/JsonMsgGenerator.cpp:22:#define FLOGI(number,fmt,...) ALOGI("[No-%d]%s-%d " fmt, number, __FUNCTION__, __LINE__, ##__VA_ARGS__)
videodec/amports/utils/JsonMsgGenerator.cpp:23:#define FLOGW(number,fmt,...) ALOGE("[No-%d]%s-%d " fmt, number, __FUNCTION__, __LINE__, ##__VA_ARGS__)
videodec/amports/utils/JsonMsgGenerator.cpp:24:#define FLOGE(number,fmt,...) ALOGE("[No-%d]%s-%d " fmt, number, __FUNCTION__, __LINE__, ##__VA_ARGS__)
videodec/amports/utils/JsonMsgGenerator.cpp:36:    FLOGI(mJsonInstansNo, "");
videodec/amports/utils/JsonMsgGenerator.cpp:43:    FLOGI(mJsonInstansNo, "");
videodec/amports/utils/JsonMsgGenerator.cpp:52:        FLOGE(mJsonInstansNo, "ERROR:data is NULL Pointer");
videodec/amports/utils/JsonMsgGenerator.cpp:58:        FLOGE(mJsonInstansNo, "ERROR: data_len is 0");
videodec/amports/utils/JsonMsgGenerator.cpp:63:        FLOGE(mJsonInstansNo, "ERROR: data_len %d Not Enough! %d is ok\n", (int)data_len, JSON_MAX_SIZE);
videodec/amports/utils/JsonMsgGenerator.cpp:68:        FLOGE(mJsonInstansNo, "ERROR: framerate %u abnormal\n", framerate);
videodec/amports/utils/JsonMsgGenerator.cpp:75:        FLOGE(mJsonInstansNo, "ERROR: queue_size empty\n");
videodec/amports/utils/JsonMsgGenerator.cpp:96:            FLOGE(mJsonInstansNo, "error empty i:%d, queue_size:%d, framerate:%d",
videodec/amports/utils/JsonMsgGenerator.cpp:139:        FLOGE(mJsonInstansNo, "Error: %d OutOf %d data_len", (int)jsonSize, (int)data_len);
videodec/amports/utils/video_codecs.cc:9:#include "base/logging.h"
videodec/amports/AmCodecVDA.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/AmCodecVDA.h:43:#define TVP_SECRET "amlogic_omx_decoder,pts="
videodec/amports/device/AmCodecV4l2OutputDevice.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/device/AmCodecV4l2OutputDevice.h:63:#define V4L2_CID_USER_AMLOGIC_IONVIDEO_BASE   (V4L2_CID_USER_BASE + 0x1100)
videodec/amports/device/AmCodecV4l2OutputDevice.h:64:#define V4L2_CID_USER_AMLOGIC_AMLVIDEO_BASE   (V4L2_CID_USER_BASE + 0x1100)
videodec/amports/device/mediaconfig.cpp:2: * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
videodec/amports/device/mediaconfig.cpp:16:#include <cutils/log.h>
videodec/amports/device/mediaconfig.cpp:93:        ALOGE("open %s, failed %d, err=%s(%d)\n",
videodec/amports/device/AmCodecWrapper.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/device/AmCodecUserdataDevice.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/device/mediaconfig.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:12://#define LOG_NDEBUG 0
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:13:#define LOG_TAG "AmCodecV4l2OutputDevice"
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:23:#include <utils/Log.h>
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:29:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:30:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:31:#define FLOGW(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:32:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:60:    FLOGI(mPlayerInstansNo,"");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:65:        FLOGV(mPlayerInstansNo,"get v4lvideo_version \n");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:69:        FLOGE(mPlayerInstansNo,"get v4lvideo_version fail ");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:79:        FLOGI(mPlayerInstansNo,"get v4lvideo_version \n");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:82:        FLOGE(mPlayerInstansNo,"get v4lvideo_version fail ");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:94:    FLOGI(mPlayerInstansNo,"in\n");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:100:            FLOGI(mPlayerInstansNo,"codec free_ion_id failed, ret=%d", ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:102:        FLOGI(mPlayerInstansNo,"free ION Video device instance ID:%d", mVideoDevId);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:105:        FLOGI(mPlayerInstansNo,"close ionvideo\n");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:112:        FLOGI(mPlayerInstansNo,"close amvideo\n");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:119:            ALOGI("codec free_v4lvideo_id failed, ret=%d", ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:121:        FLOGI(mPlayerInstansNo,"close in v4lvideo mV4lvideoHandle : %d,mReceived ID:%d,mDevName:%s\n",mV4lvideoHandle,mVideoDevId,mDevName);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:126:    FLOGI(mPlayerInstansNo,"out");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:135:            FLOGI(mPlayerInstansNo,"-----> open /dev/ionvideo \n");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:138:                FLOGE(mPlayerInstansNo,"can not open ionvideo");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:144:                    FLOGI(mPlayerInstansNo,"codec get_ion_id failed, ret=%x", ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:147:                FLOGI(mPlayerInstansNo,"alloc ION Video device instance ID:%d", mVideoDevId);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:154:        FLOGI(mPlayerInstansNo," open /dev/v4lvideo \n");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:157:            FLOGE(mPlayerInstansNo,"can not open v4lvideo");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:162:                ALOGE("codec get v4lvideo id failed, ret=%x", ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:165:            FLOGI(mPlayerInstansNo,"(%p) alloc v4lvideo device instance mV4lvideoHandle:%d ID:%d",
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:168:        FLOGI(mPlayerInstansNo," open /dev/v4lvideo mDevName %s\n",mDevName);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:179:        FLOGE(mPlayerInstansNo,"v4l device %s open failed! ret=%d,%s(%d), retry %d\n",
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:185:        FLOGE(mPlayerInstansNo,"v4l device %s open failed!,id=%d,ret=%d,%s(%d), mDisplayMode %d\n", mDevName, mVideoDevId,
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:191:                FLOGE(mPlayerInstansNo,"IONVIDEO_IOCTL_FREE_ID fail mIonvideoHandle:%d ret %d\n",mIonvideoHandle,ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:203:                FLOGE(mPlayerInstansNo,"V4LVIDEO_IOCTL_FREE_ID fail ret %d\n", ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:209:    FLOGI(mPlayerInstansNo,"V4L DEVICE open %s, mFd %d\n",mDevName, mFd);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:215:        ctl.id = V4L2_CID_USER_AMLOGIC_IONVIDEO_BASE;
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:218:          //LOGE("Set freerun_mode: %s. ret=%d", strerror(errno),ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:226:    FLOGI(mPlayerInstansNo,"V4L DEVICE setfmt %s, ret %d\n", mDevName, ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:228:    FLOGI(mPlayerInstansNo,"V4L DEVICE start ret %d\n", ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:234:        FLOGI(mPlayerInstansNo,"getReceiveId receiveid %d,mDevName:%s\n", mVideoDevId,mDevName);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:244:            //ALOGD("AMSTREAM_IOC_GET_OMX_VPTS");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:254:        FLOGE(mPlayerInstansNo,"GET_OMX_VPTS ret=%d\n", ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:266:            FLOGE(mPlayerInstansNo,"AMSTREAM_IOC_SET_OMX_VPTS ret=%d\n", ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:273:        FLOGE(mPlayerInstansNo,"SET_OMX_VPTS ret=%d\n", ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:279:    FLOGI(mPlayerInstansNo,"%s\n",__FUNCTION__);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:287:             FLOGE(mPlayerInstansNo,"amlv4l_ioctlfailed!, mFd %d, request=%x,ret=%d,%s(%d)\n", mFd, request,
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:307:        FLOGI(mPlayerInstansNo,"dqbuf ret %d %s\n", ret,strerror(errno));
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:327:        FLOGV(mPlayerInstansNo,"dqbuf,fd %d,INDEX %d, vf->pts = %" PRId64 ", vf->sync_frame=%d ,mreceive Id:%d,mDevName:%s",
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:336:            memcpy(&vf->am_parm, &v4l2_parm.parm.capture, sizeof(struct v4l2_amlogic_parm));
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:338:            FLOGE(mPlayerInstansNo,"ret_1=%d", ret_1);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:358:    //ALOGI("qbuf fd %d, index %d, mreceive Id:%d,mDevName:%s\n", vbuf.m.fd, vbuf.index,mVideoDevId,mDevName);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:363:        FLOGI(mPlayerInstansNo,"qbuf fail ret %d\n", ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:369:        FLOGE(mPlayerInstansNo,"Alloc_Decode_Fd failed (mV4lvideoHandle:%d)", mV4lvideoHandle);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:373:    //ALOGI("%s:%d\n",__FUNCTION__,__LINE__);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:376:        FLOGE(mPlayerInstansNo,"call V4LVIDEO ioctl failed (%d).", err);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:381:        FLOGE(mPlayerInstansNo,"V4LVIDEO_IOCTL_ALLOC_FD return invalid fd (%d).", fd);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:383:    //ALOGI("%s:%d fd:%d\n",__FUNCTION__,__LINE__,fd);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:390:        FLOGE(mPlayerInstansNo,"V4LVIDEO_IOCTL_ALLOC_FD return invalid fd (%d:%d).", src_fd,dst_fd);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:397:    //ALOGI("%s:%d,src_fd:%d,dst_fd:%d,err:%d\n",__FUNCTION__,__LINE__,src_fd,dst_fd,err);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:399:        FLOGE(mPlayerInstansNo,"call V4LVIDEO ioctl failed (%d).", err);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:410:    //ALOGI("%s:%d,fd:%d\n",__FUNCTION__,__LINE__,fd);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:419:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:426:            FLOGI(mPlayerInstansNo,"stream on fail, ret %d, mReceiveId:%d,mDevName:%s\n", ret,mVideoDevId,mDevName);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:430:        FLOGI(mPlayerInstansNo,"already stream on, ret %d, mReceiveId:%d,mDevName:%s\n", ret,mVideoDevId,mDevName);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:432:    FLOGI(mPlayerInstansNo,"ok");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:437:    FLOGI(mPlayerInstansNo,"mDevName:%s",mDevName);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:443:        FLOGI(mPlayerInstansNo,"stream off, ret %d, mReceiveId:%d,mDevName:%s\n", ret,mVideoDevId,mDevName);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:445:            FLOGI(mPlayerInstansNo,"stream off fail, ret %d\n", ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:450:        FLOGI(mPlayerInstansNo,"already stream off\n");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:461:        FLOGE(mPlayerInstansNo,"VIDIOC_G_FMT failed,ret=%d\n", ret);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:468:    FLOGI(mPlayerInstansNo,"in ,mDevName:%s",mDevName);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:471:        FLOGI(mPlayerInstansNo,"out mFd < 0 mDevName:%s",mDevName);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:477:        FLOGI(mPlayerInstansNo,"close in mFd:%d\n",mFd);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:479:        FLOGI(mPlayerInstansNo,"close ok!ret:%d %s mFd:%d\n",ret,strerror(errno),mFd);
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:485:    FLOGI(mPlayerInstansNo,"out");
videodec/amports/device/AmCodecV4l2OutputDevice.cpp:490:    FLOGI(mPlayerInstansNo,"mNumOutputBuffers %d\n", mNumOutputBuffers);
videodec/amports/device/amvideo.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/device/amvideo.h:37:/* v4l2_amlogic_parm must < u8[200] */
videodec/amports/device/amvideo.h:38:struct v4l2_amlogic_parm {
videodec/amports/device/amvideo.h:58:    struct v4l2_amlogic_parm am_parm;
videodec/amports/device/vcodec.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/device/AmCodecWrapper.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/device/AmCodecWrapper.cpp:12:#define LOG_NDEBUG 0
videodec/amports/device/AmCodecWrapper.cpp:13:#define LOG_TAG "AmCodecWrapper"
videodec/amports/device/AmCodecWrapper.cpp:27:#include <android/log.h>
videodec/amports/device/AmCodecWrapper.cpp:35:#include <TspLogger.h>
videodec/amports/device/AmCodecWrapper.cpp:48:    ALOGI("AmCodecWrapper mCodecParam %p, drmmode %d\n", (void*)mCodecParam, drmmode);
videodec/amports/device/AmCodecWrapper.cpp:56:    ALOGI("mVideoPath %d\n", mVideoPath);
videodec/amports/device/AmCodecWrapper.cpp:60:    ALOGI("~AmCodecWrapper,receive_id:%d",mCodecParam->receive_id);
videodec/amports/device/AmCodecWrapper.cpp:68:        ALOGI("setVideoConfig config_len %d config:%s\n", config_len,config);
videodec/amports/device/AmCodecWrapper.cpp:81:    ALOGI("setUnstablePts, unstable:%d", unstable);
videodec/amports/device/AmCodecWrapper.cpp:108:    ALOGI("setFormat vformat %d, aformat %d, vpid %d, apid %d pcrid %d \n",
videodec/amports/device/AmCodecWrapper.cpp:115:    ALOGI("setVideoStreamType type %d\n", streamtype);
videodec/amports/device/AmCodecWrapper.cpp:122:    ALOGI("setResolution width %d, height %d\n", width, height);
videodec/amports/device/AmCodecWrapper.cpp:128:    ALOGI("setVideoType type %d\n", type);
videodec/amports/device/AmCodecWrapper.cpp:135:    ALOGI("setFramebasePath PATH %d\n", path);
videodec/amports/device/AmCodecWrapper.cpp:141:    ALOGI("setReceiveId receiveid %d\n", receiveid);
videodec/amports/device/AmCodecWrapper.cpp:148:    ALOGI("setMediasyncVfmDevId mediasync_vfm_dec_id %d\n", mediasync_vfm_dev_id);
videodec/amports/device/AmCodecWrapper.cpp:156:    ALOGI("mDemuxType %d dmx_dev_id:%d dmx_player_id:%d\n", mCodecParam->mDemuxType,dmx_dev_id,dmx_player_id);
videodec/amports/device/AmCodecWrapper.cpp:163:    ALOGI("setDemuxStbufInfo start:0x%x size:%d\n",stbuf_start,stbuf_size);
videodec/amports/device/AmCodecWrapper.cpp:169:    ALOGI("setPtsServerId : %d \n",ptsServerId);
videodec/amports/device/AmCodecWrapper.cpp:177:    ALOGI("vcodec_init format(%d) [%d:%d], type %d, dves_type:%d, rate %d, path %d, ret %d\n",
videodec/amports/device/AmCodecWrapper.cpp:220:    //ALOGI("vcodec_write buffer %x-%x-%x-%x-%x-%x-%x-%x, len %d, ret %d\n",
videodec/amports/device/AmCodecWrapper.cpp:229:    ALOGI("vcodec_close ret %d\n", ret);
videodec/amports/device/AmCodecWrapper.cpp:257:        ALOGE("input parameter is NULL, setFccMode failed\n");
videodec/amports/device/AmCodecWrapper.cpp:260:    ALOGI("AmCodecWrapper::setFccMode\n");
videodec/amports/device/AmCodecWrapper.cpp:267:        ALOGE("input parameter is NULL, resetAudio failed\n");
videodec/amports/device/AmCodecWrapper.cpp:270:    ALOGI("AmCodecWrapper::resetAudio\n");
videodec/amports/device/AmCodecWrapper.cpp:303:        //ALOGI("slots = %d frame_width:%d\n",slots,para.minfo[para.slots-1].frame_width);
videodec/amports/device/AmCodecWrapper.cpp:351:    ALOGI("AmCodecWrapper::start\n");
videodec/amports/device/AmCodecWrapper.cpp:358:    ALOGI("AmCodecWrapper::stop\n");
videodec/amports/device/AmCodecWrapper.cpp:364:    ALOGI("AmCodecWrapper::pause\n");
videodec/amports/device/AmCodecWrapper.cpp:369:    ALOGI("AmCodecWrapper::resume\n");
videodec/amports/device/AmCodecWrapper.cpp:375:    ALOGI("reset receiveid %d\n", mCodecParam->receive_id);
videodec/amports/device/AmCodecWrapper.cpp:430:    ALOGI("AmCodecWrapper::disableVideo %d\n", disable);
videodec/amports/device/AmCodecWrapper.cpp:436:    ALOGI("AmCodecWrapper::setBlackout\n");
videodec/amports/device/AmCodecWrapper.cpp:445:        ALOGI("AmCodecWrapper::getFirstFrameToggled mediasync_vfm_dev_id:%d count:%d\n",mCodecParam->mediasync_vfm_dev_id,mGetToggledCount);
videodec/amports/device/AmCodecWrapper.cpp:454:    ALOGI("AmCodecWrapper::setFastSpeed speed %d\n", speed);
videodec/amports/device/AmCodecWrapper.cpp:470:    ALOGI("AmCodecWrapper::setVideoAxis\n");
videodec/amports/device/AmCodecWrapper.cpp:477:    ALOGI("AmCodecWrapper::setVideoCrop\n");
videodec/amports/device/AmCodecWrapper.cpp:484:    ALOGI("AmCodecWrapper::setSyncMode %d\n", mode);
videodec/amports/device/AmCodecWrapper.cpp:490:    ALOGI("AmCodecWrapper::setVideoWorkMode %d\n", workmode);
videodec/amports/device/AmCodecWrapper.cpp:506:    ALOGI("AmCodecWrapper::setInstansNo %d\n", InstansNo);
videodec/amports/device/AmCodecWrapper.cpp:549:    ALOGI("AmCodecWrapper::setTsyncEnable %d\n", enable);
videodec/amports/device/AmCodecWrapper.cpp:555:    ALOGI("AmCodecWrapper::setVfmMap %s\n", val);
videodec/amports/device/AmCodecWrapper.cpp:561:    ALOGI("AmCodecWrapper::setFastShowFrameEnable %d\n", enable);
videodec/amports/device/AmCodecWrapper.cpp:567:    ALOGI("AmCodecWrapper::setVideoPid %d\n", pid);
videodec/amports/device/AmCodecWrapper.cpp:575:    ALOGI("AmCodecWrapper::setVideoFormat %d\n", fmt);
videodec/amports/device/AmCodecWrapper.cpp:582:    ALOGI("AmCodecWrapper::getVideoCodeIsInit\n");
videodec/amports/device/vcodec.cpp:2: * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
videodec/amports/device/vcodec.cpp:18:/* Copyright (C) 2007-2011, Amlogic Inc.
videodec/amports/device/vcodec.cpp:23:#define LOG_NDEBUG 0
videodec/amports/device/vcodec.cpp:24:#define  LOG_TAG    "amcodec"
videodec/amports/device/vcodec.cpp:39:#include <android/log.h>
videodec/amports/device/vcodec.cpp:45:#include <TspLogger.h>
videodec/amports/device/vcodec.cpp:47://#define CODEC_PRINT(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
videodec/amports/device/vcodec.cpp:48:#define CODEC_PRINT(...) ALOGI(__VA_ARGS__)
videodec/amports/device/AmCodecUserdataDevice.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/device/AmCodecUserdataDevice.cpp:12://#define LOG_NDEBUG 0
videodec/amports/device/AmCodecUserdataDevice.cpp:13:#define LOG_TAG "AmCodecUserdataDevice"
videodec/amports/device/AmCodecUserdataDevice.cpp:24:#include <utils/Log.h>
videodec/amports/device/AmCodecUserdataDevice.cpp:37:    ALOGI("AmCodecUserdataDevice\n");
videodec/amports/device/AmCodecUserdataDevice.cpp:42:    ALOGI("~~AmCodecUserdataDevice\n");
videodec/amports/device/AmCodecUserdataDevice.cpp:65:    ALOGI("AmCodecUserdataDevice init fd %d\n", mFd);
videodec/amports/device/AmCodecUserdataDevice.cpp:95:        ALOGI("call AMSTREAM_IOC_GET_MVDECINFO failed\n");
videodec/amports/device/AmCodecUserdataDevice.cpp:110:        ALOGI("call AMSTREAM_IOC_GET_MVDECINFO failed\n");
videodec/amports/device/AmCodecUserdataDevice.cpp:136:        ALOGE("get avaible vdec failed");
videodec/amports/device/AmCodecUserdataDevice.cpp:140:        ALOGE("playerID is not match read_vdec_id=%d,mPlayerInstansNo=%d",read_vdec_id,mPlayerInstansNo);
videodec/amports/device/AmCodecUserdataDevice.cpp:146:    //         ALOGE("AMSTREAM_IOC_UD_FLUSH_USERDATA failed");
videodec/amports/device/AmCodecUserdataDevice.cpp:156:    ALOGI("AmCodecUserdataDevice, mPlayerInstansNo:%d", mPlayerInstansNo);
videodec/amports/device/AmCodecUserdataDevice.cpp:171:        ALOGI("call AMSTREAM_IOC_UD_BUF_READ failed cmd:0x%x\n",(int)AMSTREAM_IOC_UD_BUF_READ);
videodec/amports/device/AmCodecUserdataDevice.cpp:173:        /*ALOGI("ioctl left data: %d, data_size %d\n",
videodec/amports/device/AmCodecUserdataDevice.cpp:274:            ALOGE("do not support vformat %d\n", mFormat);
videodec/amports/device/AmCodecUserdataDevice.cpp:276:    ALOGV("checkFormat %d\n", mType);
videodec/amports/device/AmCodecUserdataDevice.cpp:288:    ALOGI("[writeData] poc %d, pts %u, mNotifyData.size() %d\n", poc, pts,(int)mNotifyData.size());
videodec/amports/device/AmCodecUserdataDevice.cpp:387:                ALOGI("MPEG AFD notify %d, flag:%d\n", afd.af, afd.af_flag);
videodec/amports/device/AmCodecUserdataDevice.cpp:489:                ALOGI("H264 AFD notify %d\n", afd.af);
videodec/amports/formatters/AmCodecVDAVP9.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAMpeg4.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAMpeg4.cpp:12:#define LOG_NDEBUG 0
videodec/amports/formatters/AmCodecVDAMpeg4.cpp:13:#define LOG_TAG "AmCodecVDA"
videodec/amports/formatters/AmCodecVDAMpeg4.cpp:15:#include <utils/Log.h>
videodec/amports/formatters/AmCodecVDAMpeg4.cpp:20:    ALOGI("AmCodecVDAMpeg4");
videodec/amports/formatters/AmCodecVDAMpeg4.cpp:25:    ALOGI("~AmCodecVDAMpeg4");
videodec/amports/formatters/AmCodecVDAMpeg4.cpp:29:    ALOGI("AmCodecVDAMpeg4::codecInit");
videodec/amports/formatters/AmCodecVDAMpeg4.cpp:45:    ALOGI("AmCodecVDAMpeg4::doCodecSpec");
videodec/amports/formatters/AmCodecVDAMpeg12.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAH265.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAH265.cpp:12://#define LOG_NDEBUG 0
videodec/amports/formatters/AmCodecVDAH265.cpp:13:#define LOG_TAG "AmCodecVDA"
videodec/amports/formatters/AmCodecVDAH265.cpp:16:#include <utils/Log.h>
videodec/amports/formatters/AmCodecVDAH265.cpp:23:    ALOGI("AmCodecVDAH265");
videodec/amports/formatters/AmCodecVDAH265.cpp:28:    ALOGI("~AmCodecVDAH265");
videodec/amports/formatters/AmCodecVDAH265.cpp:32:    ALOGI("AmCodecVDAH265::codecInit");
videodec/amports/formatters/AmCodecVDAH265.cpp:43:    ALOGI("AmCodecVDAH265::doCodecSpec");
videodec/amports/formatters/AmCodecVDAH265.cpp:78:        ALOGV("AmCodecVDAH265 buf %x-%x-%x-%x-%x-%x-%x-%x\n",
videodec/amports/formatters/AmCodecVDAH265.cpp:86:        ALOGI("copy csd size %d, mCsdBufSize %d\n", size, mCsdBufSize);
videodec/amports/formatters/AmCodecVDAH265.cpp:92:        ALOGI("add csd essize %d, csdsize %d\n", size, mCsdBufSize);
videodec/amports/formatters/AmCodecVDAVP9.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAVP9.cpp:12:#define LOG_NDEBUG 0
videodec/amports/formatters/AmCodecVDAVP9.cpp:13:#define LOG_TAG "AmCodecVDA"
videodec/amports/formatters/AmCodecVDAVP9.cpp:15:#include <utils/Log.h>
videodec/amports/formatters/AmCodecVDAVP9.cpp:22:    ALOGI("AmCodecVDAVP9");
videodec/amports/formatters/AmCodecVDAVP9.cpp:27:    ALOGI("~AmCodecVDAVP9");
videodec/amports/formatters/AmCodecVDAVP9.cpp:31:    ALOGI("AmCodecVDAVP9::codecInit");
videodec/amports/formatters/AmCodecVDAVP9.cpp:45:    ALOGI("AmCodecVDAVP9::doCodecSpec");
videodec/amports/formatters/AmCodecVDAVP9.cpp:80:            //ALOGI(" frame_number : %d, mag : %d; index_sz : %d\n", frame_number, mag, index_sz);
videodec/amports/formatters/AmCodecVDAVP9.cpp:84:                ALOGI(" Wrong marker2 : 0x%X --> 0x%X\n", marker, buf[mag_ptr]);
videodec/amports/formatters/AmCodecVDAVP9.cpp:109:            ALOGE("DATA overflow : 0x%X --> 0x%X\n", total_datasize, dsize);
videodec/amports/formatters/AmCodecVDAVP9.cpp:124:            /*add amlogic frame headers.*/
videodec/amports/formatters/AmCodecVDAVP9.cpp:145:                ALOGI("data has gaps,set to 0\n");
videodec/amports/formatters/AmCodecVDAVP9.cpp:148:                ALOGI("ERROR!!! data over writed!!!! over write %d\n",(int)(fdata + 16 + framesize - old_header));
videodec/amports/formatters/AmCodecVDAAV1.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAH264.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAAVS3.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAMpeg4.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAMpeg2ts.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAMpeg2ts.cpp:12:#define LOG_NDEBUG 0
videodec/amports/formatters/AmCodecVDAMpeg2ts.cpp:13:#define LOG_TAG "AmCodecVDA"
videodec/amports/formatters/AmCodecVDAMpeg2ts.cpp:15:#include <utils/Log.h>
videodec/amports/formatters/AmCodecVDAMpeg2ts.cpp:20:    ALOGI("AmCodecVDAMpeg2ts");
videodec/amports/formatters/AmCodecVDAMpeg2ts.cpp:25:    ALOGI("~AmCodecVDAMpeg2ts");
videodec/amports/formatters/AmCodecVDAMpeg2ts.cpp:29:    ALOGI("AmCodecVDAMpeg2ts::codecInit");
videodec/amports/formatters/AmCodecVDAMpeg2ts.cpp:36:    ALOGI("display mode %d, vformat %d\n", mDisplayMode, mFormat);
videodec/amports/formatters/AmCodecVDAMpeg2ts.cpp:46:    ALOGI("AmCodecVDAMpeg2ts::doCodecSpec");
videodec/amports/formatters/AmCodecVDAH264.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAH264.cpp:12://#define LOG_NDEBUG 0
videodec/amports/formatters/AmCodecVDAH264.cpp:13:#define LOG_TAG "AmCodecVDA"
videodec/amports/formatters/AmCodecVDAH264.cpp:15:#include <utils/Log.h>
videodec/amports/formatters/AmCodecVDAH264.cpp:20:    ALOGI("AmCodecVDAH264");
videodec/amports/formatters/AmCodecVDAH264.cpp:25:    ALOGI("~AmCodecVDAH264");
videodec/amports/formatters/AmCodecVDAH264.cpp:29:    ALOGI("AmCodecVDAH264::codecInit");
videodec/amports/formatters/AmCodecVDAH264.cpp:44:    ALOGI("AmCodecVDAH264::doCodecSpec");
videodec/amports/formatters/AmCodecVDAH264.cpp:69:        ALOGI("AmCodecVDAH264 buf %x-%x-%x-%x-%x-%x-%x-%x\n",
videodec/amports/formatters/AmCodecVDAH264.cpp:77:        ALOGI("copy csd size %d, mCsdBufSize %d\n", size, mCsdBufSize);
videodec/amports/formatters/AmCodecVDAH264.cpp:83:        ALOGI("add csd essize %d, csdsize %d\n", size, mCsdBufSize);
videodec/amports/formatters/AmCodecVDAH266.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAH266.cpp:12://#define LOG_NDEBUG 0
videodec/amports/formatters/AmCodecVDAH266.cpp:13:#define LOG_TAG "AmCodecVDA"
videodec/amports/formatters/AmCodecVDAH266.cpp:16:#include <utils/Log.h>
videodec/amports/formatters/AmCodecVDAH266.cpp:23:    ALOGI("AmCodecVDAH266");
videodec/amports/formatters/AmCodecVDAH266.cpp:28:    ALOGI("~AmCodecVDAH266");
videodec/amports/formatters/AmCodecVDAH266.cpp:32:    ALOGI("AmCodecVDAH266::codecInit");
videodec/amports/formatters/AmCodecVDAH266.cpp:43:    ALOGI("AmCodecVDAH266::doCodecSpec");
videodec/amports/formatters/AmCodecVDAH266.cpp:67:        ALOGV("AmCodecVDAH266 buf %x-%x-%x-%x-%x-%x-%x-%x\n",
videodec/amports/formatters/AmCodecVDAH266.cpp:75:        ALOGI("copy csd size %d, mCsdBufSize %d\n", size, mCsdBufSize);
videodec/amports/formatters/AmCodecVDAH266.cpp:81:        ALOGI("add csd essize %d, csdsize %d\n", size, mCsdBufSize);
videodec/amports/formatters/AmCodecVDAAVS2.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAAVS2.cpp:12://#define LOG_NDEBUG 0
videodec/amports/formatters/AmCodecVDAAVS2.cpp:13:#define LOG_TAG "AmCodecVDA"
videodec/amports/formatters/AmCodecVDAAVS2.cpp:16:#include <utils/Log.h>
videodec/amports/formatters/AmCodecVDAAVS2.cpp:23:    ALOGI("AmCodecVDAAVS2");
videodec/amports/formatters/AmCodecVDAAVS2.cpp:28:    ALOGI("~AmCodecVDAAVS2");
videodec/amports/formatters/AmCodecVDAAVS2.cpp:32:    ALOGI("AmCodecVDAAVS2::codecInit");
videodec/amports/formatters/AmCodecVDAAVS2.cpp:43:    ALOGI("AmCodecVDAAVS2::doCodecSpec");
videodec/amports/formatters/AmCodecVDAMpeg12.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAMpeg12.cpp:12:#define LOG_NDEBUG 0
videodec/amports/formatters/AmCodecVDAMpeg12.cpp:13:#define LOG_TAG "AmCodecVDA"
videodec/amports/formatters/AmCodecVDAMpeg12.cpp:15:#include <utils/Log.h>
videodec/amports/formatters/AmCodecVDAMpeg12.cpp:20:    ALOGI("AmCodecVDAMpeg12");
videodec/amports/formatters/AmCodecVDAMpeg12.cpp:25:    ALOGI("~AmCodecVDAMpeg12");
videodec/amports/formatters/AmCodecVDAMpeg12.cpp:29:    ALOGI("AmCodecVDAMpeg12::codecInit");
videodec/amports/formatters/AmCodecVDAMpeg12.cpp:47:    ALOGI("AmCodecVDAMpeg12::doCodecSpec");
videodec/amports/formatters/AmCodecVDAAV1.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAAV1.cpp:12:#define LOG_NDEBUG 0
videodec/amports/formatters/AmCodecVDAAV1.cpp:13:#define LOG_TAG "AmCodecVDA"
videodec/amports/formatters/AmCodecVDAAV1.cpp:15:#include <utils/Log.h>
videodec/amports/formatters/AmCodecVDAAV1.cpp:21:    ALOGI("AmCodecVDAAV1");
videodec/amports/formatters/AmCodecVDAAV1.cpp:25:    ALOGI("AmCodecVDAAV1");
videodec/amports/formatters/AmCodecVDAAV1.cpp:29:    ALOGI("AmCodecVDAAV1::codecInit");
videodec/amports/formatters/AmCodecVDAAV1.cpp:45:    ALOGI("AmCodecVDAAV1::doCodecSpec");
videodec/amports/formatters/AmCodecVDAAV1.cpp:66:        ALOGI("buf is null");
videodec/amports/formatters/AmCodecVDAAV1.cpp:81:        ALOGI("[1] aml_es_bytes_left : %ld\n", aml_es_bytes_left);
videodec/amports/formatters/AmCodecVDAAV1.cpp:119:            ALOGE("[line:%d] Error aml_es_bytes_left : %ld\n",  __LINE__, aml_es_bytes_left);
videodec/amports/formatters/AmCodecVDAAV1.cpp:125:        ALOGI("[2] aml_es_bytes_left : %ld\n", aml_es_bytes_left);
videodec/amports/formatters/AmCodecVDAAV1.cpp:140:        ALOGE("buf is null");
videodec/amports/formatters/AmCodecVDAAV1.cpp:149:    ALOGD("buf[0]:%x aml_es_ptr:%ld aml_es_bytes_left:%ld ", buf[0],aml_es_ptr,aml_es_bytes_left);
videodec/amports/formatters/AmCodecVDAAV1.cpp:152:    ALOGD("frame_number:%d essize:%d", frame_number,*essize);
videodec/amports/formatters/AmCodecVDAAV1.cpp:203:            case OBU_SEQUENCE_HEADER:{ALOGD("OBU_SEQUENCE_HEADER\n"); break;}
videodec/amports/formatters/AmCodecVDAAV1.cpp:204:            case OBU_TEMPORAL_DELIMITER:{ALOGD("OBU_TEMPORAL_DELIMITER\n"); break;}
videodec/amports/formatters/AmCodecVDAAV1.cpp:205:            case OBU_FRAME_HEADER:{ALOGD("OBU_FRAME_HEADER\n"); break;}
videodec/amports/formatters/AmCodecVDAAV1.cpp:206:            case OBU_TILE_GROUP:{ALOGD("OBU_TILE_GROUP\n"); break;}
videodec/amports/formatters/AmCodecVDAAV1.cpp:207:            case OBU_METADATA:{ALOGD("OBU_METADATA\n"); break;}
videodec/amports/formatters/AmCodecVDAAV1.cpp:208:            case OBU_FRAME:{ALOGD("OBU_FRAME\n"); break;}
videodec/amports/formatters/AmCodecVDAAV1.cpp:209:            case OBU_REDUNDANT_FRAME_HEADER:{ALOGD("OBU_REDUNDANT_FRAME_HEADER\n"); break;}
videodec/amports/formatters/AmCodecVDAAV1.cpp:210:            case OBU_TILE_LIST:{ALOGD("OBU_TILE_LIST\n"); break;}
videodec/amports/formatters/AmCodecVDAAV1.cpp:211:            case OBU_PADDING:{ALOGD("OBU_PADDING\n"); break;}
videodec/amports/formatters/AmCodecVDAAV1.cpp:212:            default: {ALOGD("OBU_TYPE_ERROR!!\n"); break;}
videodec/amports/formatters/AmCodecVDAAV1.cpp:247:            ALOGE("aml_es_bytes_left<aml_obu_size_org (%ld vs %ld)", aml_es_bytes_left, aml_obu_size_org);
videodec/amports/formatters/AmCodecVDAH265.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAAVS.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAMpeg2ts.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAAVS2.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAAVS3.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAAVS3.cpp:12://#define LOG_NDEBUG 0
videodec/amports/formatters/AmCodecVDAAVS3.cpp:13:#define LOG_TAG "AmCodecVDA"
videodec/amports/formatters/AmCodecVDAAVS3.cpp:16:#include <utils/Log.h>
videodec/amports/formatters/AmCodecVDAAVS3.cpp:23:    ALOGI("AmCodecVDAAVS3");
videodec/amports/formatters/AmCodecVDAAVS3.cpp:28:    ALOGI("~AmCodecVDAAVS3");
videodec/amports/formatters/AmCodecVDAAVS3.cpp:32:    ALOGI("AmCodecVDAAVS3::codecInit");
videodec/amports/formatters/AmCodecVDAAVS3.cpp:43:    ALOGI("AmCodecVDAAVS3::doCodecSpec");
videodec/amports/formatters/AmCodecVDAH266.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAAVS.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/formatters/AmCodecVDAAVS.cpp:12:#define LOG_NDEBUG 0
videodec/amports/formatters/AmCodecVDAAVS.cpp:13:#define LOG_TAG "AmCodecVDA"
videodec/amports/formatters/AmCodecVDAAVS.cpp:15:#include <utils/Log.h>
videodec/amports/formatters/AmCodecVDAAVS.cpp:20:    ALOGI("AmCodecVDAAVS");
videodec/amports/formatters/AmCodecVDAAVS.cpp:25:    ALOGI("~AmCodecVDAAVS");
videodec/amports/formatters/AmCodecVDAAVS.cpp:29:    ALOGI("AmCodecVDAAVS::codecInit");
videodec/amports/formatters/AmCodecVDAAVS.cpp:44:    ALOGI("AmCodecVDAAVS::doCodecSpec");
videodec/amports/AmCodecVDA.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/amports/AmCodecVDA.cpp:12://#define LOG_NDEBUG 0
videodec/amports/AmCodecVDA.cpp:13:#define LOG_TAG "AmCodecVDA"
videodec/amports/AmCodecVDA.cpp:18:// #include <utils/Log.h>
videodec/amports/AmCodecVDA.cpp:19:#include <TspLogger.h>
videodec/amports/AmCodecVDA.cpp:29:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/amports/AmCodecVDA.cpp:30:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/amports/AmCodecVDA.cpp:31:#define FLOGW(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/amports/AmCodecVDA.cpp:32:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/amports/AmCodecVDA.cpp:151:    FLOGI(mPlayerInstansNo,"debuglevel:%d  mMargin:%d mMarginInterlace:%d\n",debuglevel,mMargin,mMarginInterlace);
videodec/amports/AmCodecVDA.cpp:159:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:232:    FLOGI(mPlayerInstansNo,"out");
videodec/amports/AmCodecVDA.cpp:257:        FLOGI(mPlayerInstansNo,"DisPlay mode is OSD\n");
videodec/amports/AmCodecVDA.cpp:262:            FLOGI(mPlayerInstansNo,"MediaSync DisPlay mode is AMVIDEO\n");
videodec/amports/AmCodecVDA.cpp:267:            FLOGI(mPlayerInstansNo,"DisPlay mode is V4LVIDEO\n");
videodec/amports/AmCodecVDA.cpp:275:        FLOGI(mPlayerInstansNo,"DisPlay mode is AMVIDEO\n");
videodec/amports/AmCodecVDA.cpp:322:    FLOGI(mPlayerInstansNo,"decoder type %d, display mode %d, video path %d\n",
videodec/amports/AmCodecVDA.cpp:345:    FLOGI(mPlayerInstansNo,"bitstreamId %d, timestamp %" PRId64 "\n", bitstreamId, timestamp);
videodec/amports/AmCodecVDA.cpp:348:    FLOGI(mPlayerInstansNo,"wait input queue ok \n");
videodec/amports/AmCodecVDA.cpp:358:    // FLOGI(mPlayerInstansNo, "decode INPUT %d, size %" PRId32 ", queue size %d, input size %" PRId64 ", timestamp %" PRId64 ", bitstreamId %d\n",
videodec/amports/AmCodecVDA.cpp:397:        FLOGI(mPlayerInstansNo,"First BufStart:0x%x Bufend:0x%x DataStart:0x%x DataEnd:0x%x\n",
videodec/amports/AmCodecVDA.cpp:416:    // FLOGI(mPlayerInstansNo, "decode INPUT %d, size %" PRId32 ", queue size %d, input size %" PRId64 ", timestamp %" PRId64 ", bitstreamId %d\n",
videodec/amports/AmCodecVDA.cpp:425:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:427:        ALOGE("failed to start dequeue thread!!");
videodec/amports/AmCodecVDA.cpp:437:        FLOGI(mPlayerInstansNo,"setVdaState RUNNING");
videodec/amports/AmCodecVDA.cpp:441:    FLOGI(mPlayerInstansNo,"end");
videodec/amports/AmCodecVDA.cpp:450:    //ALOGD("getFreedHandle ret:0x%x handle:0x%x\n", -ret, handle);
videodec/amports/AmCodecVDA.cpp:460:        FLOGE(mPlayerInstansNo,"mCodec->getVdecState error: %x\n", -ret);
videodec/amports/AmCodecVDA.cpp:463:            FLOGE(mPlayerInstansNo,"decoder error vdec.status: %x\n", vdec.status);
videodec/amports/AmCodecVDA.cpp:466:                FLOGE(mPlayerInstansNo,"not enough codec memory for this file.\n");
videodec/amports/AmCodecVDA.cpp:470:                FLOGE(mPlayerInstansNo,"decorder error.\n");
videodec/amports/AmCodecVDA.cpp:474:                FLOGE(mPlayerInstansNo,"checkDecodeWorkStatus EVENT_TYPE_VIDEO_INVALID_DATA\n");
videodec/amports/AmCodecVDA.cpp:483:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:485:        FLOGI(mPlayerInstansNo,"mDecodeLoopStop true");
videodec/amports/AmCodecVDA.cpp:487:        FLOGI(mPlayerInstansNo,"mDecodeThread.Stop");
videodec/amports/AmCodecVDA.cpp:490:    FLOGI(mPlayerInstansNo,"end");
videodec/amports/AmCodecVDA.cpp:497:        FLOGI(mPlayerInstansNo,"inputQueueSize:%zu", mInputQueue.size());
videodec/amports/AmCodecVDA.cpp:502:    FLOGI(mPlayerInstansNo,"wait input queue");
videodec/amports/AmCodecVDA.cpp:507:        FLOGI(mPlayerInstansNo,"get entry bitstreamId %d\n", entry->bitstreamId);
videodec/amports/AmCodecVDA.cpp:515:    FLOGI(mPlayerInstansNo,"wait input queue");
videodec/amports/AmCodecVDA.cpp:536:    FLOGI(mPlayerInstansNo,"decodeThreadLoop in");
videodec/amports/AmCodecVDA.cpp:625:                            FLOGI(mPlayerInstansNo,"==== codec write EAGAIN ====\n");
videodec/amports/AmCodecVDA.cpp:632:                                    FLOGE(mPlayerInstansNo,"codec_write fail %d (count: %d)\n",
videodec/amports/AmCodecVDA.cpp:636:                                FLOGE(mPlayerInstansNo,"codec_write fail %d (count: %d)\n",
videodec/amports/AmCodecVDA.cpp:650:                                FLOGI(mPlayerInstansNo,"providePictureBuffers, width %d, height %d\n",
videodec/amports/AmCodecVDA.cpp:667:                    FLOGE(mPlayerInstansNo,"save csd\n");
videodec/amports/AmCodecVDA.cpp:670:                    FLOGE(mPlayerInstansNo,"prepareEsData error %d\n", wsize);
videodec/amports/AmCodecVDA.cpp:690:                    FLOGI(mPlayerInstansNo,"providePictureBuffers, width %d, height %d, recieve id:%d\n",
videodec/amports/AmCodecVDA.cpp:698:                        FLOGE(mPlayerInstansNo,"checkinPtsUS  %" PRId64 " error \n", timestamp * 100/9);
videodec/amports/AmCodecVDA.cpp:701:                    // ALOGI(" CheckinPtsSize:%d pts_32:%lld pts_64:%lld receive id:%d\n",
videodec/amports/AmCodecVDA.cpp:743:            //ALOGI("queue empty mDecodeLoopStop.load() %d\n", mDecodeLoopStop.load());
videodec/amports/AmCodecVDA.cpp:755:                FLOGI(mPlayerInstansNo,"providePictureBuffers, width %d, height %d mDecodeThreadDebugNum %d\n",
videodec/amports/AmCodecVDA.cpp:769:                        FLOGI(mPlayerInstansNo,"Queue has no video es data. checkCount:%d\n",checkEmptyCount);
videodec/amports/AmCodecVDA.cpp:788:    FLOGI(mPlayerInstansNo,"exit mInputQueue size %d\n",(int)mInputQueue.size());
videodec/amports/AmCodecVDA.cpp:792:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:795:        FLOGE(mPlayerInstansNo,"failed to start dequeue thread!!");
videodec/amports/AmCodecVDA.cpp:809:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:811:        FLOGI(mPlayerInstansNo,"mDisplayLoopStop true");
videodec/amports/AmCodecVDA.cpp:820:        //ALOGI("getFirstFrameToggled\n");
videodec/amports/AmCodecVDA.cpp:825:                FLOGI(mPlayerInstansNo,"mDisplayMode:AMVIDEO FIRST FRAME TOGGLED\n");
videodec/amports/AmCodecVDA.cpp:831:            FLOGI(mPlayerInstansNo,"mDisplayMode:!=V4LVIDEO :FIRST FRAME TOGGLED\n");
videodec/amports/AmCodecVDA.cpp:837:            //FLOGI(mPlayerInstansNo,"FIRST FRAME TOGGLED\n");
videodec/amports/AmCodecVDA.cpp:865:                FLOGI(mPlayerInstansNo," mCodec == NULL");
videodec/amports/AmCodecVDA.cpp:905:                            FLOGI(mPlayerInstansNo, "too fast, wait_time=%u\n", mGetVFrameWaitTimeUs);
videodec/amports/AmCodecVDA.cpp:919:                        FLOGI(mPlayerInstansNo, "too slow, wait_time=%u\n", mGetVFrameWaitTimeUs);
videodec/amports/AmCodecVDA.cpp:936:                        FLOGI(mPlayerInstansNo," vframe_counter->error_count = %d",vframe_counter->error_count);
videodec/amports/AmCodecVDA.cpp:948:            ALOGI("%s, mCodec == NULL", __func__);
videodec/amports/AmCodecVDA.cpp:951:            ALOGI("firstApts:%lld\n",firstApts);
videodec/amports/AmCodecVDA.cpp:973:            FLOGI(mPlayerInstansNo,"vpts(%" PRId64 ")-apts(%" PRId64 ")=diff:%" PRId64 "\n",vpts,apts,diff);
videodec/amports/AmCodecVDA.cpp:998:        FLOGI(mPlayerInstansNo, "dves detect");
videodec/amports/AmCodecVDA.cpp:1022:            FLOGI(mPlayerInstansNo,"vdec.status : 0x%x UNSUPPORT\n",vdec.status);
videodec/amports/AmCodecVDA.cpp:1033:        FLOGI(mPlayerInstansNo,"vdec.status : 0x%x DECODER_FATAL_ERROR_TOO_MANY_TIMEOUT\n",vdec.status);
videodec/amports/AmCodecVDA.cpp:1059:        FLOGI(mPlayerInstansNo,"notifyEvent, EVENT_TYPE_VIDEO_CHANGED [%d x %d] @ %d, asp %d vpid:%d, sar [%d x %d], dar [%d x %d]\n",
videodec/amports/AmCodecVDA.cpp:1069:        FLOGI(mPlayerInstansNo, "dves video update");
videodec/amports/AmCodecVDA.cpp:1114:                FLOGI(mPlayerInstansNo,"getAvParamInfo error: %x\n", -ret);
videodec/amports/AmCodecVDA.cpp:1117:            //FLOGI(mPlayerInstansNo,"vpts_err=%u apts_err=%u\n",mAvInfo.av_info.vpts_err,mAvInfo.av_info.apts_err);
videodec/amports/AmCodecVDA.cpp:1120:                FLOGI(mPlayerInstansNo,"notifyEvent EVENT_TYPE_VIDEO_INVALID_TIMESTAMP mLastVptsErr=%u\n",mLastVptsErr);
videodec/amports/AmCodecVDA.cpp:1125:                FLOGI(mPlayerInstansNo,"notifyEvent EVENT_TYPE_AUDIO_INVALID_TIMESTAMP mLastAptsErr=%u\n",mLastAptsErr);
videodec/amports/AmCodecVDA.cpp:1139:                FLOGI(mPlayerInstansNo,"notifyEvent EVENT_TYPE_VIDEO_INVALID_TIMESTAMP\n");
videodec/amports/AmCodecVDA.cpp:1143:                FLOGI(mPlayerInstansNo,"notifyEvent EVENT_TYPE_AUDIO_INVALID_TIMESTAMP\n");
videodec/amports/AmCodecVDA.cpp:1164:            FLOGI(mPlayerInstansNo,"checkInvalidData getVbufState error: %x\n", -ret);
videodec/amports/AmCodecVDA.cpp:1178:        //FLOGI(mPlayerInstansNo,"checkInvalidData f_cnt%u err_f_cnt%u last_err%u\n", mAvInfo.frame_count, mAvInfo.error_frame_count, last_vframes_err);
videodec/amports/AmCodecVDA.cpp:1181:            FLOGI(mPlayerInstansNo,"notifyEvent EVENT_TYPE_VIDEO_INVALID_DATA-1\n");
videodec/amports/AmCodecVDA.cpp:1185:            FLOGI(mPlayerInstansNo,"notifyEvent EVENT_TYPE_VIDEO_INVALID_DATA-2 err_f_cnt%u last_err%u\n", mAvInfo.error_frame_count, last_vframes_err);
videodec/amports/AmCodecVDA.cpp:1192:            FLOGI(mPlayerInstansNo,"notifyEvent EVENT_TYPE_AUDIO_INVALID_DATA-1\n");
videodec/amports/AmCodecVDA.cpp:1211:            FLOGI(mPlayerInstansNo,"getVbufState error: %x\n", -ret);
videodec/amports/AmCodecVDA.cpp:1226:        FLOGI(mPlayerInstansNo,"checkUnderOverFlow vlevel=%f vlen=%d vsize=%d mFormat=%d vp_move=%d vp_cnt=%d\n",
videodec/amports/AmCodecVDA.cpp:1232:            FLOGI(mPlayerInstansNo,"notifyEvent EVENT_TYPE_VIDEO_OVERFLOW video_overflow_num=%u\n",mAvFlow.video_overflow_num);
videodec/amports/AmCodecVDA.cpp:1240:                FLOGI(mPlayerInstansNo,"notifyEvent VFORMAT_MJPEG EVENT_TYPE_VIDEO_UNDERFLOW video_underflow_num=%u\n",mAvFlow.video_underflow_num);
videodec/amports/AmCodecVDA.cpp:1246:                FLOGI(mPlayerInstansNo,"notifyEvent EVENT_TYPE_VIDEO_UNDERFLOW video_underflow_num=%u\n",mAvFlow.video_underflow_num);
videodec/amports/AmCodecVDA.cpp:1256:            FLOGI(mPlayerInstansNo,"getAbufState error: %x\n", -ret);
videodec/amports/AmCodecVDA.cpp:1275:        FLOGI(mPlayerInstansNo,"checkUnderOverFlow alevel=%f alen=%d asize=%d ap_move=%d ap_cnt=%d\n",
videodec/amports/AmCodecVDA.cpp:1279:            FLOGI(mPlayerInstansNo,"notifyEvent EVENT_TYPE_AUDIO_OVERFLOW audio_overflow_num=%u\n",mAvFlow.audio_overflow_num);
videodec/amports/AmCodecVDA.cpp:1286:            FLOGI(mPlayerInstansNo,"notifyEvent EVENT_TYPE_AUDIO_UNDERFLOW audio_underflow_num=%u\n",mAvFlow.audio_underflow_num);
videodec/amports/AmCodecVDA.cpp:1292:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:1335:                    //ALOGI("[%d] vpts %lld\n", mOutputCount, vpts);
videodec/amports/AmCodecVDA.cpp:1375:                        FLOGI(mPlayerInstansNo,"Can't get buf from v4lvideo,need retry.videoid:%d dqbufWaitCount:%d InDebug:%d DecodeDebug:%d, isInput:%d\n",
videodec/amports/AmCodecVDA.cpp:1382:                            FLOGI(mPlayerInstansNo,"size:%d %s",(int)mOutputBuffersId.size(),bufferInfo);
videodec/amports/AmCodecVDA.cpp:1427:    FLOGI(mPlayerInstansNo,"terminates");
videodec/amports/AmCodecVDA.cpp:1431:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:1438:        FLOGE(mPlayerInstansNo,"failed to start userdata thread!!");
videodec/amports/AmCodecVDA.cpp:1444:    FLOGI(mPlayerInstansNo,"end");
videodec/amports/AmCodecVDA.cpp:1449:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:1451:        FLOGI(mPlayerInstansNo,"mUserdataLoopStop true");
videodec/amports/AmCodecVDA.cpp:1458:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:1482:                FLOGI(mPlayerInstansNo,"userdataReady each.size() %d, notify.size() %d\n",
videodec/amports/AmCodecVDA.cpp:1489:    FLOGI(mPlayerInstansNo,"terminates");
videodec/amports/AmCodecVDA.cpp:1499:    FLOGI(mPlayerInstansNo,"Total size: %d, driver size: %d\n",
videodec/amports/AmCodecVDA.cpp:1508:        FLOGV(mPlayerInstansNo,"send atrace picture ready, index %d, mOutputCount %d, fd %d, mWriteSize %" PRId64 ", resolution %d x %d, pts %" PRId64 "\n",
videodec/amports/AmCodecVDA.cpp:1523:                FLOGI(mPlayerInstansNo,"can not find matching bitstreamId with pts %" PRId64 "\n", vf->pts);
videodec/amports/AmCodecVDA.cpp:1546:                //ALOGE("%s:%d,dec_id:%d,vf->index:%d,vf->fd:%d,vff.fd:%d\n",__FUNCTION__,__LINE__,dec_id,vf->index,vf->fd,vff.fd);
videodec/amports/AmCodecVDA.cpp:1551:                    FLOGW(mPlayerInstansNo,"sendOutputBuffer id:%d vf->index:%d \n",id,vf->index);
videodec/amports/AmCodecVDA.cpp:1554:                    FLOGW(mPlayerInstansNo,"sendOutputBuffer vf->fd :%d vff.fd:%d \n",vf->fd,vff.fd);
videodec/amports/AmCodecVDA.cpp:1570:                    ALOGV("set video info pts %" PRId64 ", outcount %d\n", vf->pts, mOutputCount);
videodec/amports/AmCodecVDA.cpp:1587:            FLOGE(mPlayerInstansNo,"sendOutputBuffer mVideoWorkMode is Video_Work_MODE_CACHING_ONLY and return\n");
videodec/amports/AmCodecVDA.cpp:1603:                    FLOGI(mPlayerInstansNo,"id == -1 *it:%d  vf->index:%d\n",*it,vf->index);
videodec/amports/AmCodecVDA.cpp:1613:                FLOGE(mPlayerInstansNo,"sendOutputBuffer id:%d vf->index:%d \n",id,vf->index);
videodec/amports/AmCodecVDA.cpp:1617:                FLOGE(mPlayerInstansNo,"sendOutputBuffer vf->fd :%d vff.fd:%d \n",vf->fd,vff.fd);
videodec/amports/AmCodecVDA.cpp:1626:                FLOGI(mPlayerInstansNo,"pictureReady slot %d, fd %d timeus:%" PRId64 "\n",
videodec/amports/AmCodecVDA.cpp:1632:            FLOGI(mPlayerInstansNo," vf === NULL");
videodec/amports/AmCodecVDA.cpp:1662:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:1665:            ALOGE("failed to start flush thread!!");
videodec/amports/AmCodecVDA.cpp:1689:        FLOGI(mPlayerInstansNo,"mInputQueue.size() %d\n", inputQueueSize);
videodec/amports/AmCodecVDA.cpp:1693:    FLOGI(mPlayerInstansNo,"print before first eos mInputQueue.size() %d, mInputCount %d,"
videodec/amports/AmCodecVDA.cpp:1721:        FLOGI(mPlayerInstansNo,"mOutputBuffersId: %d mDispReadyCount %d,"
videodec/amports/AmCodecVDA.cpp:1732:        ALOGI("flush return buffer %d", id);
videodec/amports/AmCodecVDA.cpp:1750:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:1756:    FLOGI(mPlayerInstansNo,"mInputQueue.size() %d, mInputCount %d, mDispReadyCount %d,"
videodec/amports/AmCodecVDA.cpp:1790:        FLOGI(mPlayerInstansNo,"When in stopvideo case: only stop not reset vcodec");
videodec/amports/AmCodecVDA.cpp:1808:    FLOGI(mPlayerInstansNo,"terminates");
videodec/amports/AmCodecVDA.cpp:1812:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:1815:            FLOGE(mPlayerInstansNo,"failed to start reset thread!!");
videodec/amports/AmCodecVDA.cpp:1819:    FLOGI(mPlayerInstansNo,"wait input queue");
videodec/amports/AmCodecVDA.cpp:1846:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:1860:   FLOGI(mPlayerInstansNo,"terminates");
videodec/amports/AmCodecVDA.cpp:1899:    FLOGI(mPlayerInstansNo,"mConfig.drmMode %d, isAmDolbyVideo:%d\n", mConfig.drmMode, isAmDolbyVideo);
videodec/amports/AmCodecVDA.cpp:1954:    FLOGI(mPlayerInstansNo,"subtitleFlg : %d \n",mConfig.subtitleFlg);
videodec/amports/AmCodecVDA.cpp:1963:    FLOGI(mPlayerInstansNo,"mNumOutputBuffers %d, mDecoderType %d, mVideoPath %d, mDisplayMode %d\n",
videodec/amports/AmCodecVDA.cpp:1970:    FLOGI(mPlayerInstansNo,"assign output buffer num %d\n", numOutputBuffers);
videodec/amports/AmCodecVDA.cpp:1987:        FLOGI(mPlayerInstansNo,"add mDecOutputBuffersId.size() %d,vf.fd:%d,index:%d\n",(int)mOutputBuffersId.size(),vf.fd,index);
videodec/amports/AmCodecVDA.cpp:2051:        FLOGI(mPlayerInstansNo,"add mDecOutputBuffersId.size() %d,pictureBufferId:%d,pictureBufferId:%d\n",
videodec/amports/AmCodecVDA.cpp:2075:    //ALOGI("importBufferForPicture add mOutputBuffersId.size() %d,vf.fd:%d,pictureBufferId:%d\n", mOutputBuffersId.size(),vf.fd,pictureBufferId);
videodec/amports/AmCodecVDA.cpp:2089:            FLOGI(mPlayerInstansNo,"can not find mDisp_Dec_Map in line %d,pictureBufferId %d\n",__LINE__, pictureBufferId);
videodec/amports/AmCodecVDA.cpp:2096:            FLOGI(mPlayerInstansNo,"can not find mOutputBuffers in line %d,pictureBufferId %d\n",__LINE__, pictureBufferId);
videodec/amports/AmCodecVDA.cpp:2118:        //ALOGI("%s:%d,it is VideoLINK mode\n",__FUNCTION__,__LINE__);
videodec/amports/AmCodecVDA.cpp:2122:            FLOGI(mPlayerInstansNo,"can not find mOutputBuffers in line %d,pictureBufferId %d\n",__LINE__, pictureBufferId);
videodec/amports/AmCodecVDA.cpp:2134:            FLOGI(mPlayerInstansNo,"slot:%d fd:%d OutputBufferSize:%d,pictureBufferId:%d\n",
videodec/amports/AmCodecVDA.cpp:2144:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:2146:        ALOGI("flushed, ignore\n");
videodec/amports/AmCodecVDA.cpp:2150:    FLOGI(mPlayerInstansNo," ok");
videodec/amports/AmCodecVDA.cpp:2154:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:2156:    FLOGI(mPlayerInstansNo,"ok");
videodec/amports/AmCodecVDA.cpp:2160:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:2188:    FLOGI(mPlayerInstansNo,"end");
videodec/amports/AmCodecVDA.cpp:2204:        FLOGE(mPlayerInstansNo,"something wrong with the stream's pts pts_dmx2 %" PRId64 ", pts_dmx %" PRId64 "\n",
videodec/amports/AmCodecVDA.cpp:2209:    //ALOGI("pts_dmx2 %lld, pts_dmx %lld pts_dmx_bit32 %lld pts_tsync %lld\n",
videodec/amports/AmCodecVDA.cpp:2223:        FLOGE(mPlayerInstansNo,"getVbufState error: %x\n", -ret);
videodec/amports/AmCodecVDA.cpp:2235:            FLOGI(mPlayerInstansNo,"getVbufState error: %x\n", -ret);
videodec/amports/AmCodecVDA.cpp:2262:    FLOGV(mPlayerInstansNo,"sendCommand %d\n", index);
videodec/amports/AmCodecVDA.cpp:2267:            FLOGI(mPlayerInstansNo,"VDA_SET_VIDEO_MATCHMODE %d\n", *static_cast<uint32_t*>(param));
videodec/amports/AmCodecVDA.cpp:2274:            FLOGI(mPlayerInstansNo,"VDA_SET_SYNC_MODE %d\n", *static_cast<uint32_t*>(param));
videodec/amports/AmCodecVDA.cpp:2281:            FLOGI(mPlayerInstansNo,"VDA_SET_FAST %f\n", *static_cast<float*>(param));
videodec/amports/AmCodecVDA.cpp:2297:            FLOGI(mPlayerInstansNo,"VDA_SET_TRICKMODE %d\n", *static_cast<uint32_t*>(param));
videodec/amports/AmCodecVDA.cpp:2311:            FLOGI(mPlayerInstansNo,"VDA_SET_VIDEO_SHOW %d\n", *static_cast<bool*>(param));
videodec/amports/AmCodecVDA.cpp:2319:            FLOGI(mPlayerInstansNo,"VDA_SET_VIDEO_BLACKOUT %d\n", *static_cast<bool*>(param));
videodec/amports/AmCodecVDA.cpp:2327:            FLOGI(mPlayerInstansNo,"VDA_SET_VIDEO_START_DECODING\n");
videodec/amports/AmCodecVDA.cpp:2334:                FLOGI(mPlayerInstansNo, "start==reset vpid:%d and apid:%d", mConfig.vpid, mConfig.apid);
videodec/amports/AmCodecVDA.cpp:2337:                FLOGI(mPlayerInstansNo, "VDA_SET_VIDEO_START_DECODING");
videodec/amports/AmCodecVDA.cpp:2344:            FLOGI(mPlayerInstansNo,"VDA_SET_VIDEO_PAUSE_DECODING\n");
videodec/amports/AmCodecVDA.cpp:2353:            FLOGI(mPlayerInstansNo,"VDA_SET_VIDEO_RESUME_DECODING\n");
videodec/amports/AmCodecVDA.cpp:2367:                FLOGI(mPlayerInstansNo, "stop=reset vpid:%d, apid:%d", mConfig.vpid, mConfig.apid);
videodec/amports/AmCodecVDA.cpp:2370:                FLOGI(mPlayerInstansNo,"VDA_SET_VIDEO_STOP_DECODING\n");
videodec/amports/AmCodecVDA.cpp:2379:            FLOGI(mPlayerInstansNo,"VDA_SET_PCRID %d\n", *static_cast<uint32_t*>(param));
videodec/amports/AmCodecVDA.cpp:2386:            FLOGI(mPlayerInstansNo,"VDA_SET_AUDIO_ID %d\n", *static_cast<uint32_t*>(param));
videodec/amports/AmCodecVDA.cpp:2394:            FLOGI(mPlayerInstansNo,"VDA_SET_SUBTITLE_ID %d\n", *static_cast<uint32_t*>(param));
videodec/amports/AmCodecVDA.cpp:2400:            FLOGI(mPlayerInstansNo,"VDA_SET_SUBTITLE_START\n");
videodec/amports/AmCodecVDA.cpp:2406:            FLOGI(mPlayerInstansNo,"VDA_SET_WINDOWS_AXIS\n");
videodec/amports/AmCodecVDA.cpp:2414:            FLOGI(mPlayerInstansNo,"VDA_SET_VIDEO_CROP\n");
videodec/amports/AmCodecVDA.cpp:2428:            FLOGI(mPlayerInstansNo,"VDA_SET_VIDEO_ID %d\n", *static_cast<uint32_t*>(param));
videodec/amports/AmCodecVDA.cpp:2436:            FLOGI(mPlayerInstansNo,"VDA_SET_VIDEO_FORMAT %d\n", *static_cast<uint32_t*>(param));
videodec/amports/AmCodecVDA.cpp:2444:            FLOGI(mPlayerInstansNo,"VDA_SET_WORK_MODE %d\n", *static_cast<uint32_t*>(param));
videodec/amports/AmCodecVDA.cpp:2501:            FLOGI(mPlayerInstansNo,"VDA_SET_WORK_MODE %d\n", *static_cast<uint32_t*>(param));
videodec/amports/AmCodecVDA.cpp:2517:                FLOGE(mPlayerInstansNo,"VDA_SET_INSTANS_NUM param == NULL");
videodec/amports/AmCodecVDA.cpp:2519:            FLOGI(mPlayerInstansNo,"VDA_SET_INSTANS_NUM %d\n", mPlayerInstansNo);
videodec/amports/AmCodecVDA.cpp:2541:            FLOGI(mPlayerInstansNo,"VDA_SET_VIDEO_START_COMPLETE %d\n",mIsVideoComplete);
videodec/amports/AmCodecVDA.cpp:2555:            FLOGI(mPlayerInstansNo,"VDA_GET_CURRENT_TIME ret:%d,vpts:%" PRId64 ",ctime:%" PRId64 "\n",ret,vpts,ctime);
videodec/amports/AmCodecVDA.cpp:2575:           // ALOGI("start toggle %d delaytime %lld\n", mStartToggle.load(), dtime);
videodec/amports/AmCodecVDA.cpp:2589:            //ALOGI("VDA_GET_VIDEO_INFO\n");
videodec/amports/AmCodecVDA.cpp:2607:                    //ALOGI("VDA_GET_VIDEO_STAT success");
videodec/amports/AmCodecVDA.cpp:2609:                    //ALOGI("VDA_GET_VIDEO_STAT use previous cached info slots:%d",slots);
videodec/amports/AmCodecVDA.cpp:2766:            FLOGI(mPlayerInstansNo,"VDA_SET_VCODEC_INIT_IN_RESET mVcodecInitInReset=%d", mVcodecInitInReset);
videodec/amports/AmCodecVDA.cpp:2773:            FLOGI(mPlayerInstansNo,"VDA_SET_VFRAME_COUNTER_ENABLED mVFrameCounterEnabled=%d",
videodec/amports/AmCodecVDA.cpp:2782:                //FLOGI(mPlayerInstansNo,"mVFrameCounterQue empty");
videodec/amports/AmCodecVDA.cpp:2794:            FLOGI(mPlayerInstansNo,"VDA_SET_VIDEO_EXTRADATA, size:%d", size);
videodec/amports/AmCodecVDA.cpp:2816:            FLOGI(mPlayerInstansNo,"VDA_SET_STREAM_EOF");
videodec/amports/AmCodecVDA.cpp:2824:            FLOGI(mPlayerInstansNo,"VDA_SET_FAST_VIDEO_STATE mFastVideoStateValue=%d",
videodec/amports/AmCodecVDA.cpp:2829:            ALOGW("unknown command:%d", idx);
videodec/amports/AmCodecVDA.cpp:2843:        FLOGI(mPlayerInstansNo,"ignore provide picture event at state %d\n", state);
videodec/amports/AmCodecVDA.cpp:2857:    //    FLOGI(mPlayerInstansNo,"ignore output done event at state %d\n", state);
videodec/amports/AmCodecVDA.cpp:2866:        FLOGI(mPlayerInstansNo,"ignore userdata done event at state %d\n", state);
videodec/amports/AmCodecVDA.cpp:2876:        FLOGI(mPlayerInstansNo,"ignore input done event at state %d\n", state);
videodec/amports/AmCodecVDA.cpp:2881:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:2884:    FLOGI(mPlayerInstansNo,"end");
videodec/amports/AmCodecVDA.cpp:2888:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:2891:    FLOGI(mPlayerInstansNo,"end");
videodec/amports/AmCodecVDA.cpp:2895:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:2897:        FLOGI(mPlayerInstansNo,"mAdaptor=NULL");
videodec/amports/AmCodecVDA.cpp:2901:    FLOGI(mPlayerInstansNo,"end");
videodec/amports/AmCodecVDA.cpp:2905:    FLOGI(mPlayerInstansNo,"in");
videodec/amports/AmCodecVDA.cpp:2907:        FLOGI(mPlayerInstansNo,"mAdaptor=NULL");
videodec/amports/AmCodecVDA.cpp:2911:    FLOGI(mPlayerInstansNo,"end");
videodec/libchromes/base/bind_internal.h:593:// There are 2 logical InvokeHelper<> specializations: normal, WeakCalls.
videodec/libchromes/base/unguessable_token.h:15:#include "base/logging.h"
videodec/libchromes/base/lazy_instance.h:53:#include "base/logging.h"
videodec/libchromes/base/sequence_checker_impl.cc:7:#include "base/logging.h"
videodec/libchromes/base/containers/small_map.h:16:#include "base/logging.h"
videodec/libchromes/base/containers/README.md:43:    gives O(n log n) construction times and it should be strictly better than
videodec/libchromes/base/containers/flat_map.h:13:#include "base/logging.h"
videodec/libchromes/base/containers/vector_buffer.h:14:#include "base/logging.h"
videodec/libchromes/base/containers/flat_tree.h:124:  // Constructors that take range guarantee O(N * log^2(N)) + O(N) complexity
videodec/libchromes/base/containers/flat_tree.h:125:  // and take O(N * log(N)) + O(N) if extra memory is available (N is a range
videodec/libchromes/base/containers/flat_tree.h:244:  // erase(key) may take O(size) + O(log(size)).
videodec/libchromes/base/containers/flat_tree.h:264:  // Search operations have O(log(size)) complexity.
videodec/libchromes/base/containers/span.h:16:#include "base/logging.h"
videodec/libchromes/base/containers/span.h:91:// span is somewhat analogous to StringPiece, but with arbitrary element types,
videodec/libchromes/base/containers/mru_cache.h:28:#include "base/logging.h"
videodec/libchromes/base/containers/ring_buffer.h:10:#include "base/logging.h"
videodec/libchromes/base/containers/circular_deque.h:15:#include "base/logging.h"
videodec/libchromes/base/containers/circular_deque.h:809:    // In an erase operation, the shifted items all move logically to the left,
videodec/libchromes/base/containers/circular_deque.h:1031:    // Move the elements. This will always involve shifting logically to the
videodec/libchromes/base/stl_util.h:24:#include "base/logging.h"
videodec/libchromes/base/stl_util.h:372:// sorted. Note that the logic below appears inverted since it is returning
videodec/libchromes/base/base_paths_posix.cc:21:#include "base/logging.h"
videodec/libchromes/base/base_paths_posix.cc:94:        DLOG(WARNING) << "CR_SOURCE_ROOT is set, but it appears to not "
videodec/libchromes/base/base_paths_posix.cc:104:      DLOG(ERROR) << "Couldn't find your source root.  "
videodec/libchromes/base/sys_info.h:30:  // Return the number of logical processors/cores on the current machine.
videodec/libchromes/base/json/json_parser.cc:11:#include "base/logging.h"
videodec/libchromes/base/json/json_value_converter.h:15:#include "base/logging.h"
videodec/libchromes/base/json/json_value_converter.h:273:        DVLOG(1) << "failure at " << i << "-th element";
videodec/libchromes/base/json/json_value_converter.h:307:        DVLOG(1) << "failure at " << i << "-th element";
videodec/libchromes/base/json/json_value_converter.h:344:        DVLOG(1) << "failure at " << i << "-th element";
videodec/libchromes/base/json/json_value_converter.h:507:          DVLOG(1) << "failure at field " << field_converter->field_path();
videodec/libchromes/base/json/json_string_value_serializer.cc:9:#include "base/logging.h"
videodec/libchromes/base/json/json_file_value_serializer.cc:9:#include "base/logging.h"
videodec/libchromes/base/json/json_parser.h:31:// to be used directly; it encapsulates logic that need not be exposed publicly.
videodec/libchromes/base/json/json_parser.h:90:  // This class centralizes that logic.
videodec/libchromes/base/json/json_reader.cc:11:#include "base/logging.h"
videodec/libchromes/base/json/json_writer.cc:13:#include "base/logging.h"
videodec/libchromes/base/json/json_writer.cc:198:      DLOG_IF(ERROR, !omit_binary_values_) << "Cannot serialize binary value.";
videodec/libchromes/base/json/json_correctness_fuzzer.cc:17:#include "base/logging.h"
videodec/libchromes/base/json/json_correctness_fuzzer.cc:46:  LOG_ASSERT(b);
videodec/libchromes/base/json/json_correctness_fuzzer.cc:51:  LOG_ASSERT(double_parsed_value);
videodec/libchromes/base/json/json_correctness_fuzzer.cc:55:  LOG_ASSERT(b2);
videodec/libchromes/base/json/json_correctness_fuzzer.cc:57:  LOG_ASSERT(parsed_output == double_parsed_output)
videodec/libchromes/base/android/scoped_hardware_buffer_handle.cc:8:#include "base/logging.h"
videodec/libchromes/base/android/scoped_hardware_buffer_handle.cc:70:    PLOG(ERROR) << "socketpair";
videodec/libchromes/base/android/scoped_hardware_buffer_handle.cc:81:    PLOG(ERROR) << "send";
videodec/libchromes/base/android/scoped_hardware_buffer_handle.cc:101:    PLOG(ERROR) << "recv";
videodec/libchromes/base/android/build_info.cc:12:#include "base/logging.h"
videodec/libchromes/base/android/jni_array.cc:9:#include "base/logging.h"
videodec/libchromes/base/android/orderfile/orderfile_instrumentation.cc:21:#include "base/logging.h"
videodec/libchromes/base/android/orderfile/orderfile_instrumentation.cc:64:// Data required to log reached offsets.
videodec/libchromes/base/android/orderfile/orderfile_instrumentation.cc:65:struct LogData {
videodec/libchromes/base/android/orderfile/orderfile_instrumentation.cc:71:LogData g_data[kPhases];
videodec/libchromes/base/android/orderfile/orderfile_instrumentation.cc:131:    // likely happening during a static initializer. Logging at this time is
videodec/libchromes/base/android/orderfile/orderfile_instrumentation.cc:167:    LOG(FATAL) << "Too many reached offsets";
videodec/libchromes/base/android/orderfile/orderfile_instrumentation.cc:173:                                       const LogData& data) {
videodec/libchromes/base/android/orderfile/orderfile_instrumentation.cc:177:    PLOG(ERROR) << "Could not open " << path;
videodec/libchromes/base/android/orderfile/orderfile_instrumentation.cc:182:    LOG(ERROR) << "No entries to dump";
videodec/libchromes/base/android/orderfile/orderfile_instrumentation.cc:202:      LOG(FATAL) << "Error writing profile data";
videodec/libchromes/base/android/orderfile/orderfile_instrumentation.cc:223:      LOG(ERROR) << "Problem with dump " << phase << " (" << tag << ")";
videodec/libchromes/base/android/orderfile/orderfile_instrumentation.cc:258:    PLOG(FATAL) << "clock_gettime.";
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:12: * Utility class for Logging.
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:15: * Defines logging access points for each feature. They format and forward the logs to
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:16: * {@link android.util.Log}, allowing to standardize the output, to make it easy to identify
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:17: * the origin of logs, and enable or disable logging in different parts of the code.
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:20: * Usage documentation: {@code //docs/android_logging.md}.
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:23:public class Log {
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:24:    /** Convenience property, same as {@link android.util.Log#ASSERT}. */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:25:    public static final int ASSERT = android.util.Log.ASSERT;
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:27:    /** Convenience property, same as {@link android.util.Log#DEBUG}. */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:28:    public static final int DEBUG = android.util.Log.DEBUG;
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:30:    /** Convenience property, same as {@link android.util.Log#ERROR}. */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:31:    public static final int ERROR = android.util.Log.ERROR;
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:33:    /** Convenience property, same as {@link android.util.Log#INFO}. */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:34:    public static final int INFO = android.util.Log.INFO;
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:36:    /** Convenience property, same as {@link android.util.Log#VERBOSE}. */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:37:    public static final int VERBOSE = android.util.Log.VERBOSE;
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:39:    /** Convenience property, same as {@link android.util.Log#WARN}. */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:40:    public static final int WARN = android.util.Log.WARN;
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:45:    private Log() {
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:49:    /** Returns a formatted log message, using the supplied format and arguments.*/
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:50:    private static String formatLog(String messageTemplate, Object... params) {
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:60:     * various Log overrides. If using {@link #isLoggable(String, int)}, you might want to call it
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:77:     * Returns a formatted log message, using the supplied format and arguments.
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:80:    private static String formatLogWithStack(String messageTemplate, Object... params) {
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:81:        return "[" + getCallOrigin() + "] " + formatLog(messageTemplate, params);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:85:     * Convenience function, forwards to {@link android.util.Log#isLoggable(String, int)}.
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:87:     * Note: Has no effect on whether logs are sent or not. Use a method with
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:88:     * {@link RemovableInRelease} to log something in Debug builds only.
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:90:    public static boolean isLoggable(String tag, int level) {
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:91:        return android.util.Log.isLoggable(tag, level);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:95:     * Sends a {@link android.util.Log#VERBOSE} log message.
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:98:     * than 7 parameters, consider building your log message using a function annotated with
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:101:     * @param tag Used to identify the source of a log message. Might be modified in the output
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:103:     * @param messageTemplate The message you would like logged. It is to be specified as a format
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:109:        String message = formatLogWithStack(messageTemplate, args);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:110:        Throwable tr = getThrowableToLog(args);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:112:            android.util.Log.v(normalizeTag(tag), message, tr);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:114:            android.util.Log.v(normalizeTag(tag), message);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:118:    /** Sends a {@link android.util.Log#VERBOSE} log message. 0 args version. */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:125:    /** Sends a {@link android.util.Log#VERBOSE} log message. 1 arg version. */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:132:    /** Sends a {@link android.util.Log#VERBOSE} log message. 2 args version */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:139:    /** Sends a {@link android.util.Log#VERBOSE} log message. 3 args version */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:147:    /** Sends a {@link android.util.Log#VERBOSE} log message. 4 args version */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:155:    /** Sends a {@link android.util.Log#VERBOSE} log message. 5 args version */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:163:    /** Sends a {@link android.util.Log#VERBOSE} log message. 6 args version */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:171:    /** Sends a {@link android.util.Log#VERBOSE} log message. 7 args version */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:180:     * Sends a {@link android.util.Log#DEBUG} log message.
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:183:     * than 7 parameters, consider building your log message using a function annotated with
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:186:     * @param tag Used to identify the source of a log message. Might be modified in the output
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:188:     * @param messageTemplate The message you would like logged. It is to be specified as a format
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:194:        String message = formatLogWithStack(messageTemplate, args);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:195:        Throwable tr = getThrowableToLog(args);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:197:            android.util.Log.d(normalizeTag(tag), message, tr);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:199:            android.util.Log.d(normalizeTag(tag), message);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:203:    /** Sends a {@link android.util.Log#DEBUG} log message. 0 args version. */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:210:    /** Sends a {@link android.util.Log#DEBUG} log message. 1 arg version. */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:216:    /** Sends a {@link android.util.Log#DEBUG} log message. 2 args version */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:222:    /** Sends a {@link android.util.Log#DEBUG} log message. 3 args version */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:230:    /** Sends a {@link android.util.Log#DEBUG} log message. 4 args version */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:238:    /** Sends a {@link android.util.Log#DEBUG} log message. 5 args version */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:246:    /** Sends a {@link android.util.Log#DEBUG} log message. 6 args version */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:254:    /** Sends a {@link android.util.Log#DEBUG} log message. 7 args version */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:263:     * Sends an {@link android.util.Log#INFO} log message.
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:265:     * @param tag Used to identify the source of a log message. Might be modified in the output
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:267:     * @param messageTemplate The message you would like logged. It is to be specified as a format
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:274:        String message = formatLog(messageTemplate, args);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:275:        Throwable tr = getThrowableToLog(args);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:277:            android.util.Log.i(normalizeTag(tag), message, tr);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:279:            android.util.Log.i(normalizeTag(tag), message);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:284:     * Sends a {@link android.util.Log#WARN} log message.
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:286:     * @param tag Used to identify the source of a log message. Might be modified in the output
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:288:     * @param messageTemplate The message you would like logged. It is to be specified as a format
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:295:        String message = formatLog(messageTemplate, args);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:296:        Throwable tr = getThrowableToLog(args);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:298:            android.util.Log.w(normalizeTag(tag), message, tr);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:300:            android.util.Log.w(normalizeTag(tag), message);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:305:     * Sends an {@link android.util.Log#ERROR} log message.
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:307:     * @param tag Used to identify the source of a log message. Might be modified in the output
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:309:     * @param messageTemplate The message you would like logged. It is to be specified as a format
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:316:        String message = formatLog(messageTemplate, args);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:317:        Throwable tr = getThrowableToLog(args);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:319:            android.util.Log.e(normalizeTag(tag), message, tr);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:321:            android.util.Log.e(normalizeTag(tag), message);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:326:     * What a Terrible Failure: Used for conditions that should never happen, and logged at
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:327:     * the {@link android.util.Log#ASSERT} level. Depending on the configuration, it might
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:330:     * @see android.util.Log#wtf(String, String, Throwable)
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:332:     * @param tag Used to identify the source of a log message. Might be modified in the output
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:334:     * @param messageTemplate The message you would like logged. It is to be specified as a format
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:341:        String message = formatLog(messageTemplate, args);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:342:        Throwable tr = getThrowableToLog(args);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:344:            android.util.Log.wtf(normalizeTag(tag), message, tr);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:346:            android.util.Log.wtf(normalizeTag(tag), message);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:350:    /** Handy function to get a loggable stack trace from a Throwable. */
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:352:        return android.util.Log.getStackTraceString(tr);
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:355:    private static Throwable getThrowableToLog(Object[] args) {
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:364:    /** Returns a string form of the origin of the log call, to be used as secondary tag.*/
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:371:        //  +1 privateLogFunction: verbose or debug
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:372:        //  +2 formatLogWithStack()
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:373:        //  +3 logFunction: v or d
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:377:        String logClassName = Log.class.getName();
videodec/libchromes/base/android/java/src/org/chromium/base/Log.java:379:            if (st[callerStackIndex].getClassName().equals(logClassName)) {
videodec/libchromes/base/android/java/src/org/chromium/base/BuildInfo.java:113:                Log.d(TAG, "GMS package is not found.", e);
videodec/libchromes/base/android/java/src/org/chromium/base/ContextUtils.java:142:            // If fallback logic is ever needed, refer to:
videodec/libchromes/base/android/java/src/org/chromium/base/ContextUtils.java:167:            // If fallback logic is ever needed, refer to:
videodec/libchromes/base/android/scoped_java_ref.h:15:#include "base/logging.h"
videodec/libchromes/base/android/library_loader/anchor_functions.cc:7:#include "base/logging.h"
videodec/libchromes/base/android/java_exception_reporter.cc:53:    LOG(ERROR) << exception_info;
videodec/libchromes/base/android/java_exception_reporter.cc:54:    LOG(FATAL) << "Uncaught exception";
videodec/libchromes/base/android/scoped_java_ref.cc:8:#include "base/logging.h"
videodec/libchromes/base/android/jni_string.cc:8:#include "base/logging.h"
videodec/libchromes/base/android/jni_string.cc:29:    LOG(WARNING) << "ConvertJavaStringToUTF8 called with null string.";
videodec/libchromes/base/android/jni_string.cc:80:    LOG(WARNING) << "ConvertJavaStringToUTF16 called with null string.";
videodec/libchromes/base/android/jni_generator/jni_generator_helper.h:13:#include "base/logging.h"
videodec/libchromes/base/android/jni_generator/jni_generator_helper.h:47:  LOG(ERROR) << "RegisterNatives failed in " << filename;
videodec/libchromes/base/android/jni_generator/testCalledByNatives.golden:75:static base::subtle::AtomicWord g_org_chromium_TestJni_showAutoLoginInfoBar = 0;
videodec/libchromes/base/android/jni_generator/testCalledByNatives.golden:76:static base::android::ScopedJavaLocalRef<jobject> Java_TestJni_showAutoLoginInfoBar(JNIEnv* env,
videodec/libchromes/base/android/jni_generator/testCalledByNatives.golden:86:          "showAutoLoginInfoBar",
videodec/libchromes/base/android/jni_generator/testCalledByNatives.golden:88:          &g_org_chromium_TestJni_showAutoLoginInfoBar);
videodec/libchromes/base/android/jni_generator/testCalledByNatives.golden:113:static base::subtle::AtomicWord g_org_chromium_TestJni_shouldShowAutoLogin = 0;
videodec/libchromes/base/android/jni_generator/testCalledByNatives.golden:114:static jboolean Java_TestJni_shouldShowAutoLogin(JNIEnv* env, const base::android::JavaRef<jobject>&
videodec/libchromes/base/android/jni_generator/testCalledByNatives.golden:124:          "shouldShowAutoLogin",
videodec/libchromes/base/android/jni_generator/testCalledByNatives.golden:126:          &g_org_chromium_TestJni_shouldShowAutoLogin);
videodec/libchromes/base/android/jni_generator/jni_generator_tests.py:411:    InnerClass showAutoLoginInfoBar(int nativeInfoBar,
videodec/libchromes/base/android/jni_generator/jni_generator_tests.py:413:        AutoLoginInfoBar infobar = new AutoLoginInfoBar(nativeInfoBar, mContext,
videodec/libchromes/base/android/jni_generator/jni_generator_tests.py:423:    private static boolean shouldShowAutoLogin(View view,
videodec/libchromes/base/android/jni_generator/jni_generator_tests.py:428:        String[] logins = accountManagerContainer.getAccountLogins(null);
videodec/libchromes/base/android/jni_generator/jni_generator_tests.py:429:        return logins.length != 0;
videodec/libchromes/base/android/jni_generator/jni_generator_tests.py:507:            name='showAutoLoginInfoBar',
videodec/libchromes/base/android/jni_generator/jni_generator_tests.py:508:            method_id_var_name='showAutoLoginInfoBar',
videodec/libchromes/base/android/jni_generator/jni_generator_tests.py:532:            name='shouldShowAutoLogin',
videodec/libchromes/base/android/jni_generator/jni_generator_tests.py:533:            method_id_var_name='shouldShowAutoLogin',
videodec/libchromes/base/android/jni_generator/jni_generator_tests.py:851:        Log.v(TAG, "Destroying native SyncSetupFlow");
videodec/libchromes/base/android/jni_generator/jni_generator_tests.py:927:import android.util.Log;
videodec/libchromes/base/android/jni_android.cc:16:#include "base/logging.h"
videodec/libchromes/base/android/jni_android.cc:54:      DPLOG(ERROR) << "prctl(PR_GET_NAME)";
videodec/libchromes/base/android/jni_android.cc:138:    LOG(FATAL) << "Failed to find class " << class_name;
videodec/libchromes/base/android/jni_android.cc:177:    LOG(FATAL) << "Failed to find " <<
videodec/libchromes/base/android/jni_android.cc:246:          "Java OOM'ed in exception handling, check logcat");
videodec/libchromes/base/android/jni_android.cc:258:    LOG(FATAL) << GetJavaExceptionInfo(env, java_throwable);
videodec/libchromes/base/android/jni_android.cc:260:    LOG(FATAL) << "Unhandled exception";
videodec/libchromes/base/version.cc:11:#include "base/logging.h"
videodec/libchromes/base/version.cc:129:  // version is still smaller. Same logic for equality (e.g. comparing 1.2.2 to
videodec/libchromes/base/version.cc:130:  // 1.2.2.* is 0 regardless of the wildcard). Under this logic,
videodec/libchromes/base/cpu.cc:183:    // See http://software.intel.com/en-us/blogs/2011/04/14/is-avx-enabled
videodec/libchromes/base/vlog.cc:5:#include "base/vlog.h"
videodec/libchromes/base/vlog.cc:12:#include "base/logging.h"
videodec/libchromes/base/vlog.cc:17:namespace VDLogGing {
videodec/libchromes/base/vlog.cc:19:const int VlogInfo::kDefaultVlogLevel = 0;
videodec/libchromes/base/vlog.cc:21:struct VlogInfo::VmodulePattern {
videodec/libchromes/base/vlog.cc:29:  int vlog_level;
videodec/libchromes/base/vlog.cc:33:VlogInfo::VmodulePattern::VmodulePattern(const std::string& pattern)
videodec/libchromes/base/vlog.cc:35:      vlog_level(VlogInfo::kDefaultVlogLevel),
videodec/libchromes/base/vlog.cc:44:VlogInfo::VmodulePattern::VmodulePattern()
videodec/libchromes/base/vlog.cc:45:    : vlog_level(VlogInfo::kDefaultVlogLevel),
videodec/libchromes/base/vlog.cc:48:VlogInfo::VlogInfo(const std::string& v_switch,
videodec/libchromes/base/vlog.cc:50:                   int* min_log_level)
videodec/libchromes/base/vlog.cc:51:    : min_log_level_(min_log_level) {
videodec/libchromes/base/vlog.cc:52:  DCHECK_NE(min_log_level, nullptr);
videodec/libchromes/base/vlog.cc:54:  int vlog_level = 0;
videodec/libchromes/base/vlog.cc:56:    if (base::StringToInt(v_switch, &vlog_level)) {
videodec/libchromes/base/vlog.cc:57:      SetMaxVlogLevel(vlog_level);
videodec/libchromes/base/vlog.cc:59:      DLOG(WARNING) << "Could not parse v switch \"" << v_switch << "\"";
videodec/libchromes/base/vlog.cc:66:    DLOG(WARNING) << "Could not fully parse vmodule switch \""
videodec/libchromes/base/vlog.cc:72:    if (!base::StringToInt(it->second, &pattern.vlog_level)) {
videodec/libchromes/base/vlog.cc:73:      DLOG(WARNING) << "Parsed vlog level for \""
videodec/libchromes/base/vlog.cc:75:                    << "\" as " << pattern.vlog_level;
videodec/libchromes/base/vlog.cc:81:VlogInfo::~VlogInfo() = default;
videodec/libchromes/base/vlog.cc:87:// number of dependencies the logging system has.
videodec/libchromes/base/vlog.cc:105:int VlogInfo::GetVlogLevel(const base::StringPiece& file) const {
videodec/libchromes/base/vlog.cc:112:      if (MatchVlogPattern(target, it->pattern))
videodec/libchromes/base/vlog.cc:113:        return it->vlog_level;
videodec/libchromes/base/vlog.cc:116:  return GetMaxVlogLevel();
videodec/libchromes/base/vlog.cc:119:void VlogInfo::SetMaxVlogLevel(int level) {
videodec/libchromes/base/vlog.cc:120:  // Log severity is the negative verbosity.
videodec/libchromes/base/vlog.cc:121:  *min_log_level_ = -level;
videodec/libchromes/base/vlog.cc:124:int VlogInfo::GetMaxVlogLevel() const {
videodec/libchromes/base/vlog.cc:125:  return -*min_log_level_;
videodec/libchromes/base/vlog.cc:128:bool MatchVlogPattern(const base::StringPiece& string,
videodec/libchromes/base/vlog.cc:129:                      const base::StringPiece& vlog_pattern) {
videodec/libchromes/base/vlog.cc:130:  base::StringPiece p(vlog_pattern);
videodec/libchromes/base/vlog.cc:172:    if (MatchVlogPattern(s, p))
videodec/libchromes/base/vlog.cc:181:}  // namespace logging
videodec/libchromes/base/sequence_checker.h:9:#include "base/logging.h"
videodec/libchromes/base/values.h:776:// Stream operator so that enum class Types can be used in log statements.
videodec/libchromes/base/native_library_posix.cc:10:#include "base/logging.h"
videodec/libchromes/base/native_library_posix.cc:51:    DLOG(ERROR) << "dlclose failed: " << dlerror();
videodec/libchromes/base/feature_list.cc:12:#include "base/logging.h"
videodec/libchromes/base/feature_list.cc:267:  // Update the behaviour of LOG_DCHECK to match the Feature configuration.
videodec/libchromes/base/feature_list.cc:274:    VDLogGing::LOG_DCHECK = VDLogGing::LOG_FATAL;
videodec/libchromes/base/feature_list.cc:276:    VDLogGing::LOG_DCHECK = VDLogGing::LOG_INFO;
videodec/libchromes/base/rand_util.cc:14:#include "base/logging.h"
videodec/libchromes/base/third_party/valgrind/valgrind.h:159:   from the compiled code (analogous to NDEBUG's effects on
videodec/libchromes/base/third_party/valgrind/valgrind.h:1253:#  define VALGRIND_CFI_PROLOGUE                                   \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1258:#  define VALGRIND_CFI_EPILOGUE                                   \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1263:#  define VALGRIND_CFI_PROLOGUE
videodec/libchromes/base/third_party/valgrind/valgrind.h:1264:#  define VALGRIND_CFI_EPILOGUE
videodec/libchromes/base/third_party/valgrind/valgrind.h:1299:         VALGRIND_CFI_PROLOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1304:         VALGRIND_CFI_EPILOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1320:         VALGRIND_CFI_PROLOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1326:         VALGRIND_CFI_EPILOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1343:         VALGRIND_CFI_PROLOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1350:         VALGRIND_CFI_EPILOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1368:         VALGRIND_CFI_PROLOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1376:         VALGRIND_CFI_EPILOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1395:         VALGRIND_CFI_PROLOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1404:         VALGRIND_CFI_EPILOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1424:         VALGRIND_CFI_PROLOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1434:         VALGRIND_CFI_EPILOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1455:         VALGRIND_CFI_PROLOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1466:         VALGRIND_CFI_EPILOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1489:         VALGRIND_CFI_PROLOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1502:         VALGRIND_CFI_EPILOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1526:         VALGRIND_CFI_PROLOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1540:         VALGRIND_CFI_EPILOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1565:         VALGRIND_CFI_PROLOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1580:         VALGRIND_CFI_EPILOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1606:         VALGRIND_CFI_PROLOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1622:         VALGRIND_CFI_EPILOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1649:         VALGRIND_CFI_PROLOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1666:         VALGRIND_CFI_EPILOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1694:         VALGRIND_CFI_PROLOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:1712:         VALGRIND_CFI_EPILOGUE                                    \
videodec/libchromes/base/third_party/valgrind/valgrind.h:4309:          /* Allow printfs to valgrind log. */
videodec/libchromes/base/path_service.cc:17:#include "base/logging.h"
videodec/libchromes/base/at_exit.cc:13:#include "base/logging.h"
videodec/libchromes/base/test/test_io_thread.cc:7:#include "base/logging.h"
videodec/libchromes/base/test/scoped_task_environment.cc:8:#include "base/logging.h"
videodec/libchromes/base/test/scoped_task_environment.cc:244:    // the above logic as it'd then be possible for a TaskScheduler task to be
videodec/libchromes/base/test/fuzzed_data_provider.cc:10:#include "base/logging.h"
videodec/libchromes/base/test/fuzzed_data_provider.cc:60:  // logic, a fuzzer can insert characters into the string, and the string will
videodec/libchromes/base/test/test_shared_memory_util.cc:12:#include "base/logging.h"
videodec/libchromes/base/test/test_shared_memory_util.cc:59:    LOG(ERROR) << "mmap() should have failed!";
videodec/libchromes/base/test/test_shared_memory_util.cc:64:    LOG(ERROR) << "Expected mmap() to return " << kExpectedErrno
videodec/libchromes/base/test/test_shared_memory_util.cc:81:    LOG(ERROR) << "zx_vmar_map() should have failed!";
videodec/libchromes/base/test/test_shared_memory_util.cc:86:    LOG(ERROR) << "Expected zx_vmar_map() to return " << ZX_ERR_ACCESS_DENIED
videodec/libchromes/base/test/test_shared_memory_util.cc:101:    LOG(ERROR) << "mach_vm_map() should have failed!";
videodec/libchromes/base/test/test_shared_memory_util.cc:113:    LOG(ERROR) << "MapViewOfFile() should have failed!";
videodec/libchromes/base/test/test_shared_memory_util.cc:140:    LOG(ERROR) << "Expected region mode is "
videodec/libchromes/base/test/simple_test_tick_clock.cc:7:#include "base/logging.h"
videodec/libchromes/base/test/test_mock_time_task_runner.h:266:  // Also used for non-dcheck logic (RunsTasksInCurrentSequence()) and as such
videodec/libchromes/base/test/test_timeouts.h:8:#include "base/logging.h"
videodec/libchromes/base/test/metrics/histogram_tester.cc:128:  // Find candidate matches by using the logic built into GetSnapshot().
videodec/libchromes/base/test/metrics/histogram_tester.h:27:// getting logged as intended.
videodec/libchromes/base/test/metrics/histogram_tester.h:124:  // Access a modified HistogramSamples containing only what has been logged
videodec/libchromes/base/test/test_mock_time_task_runner.cc:10:#include "base/logging.h"
videodec/libchromes/base/test/multiprocess_test_android.cc:15:#include "base/logging.h"
videodec/libchromes/base/test/gtest_util.h:13:#include "base/logging.h"
videodec/libchromes/base/test/test_timeouts.cc:11:#include "base/logging.h"
videodec/libchromes/base/test/test_timeouts.cc:31:      LOG(FATAL) << "Timeout value \"" << string_value << "\" was parsed as "
videodec/libchromes/base/test/test_file_util_posix.cc:17:#include "base/logging.h"
videodec/libchromes/base/test/test_simple_task_runner.cc:9:#include "base/logging.h"
videodec/libchromes/base/test/fontconfig_util_linux.cc:13:#include "base/logging.h"
videodec/libchromes/base/scoped_observer.h:13:#include "base/logging.h"
videodec/libchromes/base/sys_info_linux.cc:14:#include "base/logging.h"
videodec/libchromes/base/sys_info_linux.cc:63:  // The fallback logic (when there is no MemAvailable) would be more precise
videodec/libchromes/base/command_line.cc:11:#include "base/logging.h"
videodec/libchromes/base/command_line.cc:296:    DLOG(WARNING) << "Value of switch (" << switch_string << ") must be ASCII.";
videodec/libchromes/base/command_line.cc:435:  DPLOG_IF(FATAL, !args) << "CommandLineToArgvW failed on command line: "
videodec/libchromes/base/strings/safe_sprintf.cc:19:// restricted run-time context, it is not actually safe to call logging
videodec/libchromes/base/strings/safe_sprintf.cc:21:// best. We should _never_ call any logging function other than RAW_CHECK(),
videodec/libchromes/base/strings/safe_sprintf.cc:22:// and we should _never_ include any logging code that is active in production
videodec/libchromes/base/strings/safe_sprintf.cc:23:// builds. Most notably, we should not include these logging functions in
videodec/libchromes/base/strings/safe_sprintf.cc:37:#include "base/logging.h"
videodec/libchromes/base/strings/utf_string_conversions_regression_fuzzer.cc:5:#include "base/logging.h"
videodec/libchromes/base/strings/string_split.cc:9:#include "base/logging.h"
videodec/libchromes/base/strings/string_split.cc:115:    DVLOG(1) << "cannot find delimiter in: " << input;
videodec/libchromes/base/strings/string_split.cc:124:    DVLOG(1) << "cannot parse value from input: " << input;
videodec/libchromes/base/strings/string_number_conversions.cc:15:#include "base/logging.h"
videodec/libchromes/base/strings/string_number_conversions.cc:27:    // log10(2) ~= 0.3 bytes needed per bit or per byte log10(2**8) ~= 2.4.
videodec/libchromes/base/strings/stringprintf.cc:94:      DLOG(WARNING) << "Unable to printf the requested string due to size.";
videodec/libchromes/base/strings/string_piece.cc:13:#include "base/logging.h"
videodec/libchromes/base/strings/string_piece.h:31:#include "base/logging.h"
videodec/libchromes/base/strings/string_piece.h:193:    // This assertion is done out-of-line to avoid bringing in logging.h and
videodec/libchromes/base/strings/string_piece.h:194:    // instantiating logging macros for every instantiation.
videodec/libchromes/base/strings/string_util.cc:23:#include "base/logging.h"
videodec/libchromes/base/strings/string_util.cc:475:  // Prologue: align the input.
videodec/libchromes/base/strings/string_util.cc:1040:            DLOG(ERROR) << "Invalid placeholder: $" << *i;
videodec/libchromes/base/strings/string_util_posix.h:14:#include "base/logging.h"
videodec/libchromes/base/pickle.h:16:#include "base/logging.h"
videodec/libchromes/base/build_time.cc:7:#include "base/logging.h"
videodec/libchromes/base/metrics/histogram_macros.h:33:// be of the form of "event occurs, log the result". We recommended not putting
videodec/libchromes/base/metrics/histogram_macros.h:46://   // These values are persisted to logs. Entries should not be renumbered and
videodec/libchromes/base/metrics/histogram_macros.h:62://   // These values are persisted to logs. Entries should not be renumbered and
videodec/libchromes/base/metrics/histogram_macros.h:260:// Scoped class which logs its time on this earth as a UMA statistic. This is
videodec/libchromes/base/metrics/histogram_macros.h:304:// Histograms logged in as stability histograms will be included in the initial
videodec/libchromes/base/metrics/histogram_macros.h:305:// stability log. See comments by declaration of
videodec/libchromes/base/metrics/histogram_macros.h:306:// MetricsService::PrepareInitialStabilityLog().
videodec/libchromes/base/metrics/dummy_histogram.cc:9:#include "base/logging.h"
videodec/libchromes/base/metrics/histogram_macros_local.h:8:#include "base/logging.h"
videodec/libchromes/base/metrics/metrics_hashes.cc:7:#include "base/logging.h"
videodec/libchromes/base/metrics/statistics_recorder.h:173:  // Initializes logging histograms with --v=1. Safe to call multiple times.
videodec/libchromes/base/metrics/statistics_recorder.h:175:  // start logging after statistics recorder, so we need to init log-on-shutdown
videodec/libchromes/base/metrics/statistics_recorder.h:179:  static void InitLogOnShutdown();
videodec/libchromes/base/metrics/statistics_recorder.h:275:  static void InitLogOnShutdownWhileLocked();
videodec/libchromes/base/metrics/statistics_recorder.h:294:  // Tracks whether InitLogOnShutdownWhileLocked() has registered a logging
videodec/libchromes/base/metrics/statistics_recorder.h:296:  static bool is_vlog_initialized_;
videodec/libchromes/base/metrics/field_trial.cc:14:#include "base/logging.h"
videodec/libchromes/base/metrics/field_trial.cc:442:  DVLOG(1) << "Field trial: " << trial_name_ << " Group choice:" << group_name_;
videodec/libchromes/base/metrics/field_trial.cc:806:      // Use --enable-logging or --enable-logging=stderr to see this warning.
videodec/libchromes/base/metrics/field_trial.cc:807:      LOG(WARNING) << "Field trial: " << trial_name << " cannot be forced.";
videodec/libchromes/base/metrics/persistent_histogram_allocator.h:254:  // StatisticsRecorder, updating the "logged" samples within the passed
videodec/libchromes/base/metrics/persistent_histogram_allocator.h:259:  // As above but merge the "final" delta. No update of "logged" samples is
videodec/libchromes/base/metrics/persistent_sample_map.h:28:// The logic here is similar to that of SampleMap but with different data
videodec/libchromes/base/metrics/histogram.h:79:#include "base/logging.h"
videodec/libchromes/base/metrics/histogram.h:161:      const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.h:163:      HistogramSamples::Metadata* logged_meta);
videodec/libchromes/base/metrics/histogram.h:229:  // common logic for building a Histogram and can be overridden by more
videodec/libchromes/base/metrics/histogram.h:253:            const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.h:255:            HistogramSamples::Metadata* logged_meta);
videodec/libchromes/base/metrics/histogram.h:285:  // Create a snapshot containing all samples (both logged and unlogged).
videodec/libchromes/base/metrics/histogram.h:290:  // Create a copy of unlogged samples.
videodec/libchromes/base/metrics/histogram.h:291:  std::unique_ptr<SampleVector> SnapshotUnloggedSamples() const;
videodec/libchromes/base/metrics/histogram.h:323:  // Samples that have not yet been logged with SnapshotDelta().
videodec/libchromes/base/metrics/histogram.h:324:  std::unique_ptr<SampleVectorBase> unlogged_samples_;
videodec/libchromes/base/metrics/histogram.h:326:  // Accumulation of all samples that have been logged with SnapshotDelta().
videodec/libchromes/base/metrics/histogram.h:327:  std::unique_ptr<SampleVectorBase> logged_samples_;
videodec/libchromes/base/metrics/histogram.h:380:      const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.h:382:      HistogramSamples::Metadata* logged_meta);
videodec/libchromes/base/metrics/histogram.h:422:                  const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.h:424:                  HistogramSamples::Metadata* logged_meta);
videodec/libchromes/base/metrics/histogram.h:516:      const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.h:518:      HistogramSamples::Metadata* logged_meta);
videodec/libchromes/base/metrics/histogram.h:530:                   const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.h:532:                   HistogramSamples::Metadata* logged_meta);
videodec/libchromes/base/metrics/histogram.h:566:      const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.h:568:      HistogramSamples::Metadata* logged_meta);
videodec/libchromes/base/metrics/histogram.h:589:                  const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.h:591:                  HistogramSamples::Metadata* logged_meta);
videodec/libchromes/base/metrics/histogram_base.h:75:  HISTOGRAM_REPORT_TYPE_LOGARITHMIC = 3,
videodec/libchromes/base/metrics/histogram_base.h:111:    // which histograms should be included in the initial stability log. Please
videodec/libchromes/base/metrics/histogram_base.h:112:    // refer to |MetricsService::PrepareInitialStabilityLog|.
videodec/libchromes/base/metrics/histogram_base.h:228:  // what was previous logged. After such a call, no further calls to this
videodec/libchromes/base/metrics/sample_map.h:23:// The logic here is similar to that of PersistentSampleMap but with different
videodec/libchromes/base/metrics/histogram_snapshot_manager.cc:109:    DLOG(ERROR) << "Histogram: \"" << histogram->histogram_name()
videodec/libchromes/base/metrics/persistent_histogram_storage.cc:9:#include "base/logging.h"
videodec/libchromes/base/metrics/persistent_histogram_storage.cc:49:    LOG(ERROR)
videodec/libchromes/base/metrics/persistent_histogram_storage.cc:61:        LOG(ERROR)
videodec/libchromes/base/metrics/persistent_histogram_storage.cc:73:        LOG(ERROR)
videodec/libchromes/base/metrics/persistent_histogram_storage.cc:98:    LOG(ERROR) << "Persistent histograms fail to write to file: "
videodec/libchromes/base/metrics/user_metrics.h:17:// This module provides some helper functions for logging actions tracked by
videodec/libchromes/base/metrics/user_metrics.h:29://   not good: "SSLDialogShown", "PageLoaded", "DiskFull"
videodec/libchromes/base/metrics/histogram_flattener.h:19:// handles the logistics of gathering up available histograms for recording.
videodec/libchromes/base/metrics/histogram_base.cc:15:#include "base/logging.h"
videodec/libchromes/base/metrics/histogram_macros_internal.h:14:#include "base/logging.h"
videodec/libchromes/base/metrics/persistent_sample_map.cc:7:#include "base/logging.h"
videodec/libchromes/base/metrics/persistent_sample_map.cc:21:// An iterator for going through a PersistentSampleMap. The logic here is
videodec/libchromes/base/metrics/sample_vector.cc:8:#include "base/logging.h"
videodec/libchromes/base/metrics/histogram_functions.h:39://   // These values are persisted to logs. Entries should not be renumbered and
videodec/libchromes/base/metrics/histogram_functions.h:134:// version logged.
videodec/libchromes/base/metrics/persistent_memory_allocator.h:775:// from the logic that defines it. In addition, there can be multiple users
videodec/libchromes/base/metrics/persistent_memory_allocator.cc:18:#include "base/logging.h"
videodec/libchromes/base/metrics/persistent_memory_allocator.cc:57:// Errors that are logged in "errors" histogram.
videodec/libchromes/base/metrics/persistent_memory_allocator.cc:845:    LOG(ERROR) << "Corruption detected in shared-memory segment.";
videodec/libchromes/base/metrics/histogram.cc:22:#include "base/logging.h"
videodec/libchromes/base/metrics/histogram.cc:55:    DLOG(ERROR) << "Pickle error decoding Histogram: " << *histogram_name;
videodec/libchromes/base/metrics/histogram.cc:66:    DLOG(ERROR) << "Values error decoding Histogram: " << histogram_name;
videodec/libchromes/base/metrics/histogram.cc:242:    DLOG(ERROR) << "Histogram " << name_
videodec/libchromes/base/metrics/histogram.cc:313:    const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.cc:315:    HistogramSamples::Metadata* logged_meta) {
videodec/libchromes/base/metrics/histogram.cc:317:                                  logged_counts, meta, logged_meta));
videodec/libchromes/base/metrics/histogram.cc:333:  double log_max = log(static_cast<double>(maximum));
videodec/libchromes/base/metrics/histogram.cc:334:  double log_ratio;
videodec/libchromes/base/metrics/histogram.cc:335:  double log_next;
videodec/libchromes/base/metrics/histogram.cc:341:    double log_current;
videodec/libchromes/base/metrics/histogram.cc:342:    log_current = log(static_cast<double>(current));
videodec/libchromes/base/metrics/histogram.cc:344:    log_ratio = (log_max - log_current) / (bucket_count - bucket_index);
videodec/libchromes/base/metrics/histogram.cc:346:    log_next = log_current + log_ratio;
videodec/libchromes/base/metrics/histogram.cc:348:    next = static_cast<int>(std::round(exp(log_next)));
videodec/libchromes/base/metrics/histogram.cc:393:  return unlogged_samples_->bucket_ranges();
videodec/libchromes/base/metrics/histogram.cc:425:    DVLOG(1) << "Histogram: " << name << " has bad minimum: " << *minimum;
videodec/libchromes/base/metrics/histogram.cc:429:    DVLOG(1) << "Histogram: " << name << " has bad maximum: " << *maximum;
videodec/libchromes/base/metrics/histogram.cc:433:    DVLOG(1) << "Histogram: " << name << " has bad bucket_count: "
videodec/libchromes/base/metrics/histogram.cc:473:  return unlogged_samples_->id();
videodec/libchromes/base/metrics/histogram.cc:504:  unlogged_samples_->Accumulate(value, count);
videodec/libchromes/base/metrics/histogram.cc:524:  // logically updated "together", but end up being only partially updated when
videodec/libchromes/base/metrics/histogram.cc:526:  // exactly the snapshotted unlogged samples, rather than simply resetting the
videodec/libchromes/base/metrics/histogram.cc:530:  std::unique_ptr<HistogramSamples> snapshot = SnapshotUnloggedSamples();
videodec/libchromes/base/metrics/histogram.cc:531:  unlogged_samples_->Subtract(*snapshot);
videodec/libchromes/base/metrics/histogram.cc:532:  logged_samples_->Add(*snapshot);
videodec/libchromes/base/metrics/histogram.cc:543:  return SnapshotUnloggedSamples();
videodec/libchromes/base/metrics/histogram.cc:547:  unlogged_samples_->Add(samples);
videodec/libchromes/base/metrics/histogram.cc:551:  return unlogged_samples_->AddFromPickle(iter);
videodec/libchromes/base/metrics/histogram.cc:567:  CHECK(unlogged_samples_);
videodec/libchromes/base/metrics/histogram.cc:568:  CHECK(unlogged_samples_->bucket_ranges());
videodec/libchromes/base/metrics/histogram.cc:569:  CHECK(logged_samples_);
videodec/libchromes/base/metrics/histogram.cc:570:  CHECK(logged_samples_->bucket_ranges());
videodec/libchromes/base/metrics/histogram.cc:571:  CHECK_NE(0U, logged_samples_->id());
videodec/libchromes/base/metrics/histogram.cc:591:  unlogged_samples_.reset(new SampleVector(HashMetricName(name), ranges));
videodec/libchromes/base/metrics/histogram.cc:592:  logged_samples_.reset(new SampleVector(unlogged_samples_->id(), ranges));
videodec/libchromes/base/metrics/histogram.cc:600:                     const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.cc:602:                     HistogramSamples::Metadata* logged_meta)
videodec/libchromes/base/metrics/histogram.cc:605:  unlogged_samples_.reset(
videodec/libchromes/base/metrics/histogram.cc:607:  logged_samples_.reset(new PersistentSampleVector(
videodec/libchromes/base/metrics/histogram.cc:608:      unlogged_samples_->id(), ranges, logged_meta, logged_counts));
videodec/libchromes/base/metrics/histogram.cc:666:  std::unique_ptr<SampleVector> samples = SnapshotUnloggedSamples();
videodec/libchromes/base/metrics/histogram.cc:667:  samples->Add(*logged_samples_);
videodec/libchromes/base/metrics/histogram.cc:671:std::unique_ptr<SampleVector> Histogram::SnapshotUnloggedSamples() const {
videodec/libchromes/base/metrics/histogram.cc:673:      new SampleVector(unlogged_samples_->id(), bucket_ranges()));
videodec/libchromes/base/metrics/histogram.cc:674:  samples->Add(*unlogged_samples_);
videodec/libchromes/base/metrics/histogram.cc:910:    const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.cc:912:    HistogramSamples::Metadata* logged_meta) {
videodec/libchromes/base/metrics/histogram.cc:914:                                        logged_counts, meta, logged_meta));
videodec/libchromes/base/metrics/histogram.cc:948:    const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.cc:950:    HistogramSamples::Metadata* logged_meta)
videodec/libchromes/base/metrics/histogram.cc:956:                logged_counts,
videodec/libchromes/base/metrics/histogram.cc:958:                logged_meta) {}
videodec/libchromes/base/metrics/histogram.cc:1127:    const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.cc:1129:    HistogramSamples::Metadata* logged_meta) {
videodec/libchromes/base/metrics/histogram.cc:1130:  return WrapUnique(new BooleanHistogram(name, ranges, counts, logged_counts,
videodec/libchromes/base/metrics/histogram.cc:1131:                                         meta, logged_meta));
videodec/libchromes/base/metrics/histogram.cc:1145:    const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.cc:1147:    HistogramSamples::Metadata* logged_meta)
videodec/libchromes/base/metrics/histogram.cc:1153:                      logged_counts,
videodec/libchromes/base/metrics/histogram.cc:1155:                      logged_meta) {}
videodec/libchromes/base/metrics/histogram.cc:1244:    const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.cc:1246:    HistogramSamples::Metadata* logged_meta) {
videodec/libchromes/base/metrics/histogram.cc:1247:  return WrapUnique(new CustomHistogram(name, ranges, counts, logged_counts,
videodec/libchromes/base/metrics/histogram.cc:1248:                                        meta, logged_meta));
videodec/libchromes/base/metrics/histogram.cc:1279:    const DelayedPersistentAllocation& logged_counts,
videodec/libchromes/base/metrics/histogram.cc:1281:    HistogramSamples::Metadata* logged_meta)
videodec/libchromes/base/metrics/histogram.cc:1287:                logged_counts,
videodec/libchromes/base/metrics/histogram.cc:1289:                logged_meta) {}
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:15:#include "base/logging.h"
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:82:  // 2 because each "sample count" also requires a backup "logged count"
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:249:  HistogramSamples::Metadata logged_metadata;
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:295:      data->samples_metadata.id == 0 || data->logged_metadata.id == 0 ||
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:296:      // Note: Sparse histograms use |id + 1| in |logged_metadata|.
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:297:      (data->logged_metadata.id != data->samples_metadata.id &&
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:298:       data->logged_metadata.id != data->samples_metadata.id + 1) ||
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:410:    DCHECK_NE(0U, histogram_data->logged_metadata.id);
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:507:                                          &histogram_data_ptr->logged_metadata);
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:560:  // The "counts" data (including both samples and logged samples) is a delayed
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:573:  // and the second half is for "logged counts".
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:574:  DelayedPersistentAllocation logged_data(
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:586:          logged_data, &histogram_data_ptr->samples_metadata,
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:587:          &histogram_data_ptr->logged_metadata);
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:593:          logged_data, &histogram_data_ptr->samples_metadata,
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:594:          &histogram_data_ptr->logged_metadata);
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:599:          name, ranges, counts_data, logged_data,
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:601:          &histogram_data_ptr->logged_metadata);
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:606:          name, ranges, counts_data, logged_data,
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:608:          &histogram_data_ptr->logged_metadata);
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:898:  DVLOG_IF(1, existing)
videodec/libchromes/base/metrics/persistent_histogram_allocator.cc:954:    LOG(ERROR) << "Could not write \"" << Name() << "\" persistent histograms"
videodec/libchromes/base/metrics/bucket_ranges.cc:9:#include "base/logging.h"
videodec/libchromes/base/metrics/field_trial.h:561:  // Achieves the same thing as CreateTrialsFromString, except wraps the logic
videodec/libchromes/base/metrics/sparse_histogram.h:40:      HistogramSamples::Metadata* logged_meta);
videodec/libchromes/base/metrics/sparse_histogram.h:71:                  HistogramSamples::Metadata* logged_meta);
videodec/libchromes/base/metrics/sparse_histogram.h:100:  std::unique_ptr<HistogramSamples> unlogged_samples_;
videodec/libchromes/base/metrics/sparse_histogram.h:101:  std::unique_ptr<HistogramSamples> logged_samples_;
videodec/libchromes/base/metrics/histogram_samples.h:164:    SAMPLES_HAVE_LOGGED_BUT_NOT_SAMPLE,
videodec/libchromes/base/metrics/histogram_samples.h:165:    SAMPLES_SAMPLE_LESS_THAN_LOGGED,
videodec/libchromes/base/metrics/histogram_samples.h:219:  // Note: |max| is int64_t because histograms support logged values in the
videodec/libchromes/base/metrics/histogram_delta_serialization.cc:7:#include "base/logging.h"
videodec/libchromes/base/metrics/histogram_delta_serialization.cc:27:    DVLOG(1) << "Single process mode, histogram observed and not copied: "
videodec/libchromes/base/metrics/histogram_snapshot_manager.h:24:// HistogramSnapshotManager handles the logistics of gathering up available
videodec/libchromes/base/metrics/histogram_snapshot_manager.h:49:  // except that it does not update the previous logged values and can thus
videodec/libchromes/base/metrics/histogram_snapshot_manager.h:71:  // |histogram_flattener_| handles the logistics of recording the histogram
videodec/libchromes/base/metrics/sparse_histogram.cc:83:    HistogramSamples::Metadata* logged_meta) {
videodec/libchromes/base/metrics/sparse_histogram.cc:85:      new SparseHistogram(allocator, name, meta, logged_meta));
videodec/libchromes/base/metrics/sparse_histogram.cc:91:  return unlogged_samples_->id();
videodec/libchromes/base/metrics/sparse_histogram.cc:117:    unlogged_samples_->Accumulate(value, count);
videodec/libchromes/base/metrics/sparse_histogram.cc:127:  snapshot->Add(*unlogged_samples_);
videodec/libchromes/base/metrics/sparse_histogram.cc:128:  snapshot->Add(*logged_samples_);
videodec/libchromes/base/metrics/sparse_histogram.cc:137:  snapshot->Add(*unlogged_samples_);
videodec/libchromes/base/metrics/sparse_histogram.cc:139:  unlogged_samples_->Subtract(*snapshot);
videodec/libchromes/base/metrics/sparse_histogram.cc:140:  logged_samples_->Add(*snapshot);
videodec/libchromes/base/metrics/sparse_histogram.cc:150:  snapshot->Add(*unlogged_samples_);
videodec/libchromes/base/metrics/sparse_histogram.cc:157:  unlogged_samples_->Add(samples);
videodec/libchromes/base/metrics/sparse_histogram.cc:162:  return unlogged_samples_->AddFromPickle(iter);
videodec/libchromes/base/metrics/sparse_histogram.cc:182:      unlogged_samples_(new SampleMap(HashMetricName(name))),
videodec/libchromes/base/metrics/sparse_histogram.cc:183:      logged_samples_(new SampleMap(unlogged_samples_->id())) {}
videodec/libchromes/base/metrics/sparse_histogram.cc:188:                                 HistogramSamples::Metadata* logged_meta)
videodec/libchromes/base/metrics/sparse_histogram.cc:191:      // sufficient space for both "active" and "logged" samples, with each
videodec/libchromes/base/metrics/sparse_histogram.cc:195:      // Since a sparse histogram has two sample maps (active and logged),
videodec/libchromes/base/metrics/sparse_histogram.cc:198:      // that of the histogram while the "logged" samples use that number
videodec/libchromes/base/metrics/sparse_histogram.cc:200:      unlogged_samples_(
videodec/libchromes/base/metrics/sparse_histogram.cc:202:      logged_samples_(new PersistentSampleMap(unlogged_samples_->id() + 1,
videodec/libchromes/base/metrics/sparse_histogram.cc:204:                                              logged_meta)) {}
videodec/libchromes/base/metrics/sparse_histogram.cc:210:    DLOG(ERROR) << "Pickle error decoding Histogram: " << histogram_name;
videodec/libchromes/base/metrics/statistics_recorder.cc:12:#include "base/logging.h"
videodec/libchromes/base/metrics/statistics_recorder.cc:40:bool StatisticsRecorder::is_vlog_initialized_ = false;
videodec/libchromes/base/metrics/statistics_recorder.cc:234:void StatisticsRecorder::InitLogOnShutdown() {
videodec/libchromes/base/metrics/statistics_recorder.cc:236:  InitLogOnShutdownWhileLocked();
videodec/libchromes/base/metrics/statistics_recorder.cc:399:  InitLogOnShutdownWhileLocked();
videodec/libchromes/base/metrics/statistics_recorder.cc:403:void StatisticsRecorder::InitLogOnShutdownWhileLocked() {
videodec/libchromes/base/metrics/statistics_recorder.cc:405:  if (!is_vlog_initialized_ && VLOG_IS_ON(1)) {
videodec/libchromes/base/metrics/statistics_recorder.cc:406:    is_vlog_initialized_ = true;
videodec/libchromes/base/metrics/statistics_recorder.cc:407:    const auto dump_to_vlog = [](void*) {
videodec/libchromes/base/metrics/statistics_recorder.cc:410:      VLOG(1) << output;
videodec/libchromes/base/metrics/statistics_recorder.cc:412:    AtExitManager::RegisterCallback(dump_to_vlog, nullptr);
videodec/libchromes/base/metrics/sample_map.cc:7:#include "base/logging.h"
videodec/libchromes/base/metrics/sample_map.cc:19:// An iterator for going through a SampleMap. The logic here is identical
videodec/libchromes/base/optional.h:11:#include "base/logging.h"
videodec/libchromes/base/optional.h:402:// https://blogs.msdn.microsoft.com/vcblog/2016/03/30/optimizing-the-layout-of-empty-base-classes-in-vs2015-update-2-3/
videodec/libchromes/base/memory/ref_counted_delete_on_sequence.h:11:#include "base/logging.h"
videodec/libchromes/base/memory/shared_memory_handle_android.cc:10:#include "base/logging.h"
videodec/libchromes/base/memory/shared_memory_handle_android.cc:21:    DPLOG(ERROR) << "ashmem_get_prot_region";
videodec/libchromes/base/memory/shared_memory_handle_android.cc:60:    PLOG(ERROR) << "close";
videodec/libchromes/base/memory/shared_memory_handle_android.cc:109:    DPLOG(ERROR) << "ashmem_set_prot_region";
videodec/libchromes/base/memory/singleton.h:34:#include "base/logging.h"
videodec/libchromes/base/memory/singleton.h:86:// This is useful for a certain category of things, notably logging and
videodec/libchromes/base/memory/singleton.h:89:// In logging and tracing you'll typically get stray calls at odd times, like
videodec/libchromes/base/memory/singleton.h:97:// a callback the system will invoke when logging levels change. Note that
videodec/libchromes/base/memory/ref_counted_memory.cc:9:#include "base/logging.h"
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:26:      PLOG(WARNING) << "unlink";
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:38:    DPLOG(ERROR) << "fcntl(" << fd << ", F_GETFL) failed";
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:44:    DLOG(ERROR) << "Descriptor access mode (" << mode
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:93:        DLOG(WARNING) << "Readonly handle shouldn't be valid for a "
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:99:        DLOG(ERROR)
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:105:      DLOG(ERROR) << "Invalid permission mode: " << static_cast<int>(mode);
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:130:    DPLOG(ERROR) << "dup(" << handle_.fd.get() << ") failed";
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:180:    DPLOG(ERROR) << "mmap " << handle_.fd.get() << " failed";
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:222:    PLOG(ERROR) << "Creating shared memory in " << path.value() << " failed";
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:225:      PLOG(ERROR) << "Unable to access(W_OK|X_OK) " << dir.value();
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:227:        LOG(FATAL) << "This is frequently caused by incorrect permissions on "
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:244:      DPLOG(ERROR) << "open(\"" << path.value() << "\", O_RDONLY) failed";
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:266:      LOG(ERROR) << "Writable and read-only inodes don't match; bailing";
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:291:    DLOG(ERROR) << "The second descriptor must be invalid";
videodec/libchromes/base/memory/platform_shared_memory_region_posix.cc:310:    DLOG(ERROR) << "Descriptor has a wrong access mode: it is"
videodec/libchromes/base/memory/shared_memory_handle_posix.cc:9:#include "base/logging.h"
videodec/libchromes/base/memory/shared_memory_handle_posix.cc:43:    PLOG(ERROR) << "close";
videodec/libchromes/base/memory/shared_memory_android.cc:10:#include "base/logging.h"
videodec/libchromes/base/memory/shared_memory_android.cc:32:    DLOG(ERROR) << "Shared memory creation failed";
videodec/libchromes/base/memory/shared_memory_android.cc:39:    DLOG(ERROR) << "Error " << err << " when setting protection of ashmem";
videodec/libchromes/base/memory/ref_counted.h:15:#include "base/logging.h"
videodec/libchromes/base/memory/platform_shared_memory_region_mac.cc:9:#include "base/mac/mach_logging.h"
videodec/libchromes/base/memory/platform_shared_memory_region_mac.cc:61:    MACH_DLOG(ERROR, kr) << "mach_port_mod_refs";
videodec/libchromes/base/memory/platform_shared_memory_region_mac.cc:91:      MACH_DLOG(ERROR, kr) << "mach_vm_map";
videodec/libchromes/base/memory/platform_shared_memory_region_mac.cc:106:    MACH_DLOG(ERROR, kr) << "mach_make_memory_entry_64";
videodec/libchromes/base/memory/platform_shared_memory_region_mac.cc:152:    MACH_DLOG(ERROR, kr) << "mach_vm_map";
videodec/libchromes/base/memory/platform_shared_memory_region_mac.cc:183:    MACH_DLOG(ERROR, kr) << "mach_make_memory_entry_64";
videodec/libchromes/base/memory/platform_shared_memory_region_mac.cc:205:    MACH_DLOG_IF(ERROR, kr_deallocate != KERN_SUCCESS, kr_deallocate)
videodec/libchromes/base/memory/platform_shared_memory_region_mac.cc:208:    MACH_DLOG(ERROR, kr) << "mach_vm_map";
videodec/libchromes/base/memory/platform_shared_memory_region_mac.cc:216:    DLOG(ERROR) << "VM region has a wrong protection mask: it is"
videodec/libchromes/base/memory/shared_memory_helper.cc:23:      PLOG(WARNING) << "unlink";
videodec/libchromes/base/memory/shared_memory_helper.cc:61:      DPLOG(ERROR) << "open(\"" << path->value() << "\", O_RDONLY) failed";
videodec/libchromes/base/memory/shared_memory_helper.cc:92:      LOG(ERROR) << "writable and read-only inodes don't match; bailing";
videodec/libchromes/base/memory/shared_memory_helper.cc:115:            PLOG(ERROR) << "setrlimit() failed";
videodec/libchromes/base/memory/shared_memory_helper.cc:119:        PLOG(ERROR) << "getrlimit() failed";
videodec/libchromes/base/memory/shared_memory_helper.cc:138:          PLOG(ERROR) << "readlink failed for: " << fd_path;
videodec/libchromes/base/memory/shared_memory_helper.cc:145:        LOG(ERROR) << i << ": " << buf;
videodec/libchromes/base/memory/shared_memory_helper.cc:147:      LOG(FATAL) << "Logged for file descriptor exhaustion, crashing now";
videodec/libchromes/base/memory/linked_ptr.h:36:#include "base/logging.h"  // for CHECK macros
videodec/libchromes/base/memory/shared_memory_mapping.cc:9:#include "base/logging.h"
videodec/libchromes/base/memory/shared_memory_mapping.cc:25:#include "base/mac/mach_logging.h"
videodec/libchromes/base/memory/shared_memory_mapping.cc:77:    DPLOG(ERROR) << "UnmapViewOfFile";
videodec/libchromes/base/memory/shared_memory_mapping.cc:81:  DLOG_IF(ERROR, status != ZX_OK)
videodec/libchromes/base/memory/shared_memory_mapping.cc:86:  MACH_DLOG_IF(ERROR, kr != KERN_SUCCESS, kr) << "mach_vm_deallocate";
videodec/libchromes/base/memory/shared_memory_mapping.cc:89:    DPLOG(ERROR) << "munmap";
videodec/libchromes/base/memory/weak_ptr.h:77:#include "base/logging.h"
videodec/libchromes/base/memory/aligned_memory.cc:7:#include "base/logging.h"
videodec/libchromes/base/memory/aligned_memory.cc:38:    DLOG(ERROR) << "If you crashed here, your aligned allocation is incorrect: "
videodec/libchromes/base/memory/protected_memory.h:57:#include "base/logging.h"
videodec/libchromes/base/memory/protected_memory.h:176:// AutoWritableMemory is in scope. This class implements the logic for setting
videodec/libchromes/base/memory/scoped_refptr.h:15:#include "base/logging.h"
videodec/libchromes/base/memory/shared_memory_mapping.h:42:  // Returns the logical size of the mapping in bytes. This is precisely the
videodec/libchromes/base/memory/shared_memory_posix.cc:16:#include "base/logging.h"
videodec/libchromes/base/memory/shared_memory_posix.cc:151:        LOG(ERROR) <<
videodec/libchromes/base/memory/shared_memory_posix.cc:165:        DPLOG(ERROR) << "open(\"" << path.value() << "\", O_RDONLY) failed";
videodec/libchromes/base/memory/shared_memory_posix.cc:184:    PLOG(ERROR) << "Creating shared memory in " << path.value() << " failed";
videodec/libchromes/base/memory/shared_memory_posix.cc:187:      PLOG(ERROR) << "Unable to access(W_OK|X_OK) " << dir.value();
videodec/libchromes/base/memory/shared_memory_posix.cc:189:        LOG(FATAL) << "This is frequently caused by incorrect permissions on "
videodec/libchromes/base/memory/shared_memory_posix.cc:235:    DPLOG(ERROR) << "open(\"" << path.value() << "\", O_RDONLY) failed";
videodec/libchromes/base/memory/shared_memory_posix.cc:286:  //   // or during unit-testing (assuming a ScopedLogAssertHandler was installed).
videodec/libchromes/base/bits.h:14:#include "base/logging.h"
videodec/libchromes/base/bits.h:169:inline int Log2Floor(uint32_t n) {
videodec/libchromes/base/bits.h:174:inline int Log2Ceiling(uint32_t n) {
videodec/libchromes/base/values.cc:16:#include "base/logging.h"
videodec/libchromes/base/threading/platform_thread.h:32:// Used for logging. Always an integer value.
videodec/libchromes/base/threading/platform_thread.h:132:  // Gets the current thread id, which may be useful for logging purposes.
videodec/libchromes/base/threading/platform_thread_internal_posix.cc:8:#include "base/logging.h"
videodec/libchromes/base/threading/sequence_local_storage_slot.cc:10:#include "base/logging.h"
videodec/libchromes/base/threading/thread_local_storage_posix.cc:7:#include "base/logging.h"
videodec/libchromes/base/threading/thread_id_name_manager.cc:10:#include "base/logging.h"
videodec/libchromes/base/threading/sequence_local_storage_map.cc:10:#include "base/logging.h"
videodec/libchromes/base/threading/simple_thread.cc:7:#include "base/logging.h"
videodec/libchromes/base/threading/thread_local_storage.cc:8:#include "base/logging.h"
videodec/libchromes/base/threading/thread_restrictions.cc:10:#include "base/logging.h"
videodec/libchromes/base/threading/thread.cc:11:#include "base/logging.h"
videodec/libchromes/base/threading/thread.cc:117:      DLOG(ERROR) << "failed to create thread";
videodec/libchromes/base/threading/scoped_blocking_call.h:9:#include "base/logging.h"
videodec/libchromes/base/threading/thread_checker.h:9:#include "base/logging.h"
videodec/libchromes/base/threading/thread_collision_warner.cc:7:#include "base/logging.h"
videodec/libchromes/base/threading/platform_thread_linux.cc:13:#include "base/logging.h"
videodec/libchromes/base/threading/platform_thread_linux.cc:55:    DVLOG(1) << "Failed to add " << tid << " to " << tasks_filepath.value();
videodec/libchromes/base/threading/platform_thread_linux.cc:139:  // http://0pointer.de/blog/projects/name-your-threads.html
videodec/libchromes/base/threading/platform_thread_linux.cc:147:    DPLOG(ERROR) << "prctl(PR_SET_NAME)";
videodec/libchromes/base/threading/platform_thread_linux.cc:164:    DVPLOG(1) << "Failed to set nice value of thread (" << thread_id << ") to "
videodec/libchromes/base/threading/thread_task_runner_handle.cc:11:#include "base/logging.h"
videodec/libchromes/base/threading/platform_thread_posix.cc:20:#include "base/logging.h"
videodec/libchromes/base/threading/platform_thread_posix.cc:124:    PLOG(ERROR) << "pthread_create";
videodec/libchromes/base/threading/platform_thread_posix.cc:270:    DVPLOG(1) << "Failed to set nice value of thread ("
videodec/libchromes/base/threading/platform_thread_posix.cc:294:    DVPLOG(1) << "Failed to get nice value of thread ("
videodec/libchromes/base/threading/thread_restrictions.h:10:#include "base/logging.h"
videodec/libchromes/base/threading/post_task_and_reply_impl.cc:11:#include "base/logging.h"
videodec/libchromes/base/threading/thread.h:334:  // cleanup logic as required.
videodec/libchromes/base/threading/sequenced_task_runner_handle.cc:10:#include "base/logging.h"
videodec/libchromes/base/threading/thread_local.h:32://   // My class is logically attached to a single thread. We cache a pointer
videodec/libchromes/base/base_switches.cc:46:// Suppresses all error dialogs when present.
videodec/libchromes/base/base_switches.cc:47:const char kNoErrorDialogs[]                = "noerrdialogs";
videodec/libchromes/base/base_switches.cc:58:// Gives the default maximal active V-logging level; 0 is the default.
videodec/libchromes/base/base_switches.cc:59:// Normally positive values are used for V-logging levels.
videodec/libchromes/base/base_switches.cc:62:// Gives the per-module maximal V-logging levels to override the value
videodec/libchromes/base/base_switches.cc:63:// given by --v.  E.g. "my_module=2,foo*=3" would change the logging
videodec/libchromes/base/base_switches.cc:69:// "*/foo/bar/*=2" would change the logging level for all code in
videodec/libchromes/base/callback_list.h:13:#include "base/logging.h"
videodec/libchromes/base/rand_util_posix.cc:15:#include "base/logging.h"
videodec/libchromes/base/bit_cast.h:56:// logic in one place.
videodec/libchromes/base/allocator/allocator_extension.cc:7:#include "base/logging.h"
videodec/libchromes/base/allocator/allocator_shim.cc:12:#include "base/logging.h"
videodec/libchromes/base/bind.h:391:// through a Callback. Logically, this signifies a destructive transfer of
videodec/libchromes/base/bind.h:470://   Callback<void(int)> cb = Bind(RetainBlock(^(int n) { NSLog(@"%d", n); }));
videodec/libchromes/base/bind.h:471://   cb.Run(1);  // Logs "1".
videodec/libchromes/base/cancelable_callback.h:54:#include "base/logging.h"
videodec/libchromes/base/message_loop/incoming_task_queue.h:38:    // logic requiring synchronization (override DidQueueTask() for that).
videodec/libchromes/base/message_loop/incoming_task_queue.h:156:    // queue itself is empty (Clear() has special logic to reload only once
videodec/libchromes/base/message_loop/message_loop.cc:13:#include "base/logging.h"
videodec/libchromes/base/message_loop/message_loop.cc:500:      // makes the logic simpler for untriaged delayed tasks which may alter the
videodec/libchromes/base/message_loop/message_loop.cc:618:  // Do not report idle metrics nor do any logic related to delayed tasks if
videodec/libchromes/base/message_loop/message_loop_task_runner.cc:10:#include "base/logging.h"
videodec/libchromes/base/message_loop/message_loop_current.h:9:#include "base/logging.h"
videodec/libchromes/base/message_loop/message_pump_libevent.cc:15:#include "base/logging.h"
videodec/libchromes/base/message_loop/message_pump_libevent.cc:118:      DPLOG(ERROR) << "close";
videodec/libchromes/base/message_loop/message_pump_libevent.cc:122:      DPLOG(ERROR) << "close";
videodec/libchromes/base/message_loop/message_pump_libevent.cc:175:    DPLOG(ERROR) << "event_base_set(fd=" << EVENT_FD(evt.get()) << ")";
videodec/libchromes/base/message_loop/message_pump_libevent.cc:181:    DPLOG(ERROR) << "event_add failed(fd=" << EVENT_FD(evt.get()) << ")";
videodec/libchromes/base/message_loop/message_pump_libevent.cc:287:    DPLOG(ERROR) << "pipe creation failed";
videodec/libchromes/base/message_loop/incoming_task_queue.cc:58:  DLOG_IF(WARNING, delay > kTaskDelayWarningThreshold)
videodec/libchromes/base/message_loop/incoming_task_queue.cc:126:  // their destructors. See ~MessageLoop() for the full logic mitigating against
videodec/libchromes/base/message_loop/message_pump_default.cc:8:#include "base/logging.h"
videodec/libchromes/base/message_loop/message_pump_default.cc:15:#include "base/mac/mach_logging.h"
videodec/libchromes/base/message_loop/message_pump_default.cc:99:  MACH_DVLOG_IF(1, kr != KERN_SUCCESS, kr) << "thread_policy_set";
videodec/libchromes/base/message_loop/message_pump_glib.cc:13:#include "base/logging.h"
videodec/libchromes/base/message_loop/message_loop.h:69:// with dialogs (DialogBox), common dialogs (GetOpenFileName), OLE functions
videodec/libchromes/base/observer_list.h:17:#include "base/logging.h"
videodec/libchromes/base/task_runner_util.h:13:#include "base/logging.h"
videodec/libchromes/base/sys_byteorder.h:16:#include "base/logging.h"
videodec/libchromes/base/files/file_path_watcher.cc:10:#include "base/logging.h"
videodec/libchromes/base/files/file_descriptor_watcher_posix.cc:9:#include "base/logging.h"
videodec/libchromes/base/files/file_descriptor_watcher_posix.cc:117:    // closed |fd_| on another thread, so the best we can do is Debug-log.
videodec/libchromes/base/files/file_descriptor_watcher_posix.cc:118:    DLOG(ERROR) << "Failed to watch fd=" << fd_;
videodec/libchromes/base/files/file.h:351:  // Converts an error value to a human-readable form. Used for logging.
videodec/libchromes/base/files/memory_mapped_file.cc:10:#include "base/logging.h"
videodec/libchromes/base/files/memory_mapped_file.cc:53:    DLOG(ERROR) << "Couldn't open " << file_name.AsUTF8Unsafe();
videodec/libchromes/base/files/memory_mapped_file.cc:80:          DLOG(ERROR) << "Region bounds exceed maximum for base::File.";
videodec/libchromes/base/files/memory_mapped_file.cc:89:        DLOG(ERROR) << "Region bounds are not valid.";
videodec/libchromes/base/files/file_posix.cc:13:#include "base/logging.h"
videodec/libchromes/base/files/important_file_writer.cc:20:#include "base/logging.h"
videodec/libchromes/base/files/important_file_writer.cc:90:void LogFailure(const FilePath& path,
videodec/libchromes/base/files/important_file_writer.cc:97:  DPLOG(WARNING) << "temp file failure: " << path.value() << " : " << message;
videodec/libchromes/base/files/important_file_writer.cc:161:    LogFailure(path, histogram_suffix, FAILED_CREATING,
videodec/libchromes/base/files/important_file_writer.cc:171:    LogFailure(path, histogram_suffix, FAILED_OPENING,
videodec/libchromes/base/files/important_file_writer.cc:189:    LogFailure(path, histogram_suffix, FAILED_WRITING,
videodec/libchromes/base/files/important_file_writer.cc:196:    LogFailure(path, histogram_suffix, FAILED_FLUSHING, "error flushing");
videodec/libchromes/base/files/important_file_writer.cc:206:    LogFailure(path, histogram_suffix, FAILED_RENAMING,
videodec/libchromes/base/files/important_file_writer.cc:293:    DLOG(WARNING) << "failed to serialize data to be saved in "
videodec/libchromes/base/files/file_path.cc:10:#include "base/logging.h"
videodec/libchromes/base/files/file_path.cc:708:  // http://blogs.msdn.com/michkap/archive/2005/10/17/481600.aspx
videodec/libchromes/base/files/dir_reader_linux.h:15:#include "base/logging.h"
videodec/libchromes/base/files/dir_reader_linux.h:43:        RAW_LOG(ERROR, "Failed to close directory handle");
videodec/libchromes/base/files/dir_reader_linux.h:65:      DPLOG(FATAL) << "getdents64 returned an error: " << errno;
videodec/libchromes/base/files/file_util.cc:17:#include "base/logging.h"
videodec/libchromes/base/files/file_util_posix.cc:31:#include "base/logging.h"
videodec/libchromes/base/files/file_util_posix.cc:99:    DPLOG(ERROR) << "Failed to get information on path "
videodec/libchromes/base/files/file_util_posix.cc:105:    DLOG(ERROR) << "Path " << path.value() << " is a symbolic link.";
videodec/libchromes/base/files/file_util_posix.cc:110:    DLOG(ERROR) << "Path " << path.value() << " is owned by the wrong user.";
videodec/libchromes/base/files/file_util_posix.cc:116:    DLOG(ERROR) << "Path " << path.value()
videodec/libchromes/base/files/file_util_posix.cc:122:    DLOG(ERROR) << "Path " << path.value() << " is writable by any user.";
videodec/libchromes/base/files/file_util_posix.cc:220:    DPLOG(ERROR) << "CopyDirectory() couldn't stat source directory: "
videodec/libchromes/base/files/file_util_posix.cc:252:      DPLOG(ERROR) << "CopyDirectory() couldn't create directory: "
videodec/libchromes/base/files/file_util_posix.cc:258:      DLOG(WARNING) << "CopyDirectory() skipping non-regular file: "
videodec/libchromes/base/files/file_util_posix.cc:266:      DPLOG(ERROR) << "CopyDirectory() couldn't open file: " << current.value();
videodec/libchromes/base/files/file_util_posix.cc:272:      DPLOG(ERROR) << "CopyDirectory() couldn't stat file: " << current.value();
videodec/libchromes/base/files/file_util_posix.cc:277:      DLOG(WARNING) << "CopyDirectory() skipping non-regular file: "
videodec/libchromes/base/files/file_util_posix.cc:306:      DPLOG(ERROR) << "CopyDirectory() couldn't create file: "
videodec/libchromes/base/files/file_util_posix.cc:312:      DLOG(ERROR) << "CopyDirectory() couldn't copy file: " << current.value();
videodec/libchromes/base/files/file_util_posix.cc:569:    LOG(ERROR) << "No $PATH variable. Assuming no " << executable << ".";
videodec/libchromes/base/files/file_util_posix.cc:622:  DLOG(WARNING) << "OS_ANDROID: Home directory lookup not yet implemented.";
videodec/libchromes/base/files/file_util_posix.cc:677:    DPLOG(ERROR) << "mkdtemp";
videodec/libchromes/base/files/file_util_posix.cc:865:    VPLOG(1) << "Unable to create file " << filename.value();
videodec/libchromes/base/files/file_util_posix.cc:871:    VPLOG(1) << "Error while writing to file " << filename.value();
videodec/libchromes/base/files/file_util_posix.cc:876:    VPLOG(1) << "Error while closing file " << filename.value();
videodec/libchromes/base/files/file_util_posix.cc:906:     DLOG(ERROR) << "|base| must be a subdirectory of |path|.  base = \""
videodec/libchromes/base/files/file_util_posix.cc:958:      DPLOG(ERROR) << "Could not get the group ID of group \""
videodec/libchromes/base/files/scoped_temp_dir.cc:8:#include "base/logging.h"
videodec/libchromes/base/files/scoped_temp_dir.cc:23:    DLOG(WARNING) << "Could not delete temp dir in dtor.";
videodec/libchromes/base/files/file_path.h:63:// | const FilePath::CharType kLogFileName[] = FILE_PATH_LITERAL("log.txt");
videodec/libchromes/base/files/file_path.h:66:// |   FilePath log_file_path(kLogFileName);
videodec/libchromes/base/files/file_path.h:100://    http://blogs.msdn.com/oldnewthing/archive/2005/11/22/495740.aspx
videodec/libchromes/base/files/file_path.h:269:  // long "extensions" to logic like base::GetUniquePathNumber().
videodec/libchromes/base/files/file_path.h:434:  // On android, file selection dialog can return a file with content uri
videodec/libchromes/base/files/file_enumerator_posix.cc:13:#include "base/logging.h"
videodec/libchromes/base/files/file_enumerator_posix.cc:28:      DPLOG(ERROR) << "Couldn't stat" << path.value();
videodec/libchromes/base/files/scoped_file.cc:7:#include "base/logging.h"
videodec/libchromes/base/files/file_util.h:34:#include "base/logging.h"
videodec/libchromes/base/files/file_util.h:362:// This is a cross-platform analog to Windows' SetEndOfFile() function.
videodec/libchromes/base/files/scoped_file.h:13:#include "base/logging.h"
videodec/libchromes/base/files/file.cc:65:  // Go through the AssertIOAllowed logic.
videodec/libchromes/base/files/memory_mapped_file_posix.cc:14:#include "base/logging.h"
videodec/libchromes/base/files/memory_mapped_file_posix.cc:40:      DPLOG(ERROR) << "fstat " << file_.GetPlatformFile();
videodec/libchromes/base/files/memory_mapped_file_posix.cc:63:      DLOG(ERROR) << "Region bounds are not valid for mmap";
videodec/libchromes/base/files/memory_mapped_file_posix.cc:93:        DPLOG(ERROR) << "fstat " << file_.GetPlatformFile();
videodec/libchromes/base/files/memory_mapped_file_posix.cc:100:        DPLOG(ERROR) << "ftruncate " << file_.GetPlatformFile();
videodec/libchromes/base/files/memory_mapped_file_posix.cc:121:        DPLOG(ERROR) << "F_PREALLOCATE";
videodec/libchromes/base/files/memory_mapped_file_posix.cc:129:        DPLOG(ERROR) << "posix_fallocate";
videodec/libchromes/base/files/memory_mapped_file_posix.cc:165:    DPLOG(ERROR) << "mmap " << file_.GetPlatformFile();
videodec/libchromes/base/files/file_path_watcher_linux.cc:29:#include "base/logging.h"
videodec/libchromes/base/files/file_path_watcher_linux.cc:237:      DPLOG(WARNING) << "select failed";
videodec/libchromes/base/files/file_path_watcher_linux.cc:246:      DPLOG(WARNING) << "ioctl failed";
videodec/libchromes/base/files/file_path_watcher_linux.cc:256:      DPLOG(WARNING) << "read from inotify fd failed";
videodec/libchromes/base/files/file_path_watcher_linux.cc:276:    PLOG(ERROR) << "inotify_init() failed";
videodec/libchromes/base/files/file_path_watcher_linux.cc:656:    DPLOG(WARNING) << "Watch failed for "  << link.DirName().value();
videodec/libchromes/base/callback_internal.cc:7:#include "base/logging.h"
videodec/libchromes/base/base_switches.h:23:extern const char kNoErrorDialogs[];
videodec/libchromes/base/sys_info_posix.cc:17:#include "base/logging.h"
videodec/libchromes/base/sys_info_posix.cc:43:  // sysconf returns the number of "logical" (not "physical") processors on both
videodec/libchromes/base/sys_info_posix.cc:44:  // Mac and Linux.  So we get the number of max available "logical" processors.
videodec/libchromes/base/timer/timer.cc:11:#include "base/logging.h"
videodec/libchromes/base/synchronization/lock_impl.h:9:#include "base/logging.h"
videodec/libchromes/base/synchronization/lock.cc:7:// real intelligence in the class is in the debugging logic.
videodec/libchromes/base/synchronization/condition_variable.h:73:#include "base/logging.h"
videodec/libchromes/base/synchronization/atomic_flag.cc:7:#include "base/logging.h"
videodec/libchromes/base/synchronization/lock_impl_posix.cc:10:#include "base/logging.h"
videodec/libchromes/base/synchronization/waitable_event_watcher_posix.cc:10:#include "base/logging.h"
videodec/libchromes/base/synchronization/lock.h:9:#include "base/logging.h"
videodec/libchromes/base/synchronization/waitable_event_posix.cc:12:#include "base/logging.h"
videodec/libchromes/base/task/sequence_manager/sequence_manager_impl.cc:13:#include "base/debug/crash_logging.h"
videodec/libchromes/base/task/sequence_manager/sequence_manager.h:25:// implementation can be used in a various ways to apply scheduling logic.
videodec/libchromes/base/task/sequence_manager/sequence_manager.h:95:  // logic at the cost of a potentially worse latency. 1 by default.
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:5:#ifndef BASE_TASK_SEQUENCE_MANAGER_TASK_QUEUE_SELECTOR_LOGIC_H_
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:6:#define BASE_TASK_SEQUENCE_MANAGER_TASK_QUEUE_SELECTOR_LOGIC_H_
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:12:// Used to describe the logic trigerred when a task queue is selected to
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:15:enum class TaskQueueSelectorLogic {
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:18:  kControlPriorityLogic = 0,
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:19:  kHighestPriorityLogic = 1,
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:20:  kHighPriorityLogic = 2,
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:21:  kNormalPriorityLogic = 3,
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:22:  kLowPriorityLogic = 4,
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:23:  kBestEffortPriorityLogic = 5,
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:25:  // Selected due to starvation logic.
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:26:  kHighPriorityStarvationLogic = 6,
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:27:  kNormalPriorityStarvationLogic = 7,
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:28:  kLowPriorityStarvationLogic = 8,
videodec/libchromes/base/task/sequence_manager/task_queue_selector_logic.h:37:#endif  // BASE_TASK_SEQUENCE_MANAGER_TASK_QUEUE_SELECTOR_LOGIC_H_
videodec/libchromes/base/task/sequence_manager/time_domain.cc:66:      // O(log n)
videodec/libchromes/base/task/sequence_manager/time_domain.cc:70:      // O(log n)
videodec/libchromes/base/task/sequence_manager/task_queue_impl.cc:342:  // Activate delayed fence if necessary. This is ideologically similar to
videodec/libchromes/base/task/sequence_manager/work_queue_sets.h:12:#include "base/logging.h"
videodec/libchromes/base/task/sequence_manager/work_queue_sets.h:34:  // O(log num queues)
videodec/libchromes/base/task/sequence_manager/work_queue_sets.h:37:  // O(log num queues)
videodec/libchromes/base/task/sequence_manager/work_queue_sets.h:40:  // O(log num queues)
videodec/libchromes/base/task/sequence_manager/work_queue_sets.h:43:  // O(log num queues)
videodec/libchromes/base/task/sequence_manager/work_queue_sets.h:46:  // O(log num queues)
videodec/libchromes/base/task/sequence_manager/work_queue_sets.h:49:  // If empty it's O(1) amortized, otherwise it's O(log num queues)
videodec/libchromes/base/task/sequence_manager/work_queue_sets.h:53:  // O(log num queues)
videodec/libchromes/base/task/sequence_manager/intrusive_heap.h:11:#include "base/logging.h"
videodec/libchromes/base/task/sequence_manager/work_queue_sets.cc:7:#include "base/logging.h"
videodec/libchromes/base/task/sequence_manager/work_queue_sets.cc:91:    // O(log n)
videodec/libchromes/base/task/sequence_manager/work_queue_sets.cc:94:    // O(log n)
videodec/libchromes/base/task/sequence_manager/lazily_deallocated_deque.h:14:#include "base/logging.h"
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:7:#include "base/logging.h"
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:19:TaskQueueSelectorLogic QueuePriorityToSelectorLogic(
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:23:      return TaskQueueSelectorLogic::kControlPriorityLogic;
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:25:      return TaskQueueSelectorLogic::kHighestPriorityLogic;
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:27:      return TaskQueueSelectorLogic::kHighPriorityLogic;
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:29:      return TaskQueueSelectorLogic::kNormalPriorityLogic;
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:31:      return TaskQueueSelectorLogic::kLowPriorityLogic;
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:33:      return TaskQueueSelectorLogic::kBestEffortPriorityLogic;
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:36:      return TaskQueueSelectorLogic::kCount;
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:40:// Helper function used to report the number of times a selector logic is
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:42:void ReportTaskSelectionLogic(TaskQueueSelectorLogic selector_logic) {
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:43:  UMA_HISTOGRAM_ENUMERATION("TaskQueueSelector.TaskServicedPerSelectorLogic",
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:44:                            selector_logic, TaskQueueSelectorLogic::kCount);
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:223:    ReportTaskSelectionLogic(TaskQueueSelectorLogic::kControlPriorityLogic);
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:234:    ReportTaskSelectionLogic(
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:235:        TaskQueueSelectorLogic::kLowPriorityStarvationLogic);
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:246:    ReportTaskSelectionLogic(
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:247:        TaskQueueSelectorLogic::kNormalPriorityStarvationLogic);
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:258:    ReportTaskSelectionLogic(
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:259:        TaskQueueSelectorLogic::kHighPriorityStarvationLogic);
videodec/libchromes/base/task/sequence_manager/task_queue_selector.cc:268:      ReportTaskSelectionLogic(QueuePriorityToSelectorLogic(priority));
videodec/libchromes/base/task/sequence_manager/task_queue_selector.h:13:#include "base/task/sequence_manager/task_queue_selector_logic.h"
videodec/libchromes/base/task/sequence_manager/time_domain.h:11:#include "base/logging.h"
videodec/libchromes/base/task/sequence_manager/task_queue_impl.h:266:  // TODO(kraynov): Simplify non-nestable task logic https://crbug.com/845437.
videodec/libchromes/base/macros.h:62:// http://blogs.msdn.com/b/the1/archive/2004/05/07/128242.aspx.
videodec/libchromes/base/hash.h:16:#include "base/logging.h"
videodec/libchromes/base/process/process_metrics.h:164:  // logic that can include (depending on system specifics) shared last level
videodec/libchromes/base/process/process_metrics.h:167:  // logic in addition to each individual processor's logic, as well as take
videodec/libchromes/base/process/process_info_linux.cc:9:#include "base/logging.h"
videodec/libchromes/base/process/process_metrics.cc:9:#include "base/logging.h"
videodec/libchromes/base/process/kill_posix.cc:15:#include "base/logging.h"
videodec/libchromes/base/process/kill_posix.cc:36:    DPLOG(ERROR) << "waitpid(" << handle << ")";
videodec/libchromes/base/process/kill_posix.cc:83:    DPLOG(ERROR) << "Unable to terminate process group " << process_group_id;
videodec/libchromes/base/process/kill_posix.cc:97:    DPLOG(ERROR) << "Unable to terminate process " << handle;
videodec/libchromes/base/process/launch_posix.cc:35:#include "base/logging.h"
videodec/libchromes/base/process/launch_posix.cc:188:      RAW_LOG(FATAL, "sigaction (get) failed.");
videodec/libchromes/base/process/launch_posix.cc:196:        RAW_LOG(FATAL, "sigaction (set) failed.");
videodec/libchromes/base/process/launch_posix.cc:202:      RAW_LOG(FATAL, "Cound not fix sa_restorer.");
videodec/libchromes/base/process/launch_posix.cc:377:    DPLOG(ERROR) << "fork";
videodec/libchromes/base/process/launch_posix.cc:396:      RAW_LOG(ERROR, "Failed to open /dev/null");
videodec/libchromes/base/process/launch_posix.cc:402:      RAW_LOG(ERROR, "Failed to dup /dev/null for stdin");
videodec/libchromes/base/process/launch_posix.cc:410:        RAW_LOG(ERROR, "setpgid failed");
videodec/libchromes/base/process/launch_posix.cc:421:          RAW_LOG(WARNING, "getrlimit failed");
videodec/libchromes/base/process/launch_posix.cc:425:            RAW_LOG(WARNING, "setrlimit failed");
videodec/libchromes/base/process/launch_posix.cc:453:          RAW_LOG(WARNING, "ioctl(TIOCSCTTY), ctrl terminal not set");
videodec/libchromes/base/process/launch_posix.cc:456:        RAW_LOG(WARNING, "setsid failed, ctrl terminal not set");
videodec/libchromes/base/process/launch_posix.cc:486:        // Only log if the error is not EINVAL (i.e. not supported).
videodec/libchromes/base/process/launch_posix.cc:487:        RAW_LOG(FATAL, "prctl(PR_SET_NO_NEW_PRIVS) failed");
videodec/libchromes/base/process/launch_posix.cc:493:        RAW_LOG(ERROR, "prctl(PR_SET_PDEATHSIG) failed");
videodec/libchromes/base/process/launch_posix.cc:512:    RAW_LOG(ERROR, "LaunchProcess: failed to execvp:");
videodec/libchromes/base/process/launch_posix.cc:513:    RAW_LOG(ERROR, argv_cstr[0]);
videodec/libchromes/base/process/launch_posix.cc:752:    RAW_LOG(FATAL, "Invalid usage of ForkWithFlags");
videodec/libchromes/base/process/internal_linux.cc:15:#include "base/logging.h"
videodec/libchromes/base/process/internal_linux.cc:64:    DLOG(WARNING) << "Failed to read " << file.MaybeAsASCII();
videodec/libchromes/base/process/internal_linux.cc:91:    DLOG(WARNING) << "Failed to find matched parens in '" << stats_data << "'";
videodec/libchromes/base/process/memory.cc:6:#include "base/logging.h"
videodec/libchromes/base/process/memory.cc:22:  LOG(FATAL) << "Out of memory. size=" << tmp_size;
videodec/libchromes/base/process/process_handle.cc:7:#include "base/logging.h"
videodec/libchromes/base/process/process_posix.cc:15:#include "base/logging.h"
videodec/libchromes/base/process/process_posix.cc:101:    DPLOG(ERROR) << "kqueue";
videodec/libchromes/base/process/process_posix.cc:114:    DPLOG(ERROR) << "kevent (setup " << handle << ")";
videodec/libchromes/base/process/process_posix.cc:154:    DPLOG(ERROR) << "kevent (wait " << handle << ")";
videodec/libchromes/base/process/process_posix.cc:157:    DLOG(ERROR) << "kevent (wait " << handle << "): unexpected result "
videodec/libchromes/base/process/process_posix.cc:170:    DLOG(ERROR) << "kevent (wait " << handle
videodec/libchromes/base/process/process_posix.cc:325:    DPLOG(ERROR) << "Unable to terminate process " << process_;
videodec/libchromes/base/process/internal_aix.cc:19:#include "base/logging.h"
videodec/libchromes/base/process/internal_aix.cc:65:    DLOG(WARNING) << "Failed to open " << file.MaybeAsASCII()
videodec/libchromes/base/process/internal_aix.cc:71:    DLOG(WARNING) << "Failed to read " << file.MaybeAsASCII()
videodec/libchromes/base/process/process_metrics_linux.cc:19:#include "base/logging.h"
videodec/libchromes/base/process/process_metrics_linux.cc:454://      I/O completion time and the backlog that may be accumulating.
videodec/libchromes/base/process/process_metrics_linux.cc:519:      DLOG(WARNING) << "meminfo: tokens: " << tokens.size()
videodec/libchromes/base/process/process_metrics_linux.cc:620:    DLOG(WARNING) << "Failed to open " << meminfo_file.value();
videodec/libchromes/base/process/process_metrics_linux.cc:625:    DLOG(WARNING) << "Failed to parse " << meminfo_file.value();
videodec/libchromes/base/process/process_metrics_linux.cc:651:    DLOG(WARNING) << "Failed to open " << vmstat_file.value();
videodec/libchromes/base/process/process_metrics_linux.cc:655:    DLOG(WARNING) << "Failed to parse " << vmstat_file.value();
videodec/libchromes/base/process/process_metrics_linux.cc:730:    DLOG(WARNING) << "Failed to open " << diskinfo_file.value();
videodec/libchromes/base/process/process_metrics_linux.cc:737:    DLOG(WARNING) << "No lines found";
videodec/libchromes/base/process/process_metrics_linux.cc:837:    DLOG(WARNING) << "zram mm_stat: tokens: " << tokens.size()
videodec/libchromes/base/process/process_metrics_linux.cc:865:    DLOG(WARNING) << "zram stat: tokens: " << tokens.size()
videodec/libchromes/base/process/process_metrics_linux.cc:930:    DLOG(WARNING) << "Failed to open " << zram_mm_stat_file.value();
videodec/libchromes/base/process/process_metrics_linux.cc:934:    DLOG(WARNING) << "Failed to parse " << zram_mm_stat_file.value();
videodec/libchromes/base/process/process_metrics_linux.cc:943:    DLOG(WARNING) << "Failed to open " << zram_stat_file.value();
videodec/libchromes/base/process/process_metrics_linux.cc:947:    DLOG(WARNING) << "Failed to parse " << zram_stat_file.value();
videodec/libchromes/base/process/process_metrics_posix.cc:13:#include "base/logging.h"
videodec/libchromes/base/process/process_metrics_posix.cc:63:    RAW_LOG(ERROR, "getrlimit(RLIMIT_NOFILE) failed");
videodec/libchromes/base/process/process_metrics_posix.cc:85:      PLOG(INFO) << "Failed to set file descriptor limit";
videodec/libchromes/base/process/process_metrics_posix.cc:88:    PLOG(INFO) << "Failed to get file descriptor limit";
videodec/libchromes/base/process/memory_linux.cc:15:#include "base/logging.h"
videodec/libchromes/base/process/memory_linux.cc:39:    LOG(FATAL) << "Out of memory, size = " << size;
videodec/libchromes/base/process/memory_linux.cc:40:  LOG(FATAL) << "Out of memory.";
videodec/libchromes/base/process/memory_linux.cc:80:    DVLOG(1) << "Adjusting oom_score_adj of " << process << " to "
videodec/libchromes/base/process/memory_linux.cc:96:    DVLOG(1) << "Adjusting oom_adj of " << process << " to " << score_str;
videodec/libchromes/base/process/process_iterator_linux.cc:10:#include "base/logging.h"
videodec/libchromes/base/process/process_iterator_linux.cc:67:    PLOG(ERROR) << "opendir " << internal::kProcDir;
videodec/libchromes/base/process/process_iterator_linux.cc:82:    DLOG(ERROR) << "Skipping CheckForNextProcess(), no procfs_dir_";
videodec/libchromes/base/process/launch.h:91:  // See https://blogs.msdn.microsoft.com/oldnewthing/20111216-00/?p=8873
videodec/libchromes/base/process/launch.h:122:  // the token belonging to an interactive logon session.
videodec/libchromes/base/lazy_instance_helpers.h:10:#include "base/logging.h"
videodec/libchromes/base/sampling_heap_profiler/benchmark-octane.js:43:  console.log(scores.join('\t'));
videodec/libchromes/base/sampling_heap_profiler/benchmark-octane.js:47:  console.log(`Using ${process.env.CHROME_PATH || puppeteer.executablePath()}`);
videodec/libchromes/base/sampling_heap_profiler/benchmark-octane.js:51:  console.log('Rates [KB]:');
videodec/libchromes/base/sampling_heap_profiler/benchmark-octane.js:52:  console.log(rates.join('\t'));
videodec/libchromes/base/sampling_heap_profiler/benchmark-octane.js:53:  console.log('='.repeat(rates.length * 8));
videodec/libchromes/base/sampling_heap_profiler/lock_free_address_hash_set.h:12:#include "base/logging.h"
videodec/libchromes/base/sampling_heap_profiler/sampling_heap_profiler.cc:209:  DLOG(WARNING)
videodec/libchromes/base/sampling_heap_profiler/sampling_heap_profiler.cc:243:    LOG(WARNING) << "Sampling heap profiler: Stack unwinding is not available.";
videodec/libchromes/base/sampling_heap_profiler/sampling_heap_profiler.cc:275:  double value = -log(uniform) * interval;
videodec/libchromes/base/logging.h:5:#ifndef BASE_LOGGING_H_
videodec/libchromes/base/logging.h:6:#define BASE_LOGGING_H_
videodec/libchromes/base/logging.h:29:// Assertion failed messages and fatal errors are displayed in a dialog box
videodec/libchromes/base/logging.h:33:// bad state when this assertion dialog is displayed, these messages may not
videodec/libchromes/base/logging.h:34:// get processed and hang the dialog, or the application might go crazy.
videodec/libchromes/base/logging.h:36:// Therefore, it can be beneficial to display the error dialog in a separate
videodec/libchromes/base/logging.h:37:// process from the main application. When the logging system needs to display
videodec/libchromes/base/logging.h:38:// a fatal error dialog box, it will look for a program called
videodec/libchromes/base/logging.h:47:// If DebugMessage.exe is not found, the logging code will use a normal
videodec/libchromes/base/logging.h:54:// Make a bunch of macros for logging.  The way to log things is to stream
videodec/libchromes/base/logging.h:55:// things to LOG(<a particular severity level>).  E.g.,
videodec/libchromes/base/logging.h:57://   LOG(INFO) << "Found " << num_cookies << " cookies";
videodec/libchromes/base/logging.h:59:// You can also do conditional logging:
videodec/libchromes/base/logging.h:61://   LOG_IF(INFO, num_cookies > 10) << "Got lots of cookies";
videodec/libchromes/base/logging.h:64:// effectively performs a LOG(FATAL) which terminates the process and
videodec/libchromes/base/logging.h:67:// There are also "debug mode" logging macros like the ones above:
videodec/libchromes/base/logging.h:69://   DLOG(INFO) << "Found cookies";
videodec/libchromes/base/logging.h:71://   DLOG_IF(INFO, num_cookies > 10) << "Got lots of cookies";
videodec/libchromes/base/logging.h:73:// All "debug mode" logging is compiled away to nothing for non-debug mode
videodec/libchromes/base/logging.h:74:// compiles.  LOG_IF and development flags also work well together
videodec/libchromes/base/logging.h:79://   LOG_ASSERT(assertion);
videodec/libchromes/base/logging.h:80://   DLOG_ASSERT(assertion);
videodec/libchromes/base/logging.h:82:// which is syntactic sugar for {,D}LOG_IF(FATAL, assert fails) << assertion;
videodec/libchromes/base/logging.h:84:// There are "verbose level" logging macros.  They look like
videodec/libchromes/base/logging.h:86://   VLOG(1) << "I'm printed when you run the program with --v=1 or more";
videodec/libchromes/base/logging.h:87://   VLOG(2) << "I'm printed when you run the program with --v=2 or more";
videodec/libchromes/base/logging.h:89:// These always log at the INFO log level (when they log at all).
videodec/libchromes/base/logging.h:90:// The verbose logging can also be turned on module-by-module.  For instance,
videodec/libchromes/base/logging.h:93://   a. VLOG(2) and lower messages to be printed from profile.{h,cc}
videodec/libchromes/base/logging.h:94://   b. VLOG(1) and lower messages to be printed from icon_loader.{h,cc}
videodec/libchromes/base/logging.h:95://   c. VLOG(3) and lower messages to be printed from files prefixed with
videodec/libchromes/base/logging.h:97://   d. VLOG(4) and lower messages to be printed from files under a
videodec/libchromes/base/logging.h:99://   e. VLOG(0) and lower messages to be printed from elsewhere
videodec/libchromes/base/logging.h:105:// E.g., "*/foo/bar/*=2" would change the logging level for all code
videodec/libchromes/base/logging.h:108:// There's also VLOG_IS_ON(n) "verbose level" condition macro. To be used as
videodec/libchromes/base/logging.h:110://   if (VLOG_IS_ON(2)) {
videodec/libchromes/base/logging.h:111://     // do some logging preparation and logging
videodec/libchromes/base/logging.h:112://     // that can't be accomplished with just VLOG(2) << ...;
videodec/libchromes/base/logging.h:115:// There is also a VLOG_IF "verbose level" condition macro for sample
videodec/libchromes/base/logging.h:116:// cases, when some extra computation and preparation for logs is not
videodec/libchromes/base/logging.h:119://   VLOG_IF(1, (size > 1024))
videodec/libchromes/base/logging.h:123:// We also override the standard 'assert' to use 'DLOG_ASSERT'.
videodec/libchromes/base/logging.h:127://   PLOG(ERROR) << "Couldn't do foo";
videodec/libchromes/base/logging.h:128://   DPLOG(ERROR) << "Couldn't do foo";
videodec/libchromes/base/logging.h:129://   PLOG_IF(ERROR, cond) << "Couldn't do foo";
videodec/libchromes/base/logging.h:130://   DPLOG_IF(ERROR, cond) << "Couldn't do foo";
videodec/libchromes/base/logging.h:140:// Very important: logging a message at the FATAL severity level causes
videodec/libchromes/base/logging.h:141:// the program to terminate (after the message is logged).
videodec/libchromes/base/logging.h:143:// There is the special severity of DFATAL, which logs FATAL in debug mode,
videodec/libchromes/base/logging.h:146:namespace VDLogGing {
videodec/libchromes/base/logging.h:155:// Where to record logging output? A flat file and/or system debug log
videodec/libchromes/base/logging.h:157:enum LoggingDestination {
videodec/libchromes/base/logging.h:158:  LOG_NONE                = 0,
videodec/libchromes/base/logging.h:159:  LOG_TO_FILE             = 1 << 0,
videodec/libchromes/base/logging.h:160:  LOG_TO_SYSTEM_DEBUG_LOG = 1 << 1,
videodec/libchromes/base/logging.h:162:  LOG_TO_ALL = LOG_TO_FILE | LOG_TO_SYSTEM_DEBUG_LOG,
videodec/libchromes/base/logging.h:168:  LOG_DEFAULT = LOG_TO_FILE,
videodec/libchromes/base/logging.h:170:  LOG_DEFAULT = LOG_TO_SYSTEM_DEBUG_LOG,
videodec/libchromes/base/logging.h:174:// Indicates that the log file should be locked when being written to.
videodec/libchromes/base/logging.h:175:// Unless there is only one single-threaded process that is logging to
videodec/libchromes/base/logging.h:176:// the log file, the file should be locked during writes to make each
videodec/libchromes/base/logging.h:177:// log output atomic. Other writers will block.
videodec/libchromes/base/logging.h:179:// All processes writing to the log file must have their locking set for it to
videodec/libchromes/base/logging.h:180:// work properly. Defaults to LOCK_LOG_FILE.
videodec/libchromes/base/logging.h:181:enum LogLockingState { LOCK_LOG_FILE, DONT_LOCK_LOG_FILE };
videodec/libchromes/base/logging.h:183:// On startup, should we delete or append to an existing log file (if any)?
videodec/libchromes/base/logging.h:184:// Defaults to APPEND_TO_OLD_LOG_FILE.
videodec/libchromes/base/logging.h:185:enum OldFileDeletionState { DELETE_OLD_LOG_FILE, APPEND_TO_OLD_LOG_FILE };
videodec/libchromes/base/logging.h:187:struct BASE_EXPORT LoggingSettings {
videodec/libchromes/base/logging.h:190:  //  logging_dest: LOG_DEFAULT
videodec/libchromes/base/logging.h:191:  //  log_file:     NULL
videodec/libchromes/base/logging.h:192:  //  lock_log:     LOCK_LOG_FILE
videodec/libchromes/base/logging.h:193:  //  delete_old:   APPEND_TO_OLD_LOG_FILE
videodec/libchromes/base/logging.h:194:  LoggingSettings();
videodec/libchromes/base/logging.h:196:  LoggingDestination logging_dest;
videodec/libchromes/base/logging.h:198:  // The three settings below have an effect only when LOG_TO_FILE is
videodec/libchromes/base/logging.h:199:  // set in |logging_dest|.
videodec/libchromes/base/logging.h:200:  const PathChar* log_file;
videodec/libchromes/base/logging.h:201:  LogLockingState lock_log;
videodec/libchromes/base/logging.h:205:// Define different names for the BaseInitLoggingImpl() function depending on
videodec/libchromes/base/logging.h:207:// to compile logging.cc with NDEBUG but includes logging.h without defining it,
videodec/libchromes/base/logging.h:210:#define BaseInitLoggingImpl BaseInitLoggingImpl_built_with_NDEBUG
videodec/libchromes/base/logging.h:212:#define BaseInitLoggingImpl BaseInitLoggingImpl_built_without_NDEBUG
videodec/libchromes/base/logging.h:215:// Implementation of the InitLogging() method declared below.  We use a
videodec/libchromes/base/logging.h:217:// that has named stuff "InitLogging".
videodec/libchromes/base/logging.h:218:BASE_EXPORT bool BaseInitLoggingImpl(const LoggingSettings& settings);
videodec/libchromes/base/logging.h:220:// Sets the log file name and other global logging state. Calling this function
videodec/libchromes/base/logging.h:224:// object if two threads try to do the first log at the same time.
videodec/libchromes/base/logging.h:227:// The default log file is initialized to "debug.log" in the application
videodec/libchromes/base/logging.h:231:// This function may be called a second time to re-direct logging (e.g after
videodec/libchromes/base/logging.h:232:// loging in to a user partition), however it should never be called more than
videodec/libchromes/base/logging.h:234:inline bool InitLogging(const LoggingSettings& settings) {
videodec/libchromes/base/logging.h:235:  return BaseInitLoggingImpl(settings);
videodec/libchromes/base/logging.h:238:// Sets the log level. Anything at or above this level will be written to the
videodec/libchromes/base/logging.h:239:// log file/displayed to the user (if applicable). Anything below this level
videodec/libchromes/base/logging.h:240:// will be silently ignored. The log level defaults to 0 (everything is logged
videodec/libchromes/base/logging.h:242:// Note that log messages for VLOG(x) are logged at level -x, so setting
videodec/libchromes/base/logging.h:243:// the min log level to negative values enables verbose logging.
videodec/libchromes/base/logging.h:244:BASE_EXPORT void SetMinLogLevel(int level);
videodec/libchromes/base/logging.h:246:// Gets the current log level.
videodec/libchromes/base/logging.h:247:BASE_EXPORT int GetMinLogLevel();
videodec/libchromes/base/logging.h:249:// Used by LOG_IS_ON to lazy-evaluate stream arguments.
videodec/libchromes/base/logging.h:250:BASE_EXPORT bool ShouldCreateLogMessage(int severity);
videodec/libchromes/base/logging.h:252:// Gets the VLOG default verbosity level.
videodec/libchromes/base/logging.h:253:BASE_EXPORT int GetVlogVerbosity();
videodec/libchromes/base/logging.h:256:BASE_EXPORT int GetVlogLevelHelper(const char* file_start, size_t N);
videodec/libchromes/base/logging.h:258:// Gets the current vlog level for the given file (usually taken from __FILE__).
videodec/libchromes/base/logging.h:260:int GetVlogLevel(const char (&file)[N]) {
videodec/libchromes/base/logging.h:261:  return GetVlogLevelHelper(file, N);
videodec/libchromes/base/logging.h:264:// Sets the common items you want to be prepended to each log message.
videodec/libchromes/base/logging.h:266:// If this function is not called, logging defaults to writing the timestamp
videodec/libchromes/base/logging.h:268:BASE_EXPORT void SetLogItems(bool enable_process_id, bool enable_thread_id,
videodec/libchromes/base/logging.h:272:// a dialog box or not.
videodec/libchromes/base/logging.h:273:// Dialogs are not shown by default.
videodec/libchromes/base/logging.h:274:BASE_EXPORT void SetShowErrorDialogs(bool enable_dialogs);
videodec/libchromes/base/logging.h:276:// Sets the Log Assert Handler that will be used to notify of check failures.
videodec/libchromes/base/logging.h:277:// Resets Log Assert Handler on object destruction.
videodec/libchromes/base/logging.h:278:// The default handler shows a dialog box and then terminate the process,
videodec/libchromes/base/logging.h:281:using LogAssertHandlerFunction =
videodec/libchromes/base/logging.h:287:class BASE_EXPORT ScopedLogAssertHandler {
videodec/libchromes/base/logging.h:289:  explicit ScopedLogAssertHandler(LogAssertHandlerFunction handler);
videodec/libchromes/base/logging.h:290:  ~ScopedLogAssertHandler();
videodec/libchromes/base/logging.h:293:  DISALLOW_COPY_AND_ASSIGN(ScopedLogAssertHandler);
videodec/libchromes/base/logging.h:296:// Sets the Log Message Handler that gets passed every log message before
videodec/libchromes/base/logging.h:297:// it's sent to other log destinations (if any).
videodec/libchromes/base/logging.h:299:// should not be sent to other log destinations.
videodec/libchromes/base/logging.h:300:typedef bool (*LogMessageHandlerFunction)(int severity,
videodec/libchromes/base/logging.h:302:BASE_EXPORT void SetLogMessageHandler(LogMessageHandlerFunction handler);
videodec/libchromes/base/logging.h:303:BASE_EXPORT LogMessageHandlerFunction GetLogMessageHandler();
videodec/libchromes/base/logging.h:324:#define ANALYZER_ASSUME_TRUE(arg) VDLogGing::AnalyzerAssumeTrue(!!(arg))
videodec/libchromes/base/logging.h:326:  static_cast<void>(::VDLogGing::AnalyzerNoReturn())
videodec/libchromes/base/logging.h:337:typedef int LogSeverity;
videodec/libchromes/base/logging.h:338:const LogSeverity LOG_VERBOSE = -1;  // This is level 1 verbosity
videodec/libchromes/base/logging.h:339:// Note: the log severities are used to index into the array of names,
videodec/libchromes/base/logging.h:340:// see log_severity_names.
videodec/libchromes/base/logging.h:341:const LogSeverity LOG_INFO = 0;
videodec/libchromes/base/logging.h:342:const LogSeverity LOG_WARNING = 1;
videodec/libchromes/base/logging.h:343:const LogSeverity LOG_ERROR = 2;
videodec/libchromes/base/logging.h:344:const LogSeverity LOG_FATAL = 3;
videodec/libchromes/base/logging.h:345:const LogSeverity LOG_NUM_SEVERITIES = 4;
videodec/libchromes/base/logging.h:347:// LOG_DFATAL is LOG_FATAL in debug mode, ERROR in normal mode
videodec/libchromes/base/logging.h:349:const LogSeverity LOG_DFATAL = LOG_ERROR;
videodec/libchromes/base/logging.h:351:const LogSeverity LOG_DFATAL = LOG_FATAL;
videodec/libchromes/base/logging.h:355:// by LOG() and LOG_IF, etc. Since these are used all over our code, it's
videodec/libchromes/base/logging.h:357:#define COMPACT_GOOGLE_LOG_EX_INFO(ClassName, ...) \
videodec/libchromes/base/logging.h:358:  ::VDLogGing::ClassName(__FILE__, __LINE__, ::VDLogGing::LOG_INFO, ##__VA_ARGS__)
videodec/libchromes/base/logging.h:359:#define COMPACT_GOOGLE_LOG_EX_WARNING(ClassName, ...)              \
videodec/libchromes/base/logging.h:360:  ::VDLogGing::ClassName(__FILE__, __LINE__, ::VDLogGing::LOG_WARNING, \
videodec/libchromes/base/logging.h:362:#define COMPACT_GOOGLE_LOG_EX_ERROR(ClassName, ...) \
videodec/libchromes/base/logging.h:363:  ::VDLogGing::ClassName(__FILE__, __LINE__, ::VDLogGing::LOG_ERROR, ##__VA_ARGS__)
videodec/libchromes/base/logging.h:364:#define COMPACT_GOOGLE_LOG_EX_FATAL(ClassName, ...) \
videodec/libchromes/base/logging.h:365:  ::VDLogGing::ClassName(__FILE__, __LINE__, ::VDLogGing::LOG_FATAL, ##__VA_ARGS__)
videodec/libchromes/base/logging.h:366:#define COMPACT_GOOGLE_LOG_EX_DFATAL(ClassName, ...) \
videodec/libchromes/base/logging.h:367:  ::VDLogGing::ClassName(__FILE__, __LINE__, ::VDLogGing::LOG_DFATAL, ##__VA_ARGS__)
videodec/libchromes/base/logging.h:368:#define COMPACT_GOOGLE_LOG_EX_DCHECK(ClassName, ...) \
videodec/libchromes/base/logging.h:369:  ::VDLogGing::ClassName(__FILE__, __LINE__, ::VDLogGing::LOG_DCHECK, ##__VA_ARGS__)
videodec/libchromes/base/logging.h:371:#define COMPACT_GOOGLE_LOG_INFO COMPACT_GOOGLE_LOG_EX_INFO(LogMessage)
videodec/libchromes/base/logging.h:372:#define COMPACT_GOOGLE_LOG_WARNING COMPACT_GOOGLE_LOG_EX_WARNING(LogMessage)
videodec/libchromes/base/logging.h:373:#define COMPACT_GOOGLE_LOG_ERROR COMPACT_GOOGLE_LOG_EX_ERROR(LogMessage)
videodec/libchromes/base/logging.h:374:#define COMPACT_GOOGLE_LOG_FATAL COMPACT_GOOGLE_LOG_EX_FATAL(LogMessage)
videodec/libchromes/base/logging.h:375:#define COMPACT_GOOGLE_LOG_DFATAL COMPACT_GOOGLE_LOG_EX_DFATAL(LogMessage)
videodec/libchromes/base/logging.h:376:#define COMPACT_GOOGLE_LOG_DCHECK COMPACT_GOOGLE_LOG_EX_DCHECK(LogMessage)
videodec/libchromes/base/logging.h:379:// wingdi.h defines ERROR to be 0. When we call LOG(ERROR), it gets
videodec/libchromes/base/logging.h:380:// substituted with 0, and it expands to COMPACT_GOOGLE_LOG_0. To allow us
videodec/libchromes/base/logging.h:382:// as COMPACT_GOOGLE_LOG_ERROR, and also define ERROR the same way that
videodec/libchromes/base/logging.h:385:#define COMPACT_GOOGLE_LOG_EX_0(ClassName, ...) \
videodec/libchromes/base/logging.h:386:  COMPACT_GOOGLE_LOG_EX_ERROR(ClassName , ##__VA_ARGS__)
videodec/libchromes/base/logging.h:387:#define COMPACT_GOOGLE_LOG_0 COMPACT_GOOGLE_LOG_ERROR
videodec/libchromes/base/logging.h:388:// Needed for LOG_IS_ON(ERROR).
videodec/libchromes/base/logging.h:389:const LogSeverity LOG_0 = LOG_ERROR;
videodec/libchromes/base/logging.h:392:// As special cases, we can assume that LOG_IS_ON(FATAL) always holds. Also,
videodec/libchromes/base/logging.h:393:// LOG_IS_ON(DFATAL) always holds in debug mode. In particular, CHECK()s will
videodec/libchromes/base/logging.h:395:#define LOG_IS_ON(severity) \
videodec/libchromes/base/logging.h:396:  (::VDLogGing::ShouldCreateLogMessage(::VDLogGing::LOG_##severity))
videodec/libchromes/base/logging.h:398:// We can't do any caching tricks with VLOG_IS_ON() like the
videodec/libchromes/base/logging.h:399:// google-glog version since it requires GCC extensions.  This means
videodec/libchromes/base/logging.h:400:// that using the v-logging functions in conjunction with --vmodule
videodec/libchromes/base/logging.h:402:#define VLOG_IS_ON(verboselevel) \
videodec/libchromes/base/logging.h:403:  ((verboselevel) <= ::VDLogGing::GetVlogLevel(__FILE__))
videodec/libchromes/base/logging.h:408:  !(condition) ? (void) 0 : ::VDLogGing::LogMessageVoidify() & (stream)
videodec/libchromes/base/logging.h:411:// LOG(INFO) becomes the token COMPACT_GOOGLE_LOG_INFO.  There's some funny
videodec/libchromes/base/logging.h:417:// function of LogMessage which seems to avoid the problem.
videodec/libchromes/base/logging.h:418:#define LOG_STREAM(severity) COMPACT_GOOGLE_LOG_ ## severity.stream()
videodec/libchromes/base/logging.h:420:#define LOG(severity) LAZY_STREAM(LOG_STREAM(severity), LOG_IS_ON(severity))
videodec/libchromes/base/logging.h:421:#define LOG_IF(severity, condition) \
videodec/libchromes/base/logging.h:422:  LAZY_STREAM(LOG_STREAM(severity), LOG_IS_ON(severity) && (condition))
videodec/libchromes/base/logging.h:424:// The VLOG macros log with negative verbosities.
videodec/libchromes/base/logging.h:425:#define VLOG_STREAM(verbose_level) \
videodec/libchromes/base/logging.h:426:  ::VDLogGing::LogMessage(__FILE__, __LINE__, -verbose_level).stream()
videodec/libchromes/base/logging.h:428:#define VLOG(verbose_level) \
videodec/libchromes/base/logging.h:429:  LAZY_STREAM(VLOG_STREAM(verbose_level), VLOG_IS_ON(verbose_level))
videodec/libchromes/base/logging.h:431:#define VLOG_IF(verbose_level, condition) \
videodec/libchromes/base/logging.h:432:  LAZY_STREAM(VLOG_STREAM(verbose_level), \
videodec/libchromes/base/logging.h:433:      VLOG_IS_ON(verbose_level) && (condition))
videodec/libchromes/base/logging.h:436:#define VPLOG_STREAM(verbose_level) \
videodec/libchromes/base/logging.h:437:  ::VDLogGing::Win32ErrorLogMessage(__FILE__, __LINE__, -verbose_level, \
videodec/libchromes/base/logging.h:438:    ::VDLogGing::GetLastSystemErrorCode()).stream()
videodec/libchromes/base/logging.h:440:#define VPLOG_STREAM(verbose_level) \
videodec/libchromes/base/logging.h:441:  ::VDLogGing::ErrnoLogMessage(__FILE__, __LINE__, -verbose_level, \
videodec/libchromes/base/logging.h:442:    ::VDLogGing::GetLastSystemErrorCode()).stream()
videodec/libchromes/base/logging.h:445:#define VPLOG(verbose_level) \
videodec/libchromes/base/logging.h:446:  LAZY_STREAM(VPLOG_STREAM(verbose_level), VLOG_IS_ON(verbose_level))
videodec/libchromes/base/logging.h:448:#define VPLOG_IF(verbose_level, condition) \
videodec/libchromes/base/logging.h:449:  LAZY_STREAM(VPLOG_STREAM(verbose_level), \
videodec/libchromes/base/logging.h:450:    VLOG_IS_ON(verbose_level) && (condition))
videodec/libchromes/base/logging.h:452:// TODO(akalin): Add more VLOG variants, e.g. VPLOG.
videodec/libchromes/base/logging.h:454:#define LOG_ASSERT(condition)                       \
videodec/libchromes/base/logging.h:455:  LOG_IF(FATAL, !(ANALYZER_ASSUME_TRUE(condition))) \
videodec/libchromes/base/logging.h:459:#define PLOG_STREAM(severity) \
videodec/libchromes/base/logging.h:460:  COMPACT_GOOGLE_LOG_EX_ ## severity(Win32ErrorLogMessage, \
videodec/libchromes/base/logging.h:461:      ::VDLogGing::GetLastSystemErrorCode()).stream()
videodec/libchromes/base/logging.h:463:#define PLOG_STREAM(severity) \
videodec/libchromes/base/logging.h:464:  COMPACT_GOOGLE_LOG_EX_ ## severity(ErrnoLogMessage, \
videodec/libchromes/base/logging.h:465:      ::VDLogGing::GetLastSystemErrorCode()).stream()
videodec/libchromes/base/logging.h:468:#define PLOG(severity)                                          \
videodec/libchromes/base/logging.h:469:  LAZY_STREAM(PLOG_STREAM(severity), LOG_IS_ON(severity))
videodec/libchromes/base/logging.h:471:#define PLOG_IF(severity, condition) \
videodec/libchromes/base/logging.h:472:  LAZY_STREAM(PLOG_STREAM(severity), LOG_IS_ON(severity) && (condition))
videodec/libchromes/base/logging.h:476:// Note that g_swallow_stream is used instead of an arbitrary LOG() stream to
videodec/libchromes/base/logging.h:477:// avoid the creation of an object with a non-trivial destructor (LogMessage).
videodec/libchromes/base/logging.h:490:       : ::VDLogGing::LogMessageVoidify() & (*::VDLogGing::g_swallow_stream)
videodec/libchromes/base/logging.h:507:// Crashes in the fastest possible way with no attempt at logging.
videodec/libchromes/base/logging.h:522://   trap code can be efficiently packed in the prologue of the function and
videodec/libchromes/base/logging.h:615:// Make all CHECK functions discard their log strings to reduce code bloat, and
videodec/libchromes/base/logging.h:629:  LAZY_STREAM(PLOG_STREAM(FATAL), UNLIKELY(!(condition))); \
videodec/libchromes/base/logging.h:646:      LAZY_STREAM(LOG_STREAM(FATAL), false) \
videodec/libchromes/base/logging.h:651:      LAZY_STREAM(PLOG_STREAM(FATAL), false) \
videodec/libchromes/base/logging.h:658:  LAZY_STREAM(::VDLogGing::LogMessage(__FILE__, __LINE__, #condition).stream(), \
videodec/libchromes/base/logging.h:662:  LAZY_STREAM(PLOG_STREAM(FATAL), !ANALYZER_ASSUME_TRUE(condition)) \
videodec/libchromes/base/logging.h:675:  if (::VDLogGing::CheckOpResult true_if_passed =                                \
videodec/libchromes/base/logging.h:676:      ::VDLogGing::Check##name##Impl((val1), (val2),                             \
videodec/libchromes/base/logging.h:680:    ::VDLogGing::LogMessage(__FILE__, __LINE__, true_if_passed.message()).stream()
videodec/libchromes/base/logging.h:739:// in logging.cc.
videodec/libchromes/base/logging.h:770:      return ::VDLogGing::MakeCheckOpString(v1, v2, names);                    \
videodec/libchromes/base/logging.h:776:      return ::VDLogGing::MakeCheckOpString(v1, v2, names);                    \
videodec/libchromes/base/logging.h:799:// Definitions for DLOG et al.
videodec/libchromes/base/logging.h:803:#define DLOG_IS_ON(severity) LOG_IS_ON(severity)
videodec/libchromes/base/logging.h:804:#define DLOG_IF(severity, condition) LOG_IF(severity, condition)
videodec/libchromes/base/logging.h:805:#define DLOG_ASSERT(condition) LOG_ASSERT(condition)
videodec/libchromes/base/logging.h:806:#define DPLOG_IF(severity, condition) PLOG_IF(severity, condition)
videodec/libchromes/base/logging.h:807:#define DVLOG_IF(verboselevel, condition) VLOG_IF(verboselevel, condition)
videodec/libchromes/base/logging.h:808:#define DVPLOG_IF(verboselevel, condition) VPLOG_IF(verboselevel, condition)
videodec/libchromes/base/logging.h:816:#define DLOG_IS_ON(severity) false
videodec/libchromes/base/logging.h:817:#define DLOG_IF(severity, condition) EAT_STREAM_PARAMETERS
videodec/libchromes/base/logging.h:818:#define DLOG_ASSERT(condition) EAT_STREAM_PARAMETERS
videodec/libchromes/base/logging.h:819:#define DPLOG_IF(severity, condition) EAT_STREAM_PARAMETERS
videodec/libchromes/base/logging.h:820:#define DVLOG_IF(verboselevel, condition) EAT_STREAM_PARAMETERS
videodec/libchromes/base/logging.h:821:#define DVPLOG_IF(verboselevel, condition) EAT_STREAM_PARAMETERS
videodec/libchromes/base/logging.h:825:#define DLOG(severity)                                          \
videodec/libchromes/base/logging.h:826:  LAZY_STREAM(LOG_STREAM(severity), DLOG_IS_ON(severity))
videodec/libchromes/base/logging.h:828:#define DPLOG(severity)                                         \
videodec/libchromes/base/logging.h:829:  LAZY_STREAM(PLOG_STREAM(severity), DLOG_IS_ON(severity))
videodec/libchromes/base/logging.h:831:#define DVLOG(verboselevel) DVLOG_IF(verboselevel, VLOG_IS_ON(verboselevel))
videodec/libchromes/base/logging.h:833:#define DVPLOG(verboselevel) DVPLOG_IF(verboselevel, VLOG_IS_ON(verboselevel))
videodec/libchromes/base/logging.h:840:BASE_EXPORT extern LogSeverity LOG_DCHECK;
videodec/libchromes/base/logging.h:842:const LogSeverity LOG_DCHECK = LOG_FATAL;
videodec/libchromes/base/logging.h:847:// There may be users of LOG_DCHECK that are enabled independently
videodec/libchromes/base/logging.h:848:// of DCHECK_IS_ON(), so default to FATAL logging for those.
videodec/libchromes/base/logging.h:849:const LogSeverity LOG_DCHECK = LOG_FATAL;
videodec/libchromes/base/logging.h:856:// This behavior is different from DLOG_IF et al.
videodec/libchromes/base/logging.h:867:      LAZY_STREAM(LOG_STREAM(DCHECK), false) \
videodec/libchromes/base/logging.h:872:      LAZY_STREAM(PLOG_STREAM(DCHECK), false) \
videodec/libchromes/base/logging.h:880:  LAZY_STREAM(LOG_STREAM(DCHECK), !ANALYZER_ASSUME_TRUE(condition)) \
videodec/libchromes/base/logging.h:883:  LAZY_STREAM(PLOG_STREAM(DCHECK), !ANALYZER_ASSUME_TRUE(condition)) \
videodec/libchromes/base/logging.h:905:  if (::VDLogGing::CheckOpResult true_if_passed =                        \
videodec/libchromes/base/logging.h:906:      ::VDLogGing::Check##name##Impl((val1), (val2),                     \
videodec/libchromes/base/logging.h:910:    ::VDLogGing::LogMessage(__FILE__, __LINE__, ::VDLogGing::LOG_DCHECK,   \
videodec/libchromes/base/logging.h:924:  EAT_STREAM_PARAMETERS << (::VDLogGing::MakeCheckOpValueString(      \
videodec/libchromes/base/logging.h:925:                                ::VDLogGing::g_swallow_stream, val1), \
videodec/libchromes/base/logging.h:926:                            ::VDLogGing::MakeCheckOpValueString(      \
videodec/libchromes/base/logging.h:927:                                ::VDLogGing::g_swallow_stream, val2), \
videodec/libchromes/base/logging.h:932:// Equality/Inequality checks - compare two values, and log a
videodec/libchromes/base/logging.h:933:// LOG_DCHECK message including the two values when the result is not
videodec/libchromes/base/logging.h:960:// Implement logging of NOTREACHED() as a dedicated function to get function
videodec/libchromes/base/logging.h:962:void LogErrorNotReached(const char* file, int line);
videodec/libchromes/base/logging.h:964:  true ? ::VDLogGing::LogErrorNotReached(__FILE__, __LINE__) \
videodec/libchromes/base/logging.h:970:// Redefine the standard assert to use our nice log files
videodec/libchromes/base/logging.h:972:#define assert(x) DLOG_ASSERT(x)
videodec/libchromes/base/logging.h:974:// This class more or less represents a particular log message.  You
videodec/libchromes/base/logging.h:975:// create an instance of LogMessage and then stream stuff to it.
videodec/libchromes/base/logging.h:976:// When you finish streaming to it, ~LogMessage is called and the
videodec/libchromes/base/logging.h:979:// You shouldn't actually use LogMessage's constructor to log things,
videodec/libchromes/base/logging.h:980:// though.  You should use the LOG() macro (and variants thereof)
videodec/libchromes/base/logging.h:982:class BASE_EXPORT LogMessage {
videodec/libchromes/base/logging.h:984:  // Used for LOG(severity).
videodec/libchromes/base/logging.h:985:  LogMessage(const char* file, int line, LogSeverity severity);
videodec/libchromes/base/logging.h:987:  // Used for CHECK().  Implied severity = LOG_FATAL.
videodec/libchromes/base/logging.h:988:  LogMessage(const char* file, int line, const char* condition);
videodec/libchromes/base/logging.h:991:  // Implied severity = LOG_FATAL.
videodec/libchromes/base/logging.h:992:  LogMessage(const char* file, int line, std::string* result);
videodec/libchromes/base/logging.h:995:  LogMessage(const char* file, int line, LogSeverity severity,
videodec/libchromes/base/logging.h:998:  ~LogMessage();
videodec/libchromes/base/logging.h:1002:  LogSeverity severity() { return severity_; }
videodec/libchromes/base/logging.h:1008:  LogSeverity severity_;
videodec/libchromes/base/logging.h:1019:  // This is useful since the LogMessage class uses a lot of Win32 calls
videodec/libchromes/base/logging.h:1020:  // that will lose the value of GLE and the code that called the log function
videodec/libchromes/base/logging.h:1021:  // will have lost the thread error value when the log call returns.
videodec/libchromes/base/logging.h:1036:  DISALLOW_COPY_AND_ASSIGN(LogMessage);
videodec/libchromes/base/logging.h:1040:// logging macros.  This avoids compiler warnings like "value computed
videodec/libchromes/base/logging.h:1042:class LogMessageVoidify {
videodec/libchromes/base/logging.h:1044:  LogMessageVoidify() = default;
videodec/libchromes/base/logging.h:1063:class BASE_EXPORT Win32ErrorLogMessage {
videodec/libchromes/base/logging.h:1065:  Win32ErrorLogMessage(const char* file,
videodec/libchromes/base/logging.h:1067:                       LogSeverity severity,
videodec/libchromes/base/logging.h:1071:  ~Win32ErrorLogMessage();
videodec/libchromes/base/logging.h:1073:  std::ostream& stream() { return log_message_.stream(); }
videodec/libchromes/base/logging.h:1077:  LogMessage log_message_;
videodec/libchromes/base/logging.h:1079:  DISALLOW_COPY_AND_ASSIGN(Win32ErrorLogMessage);
videodec/libchromes/base/logging.h:1083:class BASE_EXPORT ErrnoLogMessage {
videodec/libchromes/base/logging.h:1085:  ErrnoLogMessage(const char* file,
videodec/libchromes/base/logging.h:1087:                  LogSeverity severity,
videodec/libchromes/base/logging.h:1091:  ~ErrnoLogMessage();
videodec/libchromes/base/logging.h:1093:  std::ostream& stream() { return log_message_.stream(); }
videodec/libchromes/base/logging.h:1097:  LogMessage log_message_;
videodec/libchromes/base/logging.h:1099:  DISALLOW_COPY_AND_ASSIGN(ErrnoLogMessage);
videodec/libchromes/base/logging.h:1103:// Closes the log file explicitly if open.
videodec/libchromes/base/logging.h:1104:// NOTE: Since the log file is opened as necessary by the action of logging
videodec/libchromes/base/logging.h:1107:BASE_EXPORT void CloseLogFile();
videodec/libchromes/base/logging.h:1109:// Async signal safe logging mechanism.
videodec/libchromes/base/logging.h:1110:BASE_EXPORT void RawLog(int level, const char* message);
videodec/libchromes/base/logging.h:1112:#define RAW_LOG(level, message) \
videodec/libchromes/base/logging.h:1113:  ::VDLogGing::RawLog(::VDLogGing::LOG_##level, message)
videodec/libchromes/base/logging.h:1118:      ::VDLogGing::RawLog(::VDLogGing::LOG_FATAL,              \
videodec/libchromes/base/logging.h:1123:// Returns true if logging to file is enabled.
videodec/libchromes/base/logging.h:1124:BASE_EXPORT bool IsLoggingToFileEnabled();
videodec/libchromes/base/logging.h:1126:// Returns the default log file path.
videodec/libchromes/base/logging.h:1127:BASE_EXPORT std::wstring GetLogFileFullPath();
videodec/libchromes/base/logging.h:1130:}  // namespace logging
videodec/libchromes/base/logging.h:1141:// These functions are provided as a convenience for logging, which is where we
videodec/libchromes/base/logging.h:1143:// is designed to allow you to emit non-ASCII Unicode strings to the log file,
videodec/libchromes/base/logging.h:1155:// NOTIMPLEMENTED_LOG_ONCE can be used.
videodec/libchromes/base/logging.h:1167:#define NOTIMPLEMENTED_LOG_ONCE() EAT_STREAM_PARAMETERS
videodec/libchromes/base/logging.h:1169:#define NOTIMPLEMENTED() LOG(ERROR) << NOTIMPLEMENTED_MSG
videodec/libchromes/base/logging.h:1170:#define NOTIMPLEMENTED_LOG_ONCE()                      \
videodec/libchromes/base/logging.h:1172:    static bool logged_once = false;                   \
videodec/libchromes/base/logging.h:1173:    LOG_IF(ERROR, !logged_once) << NOTIMPLEMENTED_MSG; \
videodec/libchromes/base/logging.h:1174:    logged_once = true;                                \
videodec/libchromes/base/logging.h:1179:#endif  // BASE_LOGGING_H_
videodec/libchromes/base/numerics/safe_conversions.h:98:// checked_cast<> is analogous to static_cast<> for numeric types,
videodec/libchromes/base/numerics/safe_conversions.h:185:// saturated_cast<> is analogous to static_cast<> for numeric types, except
videodec/libchromes/base/numerics/safe_conversions.h:205:// strict_cast<> is analogous to static_cast<> for numeric types, except that
videodec/libchromes/base/numerics/safe_conversions.h:302:// Overload the ostream output operator to make logging work nicely.
videodec/libchromes/base/numerics/README.md:166:*   `checked_cast<>()` - Analogous to `static_cast<>` for numeric types, except
videodec/libchromes/base/numerics/README.md:171:*   `saturated_cast<>()` - Analogous to `static_cast` for numeric types, except
videodec/libchromes/base/numerics/README.md:175:*   `strict_cast<>()` - Analogous to `static_cast` for numeric types, except
videodec/libchromes/base/numerics/README.md:211:`CheckedNumeric<>` implements all the logic and operators for detecting integer
videodec/libchromes/base/numerics/README.md:228:and *bitwise logical operations always return an unsigned of the wider type.*
videodec/libchromes/base/numerics/README.md:322:`ClampedNumeric<>` implements all the logic and operators for clamped
videodec/libchromes/base/numerics/README.md:341:and *bitwise logical operations always return an unsigned of the wider type.*
videodec/libchromes/base/numerics/README.md:349:	returns zero (although logically is NaN).
videodec/libchromes/base/numerics/clamped_math.h:195:// Overload the ostream output operator to make logging work nicely.
videodec/libchromes/base/numerics/safe_conversions_impl.h:25:// we can compute an analog using std::numeric_limits<>::digits.
videodec/libchromes/base/numerics/checked_math.h:112:  // This friend method is available solely for providing more detailed logging
videodec/libchromes/base/logging.cc:5:#include "base/logging.h"
videodec/libchromes/base/logging.cc:24:// In MacOS 10.12 and iOS 10.0 and later ASL (Apple System Log) was deprecated
videodec/libchromes/base/logging.cc:25:// in favor of OS_LOG (Unified Logging).
videodec/libchromes/base/logging.cc:41:#include <os/log.h>
videodec/libchromes/base/logging.cc:62:#include <android/log.h>
videodec/libchromes/base/logging.cc:104:#include "base/vlog.h"
videodec/libchromes/base/logging.cc:110:namespace VDLogGing {
videodec/libchromes/base/logging.cc:114:VlogInfo* g_vlog_info = nullptr;
videodec/libchromes/base/logging.cc:115:VlogInfo* g_vlog_info_prev = nullptr;
videodec/libchromes/base/logging.cc:117:const char* const log_severity_names[] = {"INFO", "WARNING", "ERROR", "FATAL"};
videodec/libchromes/base/logging.cc:118:static_assert(LOG_NUM_SEVERITIES == arraysize(log_severity_names),
videodec/libchromes/base/logging.cc:119:              "Incorrect number of log_severity_names");
videodec/libchromes/base/logging.cc:121:const char* log_severity_name(int severity) {
videodec/libchromes/base/logging.cc:122:  if (severity >= 0 && severity < LOG_NUM_SEVERITIES)
videodec/libchromes/base/logging.cc:123:    return log_severity_names[severity];
videodec/libchromes/base/logging.cc:127:int g_min_log_level = 0;
videodec/libchromes/base/logging.cc:129:LoggingDestination g_logging_destination = LOG_DEFAULT;
videodec/libchromes/base/logging.cc:131:// For LOG_ERROR and above, always print to stderr.
videodec/libchromes/base/logging.cc:132:const int kAlwaysPrintErrorLevel = LOG_ERROR;
videodec/libchromes/base/logging.cc:134:// Which log file to use? This is initialized by InitLogging or
videodec/libchromes/base/logging.cc:142:PathString* g_log_file_name = nullptr;
videodec/libchromes/base/logging.cc:145:FileHandle g_log_file = nullptr;
videodec/libchromes/base/logging.cc:148:bool g_log_process_id = false;
videodec/libchromes/base/logging.cc:149:bool g_log_thread_id = false;
videodec/libchromes/base/logging.cc:150:bool g_log_timestamp = true;
videodec/libchromes/base/logging.cc:151:bool g_log_tickcount = false;
videodec/libchromes/base/logging.cc:153:// Should we pop up fatal debug messages in a dialog?
videodec/libchromes/base/logging.cc:154:bool show_error_dialogs = false;
videodec/libchromes/base/logging.cc:157:// the debug message dialog and process termination. Assert handlers are stored
videodec/libchromes/base/logging.cc:159:base::LazyInstance<base::stack<LogAssertHandlerFunction>>::Leaky
videodec/libchromes/base/logging.cc:160:    log_assert_handler_stack = LAZY_INSTANCE_INITIALIZER;
videodec/libchromes/base/logging.cc:162:// A log message handler that gets notified of every log message we process.
videodec/libchromes/base/logging.cc:163:LogMessageHandlerFunction log_message_handler = nullptr;
videodec/libchromes/base/logging.cc:203:void DeleteFilePath(const PathString& log_name) {
videodec/libchromes/base/logging.cc:205:  DeleteFile(log_name.c_str());
videodec/libchromes/base/logging.cc:209:  unlink(log_name.c_str());
videodec/libchromes/base/logging.cc:215:PathString GetDefaultLogFile() {
videodec/libchromes/base/logging.cc:221:  PathString log_name = module_name;
videodec/libchromes/base/logging.cc:222:  PathString::size_type last_backslash = log_name.rfind('\\', log_name.size());
videodec/libchromes/base/logging.cc:224:    log_name.erase(last_backslash + 1);
videodec/libchromes/base/logging.cc:225:  log_name += L"debug.log";
videodec/libchromes/base/logging.cc:226:  return log_name;
videodec/libchromes/base/logging.cc:229:  return PathString("debug.log");
videodec/libchromes/base/logging.cc:236:// This class acts as a wrapper for locking the logging files.
videodec/libchromes/base/logging.cc:237:// LoggingLock::Init() should be called from the main thread before any logging
videodec/libchromes/base/logging.cc:238:// is done. Then whenever logging, be sure to have a local LoggingLock
videodec/libchromes/base/logging.cc:241:// LoggingLocks can not be nested.
videodec/libchromes/base/logging.cc:242:class LoggingLock {
videodec/libchromes/base/logging.cc:244:  LoggingLock() {
videodec/libchromes/base/logging.cc:245:    LockLogging();
videodec/libchromes/base/logging.cc:248:  ~LoggingLock() {
videodec/libchromes/base/logging.cc:249:    UnlockLogging();
videodec/libchromes/base/logging.cc:252:  static void Init(LogLockingState lock_log, const PathChar* new_log_file) {
videodec/libchromes/base/logging.cc:255:    lock_log_file = lock_log;
videodec/libchromes/base/logging.cc:257:    if (lock_log_file != LOCK_LOG_FILE)
videodec/libchromes/base/logging.cc:258:      log_lock = new base::internal::LockImpl();
videodec/libchromes/base/logging.cc:264:  static void LockLogging() {
videodec/libchromes/base/logging.cc:265:    if (lock_log_file == LOCK_LOG_FILE) {
videodec/libchromes/base/logging.cc:266:      pthread_mutex_lock(&log_mutex);
videodec/libchromes/base/logging.cc:269:      log_lock->Lock();
videodec/libchromes/base/logging.cc:273:  static void UnlockLogging() {
videodec/libchromes/base/logging.cc:274:    if (lock_log_file == LOCK_LOG_FILE) {
videodec/libchromes/base/logging.cc:275:      pthread_mutex_unlock(&log_mutex);
videodec/libchromes/base/logging.cc:277:      log_lock->Unlock();
videodec/libchromes/base/logging.cc:281:  // The lock is used if log file locking is false. It helps us avoid problems
videodec/libchromes/base/logging.cc:282:  // with multiple threads writing to the log file at the same time.  Use
videodec/libchromes/base/logging.cc:283:  // LockImpl directly instead of using Lock, because Lock makes logging calls.
videodec/libchromes/base/logging.cc:284:  static base::internal::LockImpl* log_lock;
videodec/libchromes/base/logging.cc:288:  static pthread_mutex_t log_mutex;
videodec/libchromes/base/logging.cc:291:  static LogLockingState lock_log_file;
videodec/libchromes/base/logging.cc:295:bool LoggingLock::initialized = false;
videodec/libchromes/base/logging.cc:297:base::internal::LockImpl* LoggingLock::log_lock = nullptr;
videodec/libchromes/base/logging.cc:299:LogLockingState LoggingLock::lock_log_file = LOCK_LOG_FILE;
videodec/libchromes/base/logging.cc:301:pthread_mutex_t LoggingLock::log_mutex = PTHREAD_MUTEX_INITIALIZER;
videodec/libchromes/base/logging.cc:305:// Called by logging functions to ensure that |g_log_file| is initialized
videodec/libchromes/base/logging.cc:307:// initialized. |g_log_file| will be nullptr in this case.
videodec/libchromes/base/logging.cc:308:bool InitializeLogFileHandle() {
videodec/libchromes/base/logging.cc:309:  if (g_log_file)
videodec/libchromes/base/logging.cc:312:  if (!g_log_file_name) {
videodec/libchromes/base/logging.cc:313:    // Nobody has called InitLogging to specify a debug log file, so here we
videodec/libchromes/base/logging.cc:314:    // initialize the log file name to a default.
videodec/libchromes/base/logging.cc:315:    g_log_file_name = new PathString(GetDefaultLogFile());
videodec/libchromes/base/logging.cc:318:  if ((g_logging_destination & LOG_TO_FILE) != 0) {
videodec/libchromes/base/logging.cc:324:    g_log_file = CreateFile(g_log_file_name->c_str(), FILE_APPEND_DATA,
videodec/libchromes/base/logging.cc:327:    if (g_log_file == INVALID_HANDLE_VALUE || g_log_file == nullptr) {
videodec/libchromes/base/logging.cc:329:      // dependencies of the logging implementation. For e.g. FilePath and
videodec/libchromes/base/logging.cc:331:      // some consumers of base logging like chrome_elf, etc.
videodec/libchromes/base/logging.cc:341:      *g_log_file_name = system_buffer;
videodec/libchromes/base/logging.cc:343:      if (g_log_file_name->back() != L'\\')
videodec/libchromes/base/logging.cc:344:        *g_log_file_name += L"\\";
videodec/libchromes/base/logging.cc:345:      *g_log_file_name += L"debug.log";
videodec/libchromes/base/logging.cc:347:      g_log_file = CreateFile(g_log_file_name->c_str(), FILE_APPEND_DATA,
videodec/libchromes/base/logging.cc:350:      if (g_log_file == INVALID_HANDLE_VALUE || g_log_file == nullptr) {
videodec/libchromes/base/logging.cc:351:        g_log_file = nullptr;
videodec/libchromes/base/logging.cc:356:    g_log_file = fopen(g_log_file_name->c_str(), "a");
videodec/libchromes/base/logging.cc:357:    if (g_log_file == nullptr)
videodec/libchromes/base/logging.cc:367:void CloseFile(FileHandle log) {
videodec/libchromes/base/logging.cc:369:  CloseHandle(log);
videodec/libchromes/base/logging.cc:371:  fclose(log);
videodec/libchromes/base/logging.cc:377:void CloseLogFileUnlocked() {
videodec/libchromes/base/logging.cc:378:  if (!g_log_file)
videodec/libchromes/base/logging.cc:381:  CloseFile(g_log_file);
videodec/libchromes/base/logging.cc:382:  g_log_file = nullptr;
videodec/libchromes/base/logging.cc:388:// In DCHECK-enabled Chrome builds, allow the meaning of LOG_DCHECK to be
videodec/libchromes/base/logging.cc:391:BASE_EXPORT logging::LogSeverity LOG_DCHECK = LOG_INFO;
videodec/libchromes/base/logging.cc:399:LoggingSettings::LoggingSettings()
videodec/libchromes/base/logging.cc:400:    : logging_dest(LOG_DEFAULT),
videodec/libchromes/base/logging.cc:401:      log_file(nullptr),
videodec/libchromes/base/logging.cc:402:      lock_log(LOCK_LOG_FILE),
videodec/libchromes/base/logging.cc:403:      delete_old(APPEND_TO_OLD_LOG_FILE) {}
videodec/libchromes/base/logging.cc:405:bool BaseInitLoggingImpl(const LoggingSettings& settings) {
videodec/libchromes/base/logging.cc:407:  // Can log only to the system debug log.
videodec/libchromes/base/logging.cc:408:  CHECK_EQ(settings.logging_dest & ~LOG_TO_SYSTEM_DEBUG_LOG, 0);
videodec/libchromes/base/logging.cc:412:    // Don't bother initializing |g_vlog_info| unless we use one of the
videodec/libchromes/base/logging.cc:413:    // vlog switches.
videodec/libchromes/base/logging.cc:416:      // NOTE: If |g_vlog_info| has already been initialized, it might be in use
videodec/libchromes/base/logging.cc:417:      // by another thread. Don't delete the old VLogInfo, just create a second
videodec/libchromes/base/logging.cc:419:      CHECK(!g_vlog_info_prev);
videodec/libchromes/base/logging.cc:420:      g_vlog_info_prev = g_vlog_info;
videodec/libchromes/base/logging.cc:422:      g_vlog_info =
videodec/libchromes/base/logging.cc:423:          new VlogInfo(command_line->GetSwitchValueASCII(switches::kV),
videodec/libchromes/base/logging.cc:425:                       &g_min_log_level);
videodec/libchromes/base/logging.cc:429:  g_logging_destination = settings.logging_dest;
videodec/libchromes/base/logging.cc:431:  // ignore file options unless logging to file is set.
videodec/libchromes/base/logging.cc:432:  if ((g_logging_destination & LOG_TO_FILE) == 0)
videodec/libchromes/base/logging.cc:436:  LoggingLock::Init(settings.lock_log, settings.log_file);
videodec/libchromes/base/logging.cc:437:  LoggingLock logging_lock;
videodec/libchromes/base/logging.cc:440:  // Calling InitLogging twice or after some log call has already opened the
videodec/libchromes/base/logging.cc:441:  // default log file will re-initialize to the new options.
videodec/libchromes/base/logging.cc:442:  CloseLogFileUnlocked();
videodec/libchromes/base/logging.cc:444:  if (!g_log_file_name)
videodec/libchromes/base/logging.cc:445:    g_log_file_name = new PathString();
videodec/libchromes/base/logging.cc:446:  *g_log_file_name = settings.log_file;
videodec/libchromes/base/logging.cc:447:  if (settings.delete_old == DELETE_OLD_LOG_FILE)
videodec/libchromes/base/logging.cc:448:    DeleteFilePath(*g_log_file_name);
videodec/libchromes/base/logging.cc:450:  return InitializeLogFileHandle();
videodec/libchromes/base/logging.cc:453:void SetMinLogLevel(int level) {
videodec/libchromes/base/logging.cc:454:  g_min_log_level = std::min(LOG_FATAL, level);
videodec/libchromes/base/logging.cc:457:int GetMinLogLevel() {
videodec/libchromes/base/logging.cc:458:  return g_min_log_level;
videodec/libchromes/base/logging.cc:461:bool ShouldCreateLogMessage(int severity) {
videodec/libchromes/base/logging.cc:462:  if (severity < g_min_log_level)
videodec/libchromes/base/logging.cc:465:  // Return true here unless we know ~LogMessage won't do anything. Note that
videodec/libchromes/base/logging.cc:466:  // ~LogMessage writes to stderr if severity_ >= kAlwaysPrintErrorLevel, even
videodec/libchromes/base/logging.cc:467:  // when g_logging_destination is LOG_NONE.
videodec/libchromes/base/logging.cc:468:  return g_logging_destination != LOG_NONE || log_message_handler ||
videodec/libchromes/base/logging.cc:472:int GetVlogVerbosity() {
videodec/libchromes/base/logging.cc:473:  return std::max(-1, LOG_INFO - GetMinLogLevel());
videodec/libchromes/base/logging.cc:476:int GetVlogLevelHelper(const char* file, size_t N) {
videodec/libchromes/base/logging.cc:478:  // Note: |g_vlog_info| may change on a different thread during startup
videodec/libchromes/base/logging.cc:480:  VlogInfo* vlog_info = g_vlog_info;
videodec/libchromes/base/logging.cc:481:  return vlog_info ?
videodec/libchromes/base/logging.cc:482:      vlog_info->GetVlogLevel(base::StringPiece(file, N - 1)) :
videodec/libchromes/base/logging.cc:483:      GetVlogVerbosity();
videodec/libchromes/base/logging.cc:486:void SetLogItems(bool enable_process_id, bool enable_thread_id,
videodec/libchromes/base/logging.cc:488:  g_log_process_id = enable_process_id;
videodec/libchromes/base/logging.cc:489:  g_log_thread_id = enable_thread_id;
videodec/libchromes/base/logging.cc:490:  g_log_timestamp = enable_timestamp;
videodec/libchromes/base/logging.cc:491:  g_log_tickcount = enable_tickcount;
videodec/libchromes/base/logging.cc:494:void SetShowErrorDialogs(bool enable_dialogs) {
videodec/libchromes/base/logging.cc:495:  show_error_dialogs = enable_dialogs;
videodec/libchromes/base/logging.cc:498:ScopedLogAssertHandler::ScopedLogAssertHandler(
videodec/libchromes/base/logging.cc:499:    LogAssertHandlerFunction handler) {
videodec/libchromes/base/logging.cc:500:  log_assert_handler_stack.Get().push(std::move(handler));
videodec/libchromes/base/logging.cc:503:ScopedLogAssertHandler::~ScopedLogAssertHandler() {
videodec/libchromes/base/logging.cc:504:  log_assert_handler_stack.Get().pop();
videodec/libchromes/base/logging.cc:507:void SetLogMessageHandler(LogMessageHandlerFunction handler) {
videodec/libchromes/base/logging.cc:508:  log_message_handler = handler;
videodec/libchromes/base/logging.cc:511:LogMessageHandlerFunction GetLogMessageHandler() {
videodec/libchromes/base/logging.cc:512:  return log_message_handler;
videodec/libchromes/base/logging.cc:537:void DisplayDebugMessageInDialog(const std::string& str) {
videodec/libchromes/base/logging.cc:541:  if (!show_error_dialogs)
videodec/libchromes/base/logging.cc:545:  // We intentionally don't implement a dialog on other platforms.
videodec/libchromes/base/logging.cc:554:LogMessage::SaveLastError::SaveLastError() : last_error_(::GetLastError()) {
videodec/libchromes/base/logging.cc:557:LogMessage::SaveLastError::~SaveLastError() {
videodec/libchromes/base/logging.cc:562:LogMessage::LogMessage(const char* file, int line, LogSeverity severity)
videodec/libchromes/base/logging.cc:567:LogMessage::LogMessage(const char* file, int line, const char* condition)
videodec/libchromes/base/logging.cc:568:    : severity_(LOG_FATAL), file_(file), line_(line) {
videodec/libchromes/base/logging.cc:573:LogMessage::LogMessage(const char* file, int line, std::string* result)
videodec/libchromes/base/logging.cc:574:    : severity_(LOG_FATAL), file_(file), line_(line) {
videodec/libchromes/base/logging.cc:580:LogMessage::LogMessage(const char* file, int line, LogSeverity severity,
videodec/libchromes/base/logging.cc:588:LogMessage::~LogMessage() {
videodec/libchromes/base/logging.cc:592:  if (severity_ == LOG_FATAL && !base::debug::BeingDebugged()) {
videodec/libchromes/base/logging.cc:595:    stream_ << std::endl;  // Newline to separate from log message.
videodec/libchromes/base/logging.cc:602:  // Give any log message handler first dibs on the message.
videodec/libchromes/base/logging.cc:603:  if (log_message_handler &&
videodec/libchromes/base/logging.cc:604:      log_message_handler(severity_, file_, line_,
videodec/libchromes/base/logging.cc:610:  if ((g_logging_destination & LOG_TO_SYSTEM_DEBUG_LOG) != 0) {
videodec/libchromes/base/logging.cc:614:    // In LOG_TO_SYSTEM_DEBUG_LOG mode, log messages are always written to
videodec/libchromes/base/logging.cc:615:    // stderr. If stderr is /dev/null, also log via ASL (Apple System Log) or
videodec/libchromes/base/logging.cc:616:    // its successor OS_LOG. If there's something weird about stderr, assume
videodec/libchromes/base/logging.cc:617:    // that log messages are going nowhere and log via ASL/OS_LOG too.
videodec/libchromes/base/logging.cc:618:    // Messages logged via ASL/OS_LOG show up in Console.app.
videodec/libchromes/base/logging.cc:622:    // a pipe to launchd, which logged what it received (see log_redirect_fd in
videodec/libchromes/base/logging.cc:623:    // 10.7.5 launchd-392.39/launchd/src/launchd_core_logic.c).
videodec/libchromes/base/logging.cc:626:    // launchd and avoid logging via ASL only in that case. See 10.7.5
videodec/libchromes/base/logging.cc:627:    // CF-635.21/CFUtilities.c also_do_stderr(). This would result in logging to
videodec/libchromes/base/logging.cc:628:    // both stderr and ASL/OS_LOG even in tests, where it's undesirable to log
videodec/libchromes/base/logging.cc:629:    // to the system log at all.
videodec/libchromes/base/logging.cc:633:    // asl_set_filter(), but this is pointless because syslogd normally applies
videodec/libchromes/base/logging.cc:635:    const bool log_to_system = []() {
videodec/libchromes/base/logging.cc:653:    if (log_to_system) {
videodec/libchromes/base/logging.cc:654:      // Log roughly the same way that CFLog() and NSLog() would. See 10.10.5
videodec/libchromes/base/logging.cc:655:      // CF-1153.18/CFUtilities.c __CFLogCString().
videodec/libchromes/base/logging.cc:697:      // Map Chrome log severities to ASL log levels.
videodec/libchromes/base/logging.cc:698:      const char* const asl_level_string = [](LogSeverity severity) {
videodec/libchromes/base/logging.cc:705:          case LOG_INFO:
videodec/libchromes/base/logging.cc:707:          case LOG_WARNING:
videodec/libchromes/base/logging.cc:709:          case LOG_ERROR:
videodec/libchromes/base/logging.cc:711:          case LOG_FATAL:
videodec/libchromes/base/logging.cc:726:      const class OSLog {
videodec/libchromes/base/logging.cc:728:        explicit OSLog(const char* subsystem)
videodec/libchromes/base/logging.cc:729:            : os_log_(subsystem ? os_log_create(subsystem, "chromium_logging")
videodec/libchromes/base/logging.cc:730:                                : OS_LOG_DEFAULT) {}
videodec/libchromes/base/logging.cc:731:        ~OSLog() {
videodec/libchromes/base/logging.cc:732:          if (os_log_ != OS_LOG_DEFAULT) {
videodec/libchromes/base/logging.cc:733:            os_release(os_log_);
videodec/libchromes/base/logging.cc:736:        os_log_t get() const { return os_log_; }
videodec/libchromes/base/logging.cc:739:        os_log_t os_log_;
videodec/libchromes/base/logging.cc:740:        DISALLOW_COPY_AND_ASSIGN(OSLog);
videodec/libchromes/base/logging.cc:741:      } log(main_bundle_id.empty() ? nullptr : main_bundle_id.c_str());
videodec/libchromes/base/logging.cc:742:      const os_log_type_t os_log_type = [](LogSeverity severity) {
videodec/libchromes/base/logging.cc:744:          case LOG_INFO:
videodec/libchromes/base/logging.cc:745:            return OS_LOG_TYPE_INFO;
videodec/libchromes/base/logging.cc:746:          case LOG_WARNING:
videodec/libchromes/base/logging.cc:747:            return OS_LOG_TYPE_DEFAULT;
videodec/libchromes/base/logging.cc:748:          case LOG_ERROR:
videodec/libchromes/base/logging.cc:749:            return OS_LOG_TYPE_ERROR;
videodec/libchromes/base/logging.cc:750:          case LOG_FATAL:
videodec/libchromes/base/logging.cc:751:            return OS_LOG_TYPE_FAULT;
videodec/libchromes/base/logging.cc:753:            return severity < 0 ? OS_LOG_TYPE_DEBUG : OS_LOG_TYPE_DEFAULT;
videodec/libchromes/base/logging.cc:756:      os_log_with_type(log.get(), os_log_type, "%{public}s",
videodec/libchromes/base/logging.cc:761:    android_LogPriority priority =
videodec/libchromes/base/logging.cc:762:        (severity_ < 0) ? ANDROID_LOG_VERBOSE : ANDROID_LOG_UNKNOWN;
videodec/libchromes/base/logging.cc:764:      case LOG_INFO:
videodec/libchromes/base/logging.cc:765:        priority = ANDROID_LOG_INFO;
videodec/libchromes/base/logging.cc:767:      case LOG_WARNING:
videodec/libchromes/base/logging.cc:768:        priority = ANDROID_LOG_WARN;
videodec/libchromes/base/logging.cc:770:      case LOG_ERROR:
videodec/libchromes/base/logging.cc:771:        priority = ANDROID_LOG_ERROR;
videodec/libchromes/base/logging.cc:773:      case LOG_FATAL:
videodec/libchromes/base/logging.cc:774:        priority = ANDROID_LOG_FATAL;
videodec/libchromes/base/logging.cc:778:    __android_log_write(priority, "chromium", str_newline.c_str());
videodec/libchromes/base/logging.cc:780:    __android_log_write(
videodec/libchromes/base/logging.cc:791:    // When we're only outputting to a log file, above a certain log level, we
videodec/libchromes/base/logging.cc:798:  // write to log file
videodec/libchromes/base/logging.cc:799:  if ((g_logging_destination & LOG_TO_FILE) != 0) {
videodec/libchromes/base/logging.cc:802:    // If the client app did not call InitLogging, and the lock has not
videodec/libchromes/base/logging.cc:805:    // the lock. This is why InitLogging should be called from the main
videodec/libchromes/base/logging.cc:808:    LoggingLock::Init(LOCK_LOG_FILE, nullptr);
videodec/libchromes/base/logging.cc:809:    LoggingLock logging_lock;
videodec/libchromes/base/logging.cc:811:    if (InitializeLogFileHandle()) {
videodec/libchromes/base/logging.cc:814:      WriteFile(g_log_file,
videodec/libchromes/base/logging.cc:821:          str_newline.data(), str_newline.size(), 1, g_log_file));
videodec/libchromes/base/logging.cc:822:      fflush(g_log_file);
videodec/libchromes/base/logging.cc:829:  if (severity_ == LOG_FATAL) {
videodec/libchromes/base/logging.cc:830:    // Write the log message to the global activity tracker, if running.
videodec/libchromes/base/logging.cc:834:      tracker->RecordLogMessage(str_newline);
videodec/libchromes/base/logging.cc:840:    if (log_assert_handler_stack.IsCreated() &&
videodec/libchromes/base/logging.cc:841:        !log_assert_handler_stack.Get().empty()) {
videodec/libchromes/base/logging.cc:842:      LogAssertHandlerFunction log_assert_handler =
videodec/libchromes/base/logging.cc:843:          log_assert_handler_stack.Get().top();
videodec/libchromes/base/logging.cc:845:      if (log_assert_handler) {
videodec/libchromes/base/logging.cc:846:        log_assert_handler.Run(
videodec/libchromes/base/logging.cc:860:        // Displaying a dialog is unnecessary when debugging and can complicate
videodec/libchromes/base/logging.cc:862:        DisplayDebugMessageInDialog(stream_.str());
videodec/libchromes/base/logging.cc:872:void LogMessage::Init(const char* file, int line) {
videodec/libchromes/base/logging.cc:881:  if (g_log_process_id)
videodec/libchromes/base/logging.cc:883:  if (g_log_thread_id)
videodec/libchromes/base/logging.cc:885:  if (g_log_timestamp) {
videodec/libchromes/base/logging.cc:921:  if (g_log_tickcount)
videodec/libchromes/base/logging.cc:924:    stream_ << log_severity_name(severity_);
videodec/libchromes/base/logging.cc:970:Win32ErrorLogMessage::Win32ErrorLogMessage(const char* file,
videodec/libchromes/base/logging.cc:972:                                           LogSeverity severity,
videodec/libchromes/base/logging.cc:975:      log_message_(file, line, severity) {
videodec/libchromes/base/logging.cc:978:Win32ErrorLogMessage::~Win32ErrorLogMessage() {
videodec/libchromes/base/logging.cc:986:ErrnoLogMessage::ErrnoLogMessage(const char* file,
videodec/libchromes/base/logging.cc:988:                                 LogSeverity severity,
videodec/libchromes/base/logging.cc:991:      log_message_(file, line, severity) {
videodec/libchromes/base/logging.cc:994:ErrnoLogMessage::~ErrnoLogMessage() {
videodec/libchromes/base/logging.cc:1003:void CloseLogFile() {
videodec/libchromes/base/logging.cc:1005:  LoggingLock logging_lock;
videodec/libchromes/base/logging.cc:1007:  CloseLogFileUnlocked();
videodec/libchromes/base/logging.cc:1010:void RawLog(int level, const char* message) {
videodec/libchromes/base/logging.cc:1011:  if (level >= g_min_log_level && message) {
videodec/libchromes/base/logging.cc:1037:  if (level == LOG_FATAL)
videodec/libchromes/base/logging.cc:1045:bool IsLoggingToFileEnabled() {
videodec/libchromes/base/logging.cc:1046:  return g_logging_destination & LOG_TO_FILE;
videodec/libchromes/base/logging.cc:1049:std::wstring GetLogFileFullPath() {
videodec/libchromes/base/logging.cc:1050:  if (g_log_file_name)
videodec/libchromes/base/logging.cc:1051:    return *g_log_file_name;
videodec/libchromes/base/logging.cc:1056:BASE_EXPORT void LogErrorNotReached(const char* file, int line) {
videodec/libchromes/base/logging.cc:1057:  LogMessage(file, line, LOG_ERROR).stream()
videodec/libchromes/base/logging.cc:1061:}  // namespace logging
videodec/libchromes/base/debug/stack_trace.cc:12:#include "base/logging.h"
videodec/libchromes/base/debug/dump_without_crashing.cc:7:#include "base/logging.h"
videodec/libchromes/base/debug/leak_tracker.h:20:#include "base/logging.h"
videodec/libchromes/base/debug/leak_tracker.h:46:// the error log.
videodec/libchromes/base/debug/leak_tracker.h:100:      if (LOG_IS_ON(ERROR)) {
videodec/libchromes/base/debug/leak_tracker.h:101:        LOG_STREAM(ERROR) << "Leaked " << node << " which was allocated by:";
videodec/libchromes/base/debug/leak_tracker.h:102:        allocation_stack.OutputToStream(&LOG_STREAM(ERROR));
videodec/libchromes/base/debug/crash_logging.cc:5:#include "base/debug/crash_logging.h"
videodec/libchromes/base/debug/stack_trace_posix.cc:45:#include "base/logging.h"
videodec/libchromes/base/debug/stack_trace_posix.cc:569:    //   the callback registration is done in the constructor, so logically
videodec/libchromes/base/debug/stack_trace_posix.cc:652:      LOG(ERROR) << "Failed to read /proc/self/maps";
videodec/libchromes/base/debug/stack_trace_posix.cc:658:      LOG(ERROR) << "Failed to parse the contents of /proc/self/maps";
videodec/libchromes/base/debug/stack_trace_posix.cc:699:            LOG(WARNING) << "Failed to open file: " << region.path
videodec/libchromes/base/debug/debugger.h:33:// Used in test code, this controls whether showing dialogs and breaking into
videodec/libchromes/base/debug/debugger.h:37:// tests where we want a crash rather than a dialog or a debugger.
videodec/libchromes/base/debug/debugger_posix.cc:44:#include "base/logging.h"
videodec/libchromes/base/debug/debugger_posix.cc:222:// On other POSIX architectures, except Mac OS X, we use the same logic to
videodec/libchromes/base/debug/proc_maps_linux.cc:54:    DPLOG(ERROR) << "Couldn't open /proc/self/maps";
videodec/libchromes/base/debug/proc_maps_linux.cc:68:      DPLOG(ERROR) << "Couldn't read /proc/self/maps";
videodec/libchromes/base/debug/proc_maps_linux.cc:108:        DLOG(WARNING) << "Last line not empty";
videodec/libchromes/base/debug/proc_maps_linux.cc:133:      DPLOG(WARNING) << "sscanf failed for line: " << line;
videodec/libchromes/base/debug/crash_logging.h:5:#ifndef BASE_DEBUG_CRASH_LOGGING_H_
videodec/libchromes/base/debug/crash_logging.h:6:#define BASE_DEBUG_CRASH_LOGGING_H_
videodec/libchromes/base/debug/crash_logging.h:104:#endif  // BASE_DEBUG_CRASH_LOGGING_H_
videodec/libchromes/base/debug/stack_trace_android.cc:7:#include <android/log.h>
videodec/libchromes/base/debug/stack_trace_android.cc:82:  __android_log_write(ANDROID_LOG_ERROR, "chromium", backtrace.c_str());
videodec/libchromes/base/debug/stack_trace_android.cc:93:  // on fatal log messages in debug builds only. If the restriction is enabled
videodec/libchromes/base/debug/stack_trace_android.cc:98:    __android_log_write(
videodec/libchromes/base/debug/stack_trace_android.cc:99:        ANDROID_LOG_ERROR, "chromium", "Failed to read /proc/self/maps");
videodec/libchromes/base/debug/stack_trace_android.cc:101:    __android_log_write(
videodec/libchromes/base/debug/stack_trace_android.cc:102:        ANDROID_LOG_ERROR, "chromium", "Failed to parse /proc/self/maps");
videodec/libchromes/base/debug/task_annotator.h:36:  // doesn't want trace flow events logged to toplevel.flow.
videodec/libchromes/base/debug/activity_tracker.cc:16:#include "base/logging.h"
videodec/libchromes/base/debug/activity_tracker.cc:1487:      DLOG(ERROR) << "Recording exit of unknown process #" << process_id;
videodec/libchromes/base/debug/activity_tracker.cc:1598:void GlobalActivityTracker::RecordLogMessage(StringPiece message) {
videodec/libchromes/base/debug/activity_tracker.cc:1602:      allocator_->Allocate(message.size() + 1, kTypeIdGlobalLogMessage);
videodec/libchromes/base/debug/activity_tracker.cc:1603:  char* memory = allocator_->GetAsArray<char>(ref, kTypeIdGlobalLogMessage,
videodec/libchromes/base/debug/activity_tracker.h:775:    kTypeIdGlobalLogMessage = 0x4CF434F9 + 1,  // SHA1(GlobalLogMessage) v1
videodec/libchromes/base/debug/activity_tracker.h:1021:  // Records a log message. The current implementation does NOT recycle these
videodec/libchromes/base/debug/activity_tracker.h:1023:  void RecordLogMessage(StringPiece message);
videodec/libchromes/base/debug/activity_tracker.h:1024:  static void RecordLogMessageIfEnabled(StringPiece message) {
videodec/libchromes/base/debug/activity_tracker.h:1027:      tracker->RecordLogMessage(message);
videodec/libchromes/base/debug/debugger.cc:6:#include "base/logging.h"
videodec/libchromes/base/debug/debugger.cc:19:  DLOG(INFO) << "DebugUtil::WaitForDebugger(pid=" << static_cast<int>(getpid())
videodec/libchromes/base/sequence_token.cc:9:#include "base/logging.h"
videodec/libchromes/base/time/time_now_posix.cc:15:#include "base/logging.h"
videodec/libchromes/base/time/time.cc:13:#include "base/logging.h"
videodec/libchromes/base/time/time.cc:215:    DLOG(WARNING) << "Overflow when converting base::Time with internal " <<
videodec/libchromes/base/time/time_conversion_posix.cc:13:#include "base/logging.h"
videodec/libchromes/base/time/time.h:31:// DCHECK_EQ() and other log macros. For human-readable formatting, see
videodec/libchromes/base/time/time.h:62:#include "base/logging.h"
videodec/libchromes/base/time/time.h:316:// For logging use only.
videodec/libchromes/base/time/time.h:805:// For logging use only.
videodec/libchromes/base/time/time.h:887:  // logging purposes.
videodec/libchromes/base/time/time.h:915:// For logging use only.
videodec/libchromes/base/time/time.h:996:// For logging use only.
videodec/libchromes/base/sync_socket_posix.cc:22:#include "base/logging.h"
videodec/libchromes/base/sync_socket_posix.cc:49:    DPLOG(ERROR) << "close";
videodec/libchromes/base/observer_list_threadsafe.h:14:#include "base/logging.h"
videodec/libchromes/base/task_scheduler/scoped_set_task_priority_for_current_thread.cc:8:#include "base/logging.h"
videodec/libchromes/base/task_scheduler/task_traits.cc:11:#include "base/logging.h"
videodec/libchromes/base/task_scheduler/lazy_task_runner.cc:10:#include "base/logging.h"
videodec/libchromes/base/task_scheduler/post_task.cc:9:#include "base/logging.h"
videodec/libchromes/base/task_scheduler/tracked_ref.h:12:#include "base/logging.h"
videodec/libchromes/base/task_scheduler/tracked_ref.h:32:// (indicating a bug in the tear down logic -- proper refcounting on the other
videodec/libchromes/base/task_scheduler/tracked_ref.h:57:// tear down in a test with out-of-order tear down logic is much preferred to
videodec/libchromes/base/task_scheduler/tracked_ref.h:86:  // Intentionally not assignable for now because it makes the logic slightly
videodec/libchromes/base/task_scheduler/scheduler_lock_impl.cc:12:#include "base/logging.h"
videodec/libchromes/base/task_scheduler/sequence.cc:9:#include "base/logging.h"
videodec/libchromes/base/vlog.h:5:#ifndef BASE_VLOG_H_
videodec/libchromes/base/vlog.h:6:#define BASE_VLOG_H_
videodec/libchromes/base/vlog.h:15:namespace VDLogGing {
videodec/libchromes/base/vlog.h:17:// A helper class containing all the settings for vlogging.
videodec/libchromes/base/vlog.h:18:class BASE_EXPORT VlogInfo {
videodec/libchromes/base/vlog.h:20:  static const int kDefaultVlogLevel;
videodec/libchromes/base/vlog.h:22:  // |v_switch| gives the default maximal active V-logging level; 0 is
videodec/libchromes/base/vlog.h:23:  // the default.  Normally positive values are used for V-logging
videodec/libchromes/base/vlog.h:26:  // |vmodule_switch| gives the per-module maximal V-logging levels to
videodec/libchromes/base/vlog.h:28:  // E.g. "my_module=2,foo*=3" would change the logging level for all
videodec/libchromes/base/vlog.h:32:  // |log_severity| points to an int that stores the log level. If a valid
videodec/libchromes/base/vlog.h:33:  // |v_switch| is provided, it will set the log level, and the default
videodec/libchromes/base/vlog.h:34:  // vlog severity will be read from there..
videodec/libchromes/base/vlog.h:38:  // "*/foo/bar/*=2" would change the logging level for all code in
videodec/libchromes/base/vlog.h:40:  VlogInfo(const std::string& v_switch,
videodec/libchromes/base/vlog.h:42:           int* min_log_level);
videodec/libchromes/base/vlog.h:43:  ~VlogInfo();
videodec/libchromes/base/vlog.h:45:  // Returns the vlog level for a given file (usually taken from
videodec/libchromes/base/vlog.h:47:  int GetVlogLevel(const base::StringPiece& file) const;
videodec/libchromes/base/vlog.h:50:  void SetMaxVlogLevel(int level);
videodec/libchromes/base/vlog.h:51:  int GetMaxVlogLevel() const;
videodec/libchromes/base/vlog.h:57:  int* min_log_level_;
videodec/libchromes/base/vlog.h:59:  DISALLOW_COPY_AND_ASSIGN(VlogInfo);
videodec/libchromes/base/vlog.h:62:// Returns true if the string passed in matches the vlog pattern.  The
videodec/libchromes/base/vlog.h:63:// vlog pattern string can contain wildcards like * and ?.  ? matches
videodec/libchromes/base/vlog.h:72:BASE_EXPORT bool MatchVlogPattern(const base::StringPiece& string,
videodec/libchromes/base/vlog.h:73:                                  const base::StringPiece& vlog_pattern);
videodec/libchromes/base/vlog.h:75:}  // namespace logging
videodec/libchromes/base/vlog.h:77:#endif  // BASE_VLOG_H_
videodec/libchromes/base/trace_event/trace_event.h:30:class TraceLog {
videodec/libchromes/base/trace_event/trace_event.h:32:  static TraceLog* GetInstance() {
videodec/libchromes/base/trace_event/trace_event.h:33:    static TraceLog instance;
videodec/libchromes/base/trace_event/trace_event.h:63:#include "base/trace_event/trace_log.h"
videodec/libchromes/base/trace_event/trace_event.h:132:    base::trace_event::TraceLog::GetCategoryGroupEnabled
videodec/libchromes/base/trace_event/trace_event.h:138:    base::trace_event::TraceLog::GetInstance()->GetNumTracesRecorded
videodec/libchromes/base/trace_event/trace_event.h:155:    base::trace_event::TraceLog::GetInstance()->AddTraceEvent
videodec/libchromes/base/trace_event/trace_event.h:174:  base::trace_event::TraceLog::GetInstance()->AddTraceEventWithBindId
videodec/libchromes/base/trace_event/trace_event.h:194:  base::trace_event::TraceLog::GetInstance()->AddTraceEventWithProcessId
videodec/libchromes/base/trace_event/trace_event.h:214:    base::trace_event::TraceLog::GetInstance() \
videodec/libchromes/base/trace_event/trace_event.h:223:    base::trace_event::TraceLog::GetInstance()->UpdateTraceEventDuration
videodec/libchromes/base/trace_event/trace_event.h:233:  base::trace_event::TraceLog::GetInstance()->UpdateTraceEventDurationExplicit
videodec/libchromes/base/trace_event/trace_event.h:235:// Adds a metadata event to the trace log. The |AppendValueAsTraceFormat| method
videodec/libchromes/base/trace_event/trace_event.h:1112:  base::trace_event::TraceLog::GetInstance()->AddMetadataEvent(
videodec/libchromes/base/trace_event/trace_event.h:1131:  base::trace_event::TraceLog::GetInstance()->AddMetadataEvent(
videodec/libchromes/base/trace_event/common/trace_event_common.h:23:// Events are issued against categories. Whereas LOG's
videodec/libchromes/base/trace_event/common/trace_event_common.h:178:// category is protected by the TraceLog::lock_. Multiple threads initializing
videodec/libchromes/base/trace_event/common/trace_event_common.h:184:// which is threadsafe internally via TraceLog::lock_. The enabled flag may
videodec/libchromes/base/trace_event/common/trace_event_common.h:711://   be logged using the same id and category_group.
videodec/libchromes/base/task_runner.cc:10:#include "base/logging.h"
videodec/libchromes/base/posix/unix_domain_socket.cc:17:#include "base/logging.h"
videodec/libchromes/base/posix/unix_domain_socket.cc:193:      // Extraordinary case, not caller fixable. Log something.
videodec/libchromes/base/posix/unix_domain_socket.cc:194:      LOG(ERROR) << "recvmsg returned MSG_CTRUNC flag, buffer len is "
videodec/libchromes/base/posix/global_descriptors.cc:10:#include "base/logging.h"
videodec/libchromes/base/posix/global_descriptors.cc:36:    DLOG(DCHECK) << "Unknown global descriptor: " << key;
videodec/libchromes/base/posix/global_descriptors.cc:89:  DLOG(DCHECK) << "Unknown global descriptor: " << key;
videodec/libchromes/base/posix/safe_strerror.h:16:// BEFORE using anything from this file, first look at PLOG and friends in
videodec/libchromes/base/posix/safe_strerror.h:17:// logging.h and use them instead if applicable.
videodec/libchromes/base/posix/file_descriptor_shuffle.cc:12:#include "base/logging.h"
videodec/libchromes/base/posix/file_descriptor_shuffle.cc:47:            RAW_LOG(ERROR, "PerformInjectiveMultimapDestructive overflowed "
videodec/libchromes/libchrome_tools/patch/shared_memory_posix.patch:48:-    // or during unit-testing (assuming a ScopedLogAssertHandler was installed).
videodec/libchromes/libchrome_tools/patch/shared_memory_posix.patch:61:+  //   // or during unit-testing (assuming a ScopedLogAssertHandler was installed).
videodec/libchromes/libchrome_tools/patch/trace_event.patch:29:+class TraceLog {
videodec/libchromes/libchrome_tools/patch/trace_event.patch:31:+  static TraceLog* GetInstance() {
videodec/libchromes/libchrome_tools/patch/trace_event.patch:32:+    static TraceLog instance;
videodec/libchromes/libchrome_tools/patch/trace_event.patch:163: #include "base/logging.h"
videodec/libchromes/libchrome_tools/patch/ssl.patch:21: #include "base/logging.h"
videodec/libchromes/libchrome_tools/patch/ssl.patch:73: #include "base/logging.h"
videodec/libchromes/libchrome_tools/patch/build_time.patch:10: #include "base/logging.h"
videodec/libchromes/libchrome_tools/patch/mojo.patch:9:-  LOG(FATAL) << "Please include Java exception stack in crash report";
videodec/libchromes/libchrome_tools/patch/mojo.patch:12:+    LOG(FATAL) << GetJavaExceptionInfo(env, java_throwable);
videodec/libchromes/libchrome_tools/patch/mojo.patch:14:+    LOG(FATAL) << "Unhandled exception";
videodec/libchromes/libchrome_tools/patch/mojo-Add-a-way-to-create-thread-safe-interfaces-in-Java.patch:7:roughly analogous to mojo::ThreadSafeInterfacePtr<T>. Given that Java
videodec/libchromes/libchrome_tools/patch/mojom_disable_trace_and_mem_dump.patch:162:-    LOG(ERROR) << "Failed to create" << message_directory.value();
videodec/libchromes/libchrome_tools/patch/mojom_disable_trace_and_mem_dump.patch:189:+//     LOG(ERROR) << "Failed to create" << message_directory.value();
videodec/libchromes/libchrome_tools/patch/mojom_disable_trace_and_mem_dump.patch:248:+  LOG(FATAL) << "unsupported in libchrome";
videodec/libchromes/libchrome_tools/patch/path_service.patch:8: #include "base/logging.h"
videodec/libchromes/libchrome_tools/patch/logging.patch:1:diff --git a/base/logging.cc b/base/logging.cc
videodec/libchromes/libchrome_tools/patch/logging.patch:3:--- a/base/logging.cc
videodec/libchromes/libchrome_tools/patch/logging.patch:4:+++ b/base/logging.cc
videodec/libchromes/libchrome_tools/patch/logging.patch:11: #include <android/log.h>
videodec/libchromes/libchrome_tools/patch/logging.patch:14:@@ -407,21 +407,23 @@ bool BaseInitLoggingImpl(const LoggingSettings& settings) {
videodec/libchromes/libchrome_tools/patch/logging.patch:15:   // Can log only to the system debug log.
videodec/libchromes/libchrome_tools/patch/logging.patch:16:   CHECK_EQ(settings.logging_dest & ~LOG_TO_SYSTEM_DEBUG_LOG, 0);
videodec/libchromes/libchrome_tools/patch/logging.patch:19:-  // Don't bother initializing |g_vlog_info| unless we use one of the
videodec/libchromes/libchrome_tools/patch/logging.patch:20:-  // vlog switches.
videodec/libchromes/libchrome_tools/patch/logging.patch:23:-    // NOTE: If |g_vlog_info| has already been initialized, it might be in use
videodec/libchromes/libchrome_tools/patch/logging.patch:24:-    // by another thread. Don't delete the old VLogInfo, just create a second
videodec/libchromes/libchrome_tools/patch/logging.patch:26:-    CHECK(!g_vlog_info_prev);
videodec/libchromes/libchrome_tools/patch/logging.patch:27:-    g_vlog_info_prev = g_vlog_info;
videodec/libchromes/libchrome_tools/patch/logging.patch:29:-    g_vlog_info =
videodec/libchromes/libchrome_tools/patch/logging.patch:30:-        new VlogInfo(command_line->GetSwitchValueASCII(switches::kV),
videodec/libchromes/libchrome_tools/patch/logging.patch:32:-                     &g_min_log_level);
videodec/libchromes/libchrome_tools/patch/logging.patch:35:+    // Don't bother initializing |g_vlog_info| unless we use one of the
videodec/libchromes/libchrome_tools/patch/logging.patch:36:+    // vlog switches.
videodec/libchromes/libchrome_tools/patch/logging.patch:39:+      // NOTE: If |g_vlog_info| has already been initialized, it might be in use
videodec/libchromes/libchrome_tools/patch/logging.patch:40:+      // by another thread. Don't delete the old VLogInfo, just create a second
videodec/libchromes/libchrome_tools/patch/logging.patch:42:+      CHECK(!g_vlog_info_prev);
videodec/libchromes/libchrome_tools/patch/logging.patch:43:+      g_vlog_info_prev = g_vlog_info;
videodec/libchromes/libchrome_tools/patch/logging.patch:45:+      g_vlog_info =
videodec/libchromes/libchrome_tools/patch/logging.patch:46:+          new VlogInfo(command_line->GetSwitchValueASCII(switches::kV),
videodec/libchromes/libchrome_tools/patch/logging.patch:48:+                       &g_min_log_level);
videodec/libchromes/libchrome_tools/patch/logging.patch:52:   g_logging_destination = settings.logging_dest;
videodec/libchromes/libchrome_tools/patch/logging.patch:53:@@ -755,7 +757,7 @@ LogMessage::~LogMessage() {
videodec/libchromes/libchrome_tools/patch/logging.patch:59:     android_LogPriority priority =
videodec/libchromes/libchrome_tools/patch/logging.patch:60:         (severity_ < 0) ? ANDROID_LOG_VERBOSE : ANDROID_LOG_UNKNOWN;
videodec/libchromes/libchrome_tools/patch/logging.patch:62:@@ -772,7 +774,16 @@ LogMessage::~LogMessage() {
videodec/libchromes/libchrome_tools/patch/logging.patch:63:         priority = ANDROID_LOG_FATAL;
videodec/libchromes/libchrome_tools/patch/logging.patch:67:     __android_log_write(priority, "chromium", str_newline.c_str());
videodec/libchromes/libchrome_tools/patch/logging.patch:69:+    __android_log_write(
videodec/libchromes/libchrome_tools/patch/shared_memory_mapping.patch:8: #include "base/logging.h"
videodec/libchromes/libchrome_tools/patch/shared_memory_mapping.patch:33:     DPLOG(ERROR) << "UnmapViewOfFile";
videodec/libchromes/libchrome_tools/patch/ThreadLocalStorage-Add-a-function-to-destroy-pthread.patch:14:Test: cheets_ContainerSmokeTest and cheets_LoginScreen
videodec/libchromes/libchrome_tools/patch/buildflag_header.patch:86:+#define BUILDFLAG_INTERNAL_IPC_MESSAGE_LOG_ENABLED() (0)
videodec/libchromes/Android.bp:93:    "base/debug/crash_logging.cc",
videodec/libchromes/Android.bp:130:    "base/logging.cc",
videodec/libchromes/Android.bp:257:    "base/vlog.cc",
videodec/libchromes/Android.bp:320:                "liblog",
videodec/libchromes/build/android/pylib/constants/__init__.py:13:import logging
videodec/libchromes/build/android/pylib/constants/__init__.py:172:    logging.warning(
videodec/libchromes/build/build_config.h:57:// OS_NACL comes in two sandboxing technology flavors, SFI or Non-SFI.
videodec/AmVideoDec.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/AmVideoDec.cpp:12://#define LOG_NDEBUG 0
videodec/AmVideoDec.cpp:13:#define LOG_TAG "AmVideoDec"
videodec/AmVideoDec.cpp:32:// #include <utils/Log.h>
videodec/AmVideoDec.cpp:33:#include <TspLogger.h>
videodec/AmVideoDec.cpp:35:#include <base/logging.h>
videodec/AmVideoDec.cpp:86:    VDLogGing::SetMinLogLevel(VDLogGing::LOG_VERBOSE);
videodec/AmVideoDec.cpp:87:    ALOGI("AmVideoDec version: %s %s, mHalInstanceID %d, mHalInstancenum %d, mIonFd%d\n",
videodec/AmVideoDec.cpp:95:    mLogLevel = 1;
videodec/AmVideoDec.cpp:96:    mLogFd = -1;
videodec/AmVideoDec.cpp:103:    VideoDec_propertyGetInt(PROPERTY_VIDEODEC_LOGlEVELS, PROPERTY_VIDEODEC_LOGlEVELS_OLD, (int*)&mLogLevel);
videodec/AmVideoDec.cpp:104:    if (mLogLevel & 1)
videodec/AmVideoDec.cpp:105:        mLogFd = open("/dev/dec_stat", O_RDWR | O_NONBLOCK | O_CLOEXEC);
videodec/AmVideoDec.cpp:109:    VideoDecLog(1, "new VideoDec\n");
videodec/AmVideoDec.cpp:113:    ALOGI("open dec_stat fd %d  mLowMem:%d\n", mLogFd, mLowMem);
videodec/AmVideoDec.cpp:126:    //    VideoDecLog(1, "~AmVideoDec vcodec_demux_tsync_deinit\n");
videodec/AmVideoDec.cpp:131:    VideoDecLog(1, "~AmVideoDec IN[%d:%d] OUT[%d:%d]\n",
videodec/AmVideoDec.cpp:135:    if (mLogFd >= 0)
videodec/AmVideoDec.cpp:136:        close(mLogFd);
videodec/AmVideoDec.cpp:152:    VideoDec_propertyGetInt(PROPERTY_VIDEODEC_PIPELINE, PROPERTY_VIDEODEC_PIPELINE, (int*)&mLogLevel);
videodec/AmVideoDec.cpp:196:            VideoDecLog(1, "[warning] config v4l2paras len:%d, but videodec v4l2paras len:%d", (int32_t)pramC2->v4l2cfg.len, int(sizeof(struct v4l2_parms) / sizeof(uint32_t)));
videodec/AmVideoDec.cpp:247:        VideoDecLog(1, "checkResource.-- mem size:%d--dim:%d  w:[%d]H[%d]\n",size, dim, width, height);
videodec/AmVideoDec.cpp:270:               VideoDecLog(2, "codecmm secureAvail %d noSecureAvail %d res_status.v.query.value %d\n", secureAvail,
videodec/AmVideoDec.cpp:278:                VideoDecLog(2, "codecmm secureAvail %d noSecureAvail %d adjust %d\n", secureAvail,
videodec/AmVideoDec.cpp:287:                VideoDecLog(2, " mStopQueryResource is true\n");
videodec/AmVideoDec.cpp:294:        VideoDecLog(1, "res_status.v.query.avail %d -mmsize: %d -adjust %d\n",res_status.v.query.avail, mmsize, adjust);
videodec/AmVideoDec.cpp:350:       ALOGE("Exception: %s initialize FAILED, mime is NULL.\n", __func__);
videodec/AmVideoDec.cpp:368:    VideoDecLog(1, "initialize mime %s secureMode is %d\n", mime, secureMode);
videodec/AmVideoDec.cpp:382:        ALOGE("error illegal parameters\n");
videodec/AmVideoDec.cpp:420:        ALOGE("insufficient resources\n");
videodec/AmVideoDec.cpp:441:        ALOGE("[%s] Do not support this format\n",__func__);
videodec/AmVideoDec.cpp:484:        ALOGE("Do not support this format %s\n", mime);
videodec/AmVideoDec.cpp:500:        VideoDecLog(1, "setWorkMode ok,Now Mode == Change Mode(%s)\n",
videodec/AmVideoDec.cpp:505:    VideoDecLog(1, "setWorkMode in,Now Work Mode:(%s)--->change work mode:(%s)",
videodec/AmVideoDec.cpp:512:        VideoDecLog(1, "setWorkMode Input InputDone [%d,%d,%d]",mInputQueueCount,mInputDoneCount,mInputQueueCount-mInputDoneCount);
videodec/AmVideoDec.cpp:572:    // VideoDecLog(1, "clearPendingEsData list size:%d, %d", mEsDataQueue.size(), __LINE__);
videodec/AmVideoDec.cpp:582:    // VideoDecLog(1, "clearPendingEsData list size:%d, %d", mEsDataQueue.size(), __LINE__);
videodec/AmVideoDec.cpp:607:        VideoDecLog(1, "Input full retry : In [%d-%d=%d], Out [%d-%d]\n",
videodec/AmVideoDec.cpp:641:            VideoDecLog(1, "Input full retry : In [%d-%d=%d], Out [%d-%d]\n",
videodec/AmVideoDec.cpp:670:                        VideoDecLog(1, "inpu frame info full, so release bitstreamId:%d", it->first);
videodec/AmVideoDec.cpp:684:                VideoDecLog(1, "Input full retry : In [%d-%d=%d], Out [%d-%d]\n",
videodec/AmVideoDec.cpp:702:                        // VideoDecLog(2, "mEsData NULL value\n");
videodec/AmVideoDec.cpp:707:                        VideoDecLog(1, "mEsData->size == 0 \n");
videodec/AmVideoDec.cpp:725:                    VideoDecLog(2, "workmode:%d, loop decode pts:%lld, size:%d, queue.size:%d\n", mVideoWorkMode, (long long)mEsData->pts, mEsData->size, (int)mVideoEsDataQueue.size());
videodec/AmVideoDec.cpp:766:                VideoDecLog(2, "cache mode:%d, decode pts:%lld, bytesUsed:%d\n", mVideoWorkMode, (long long)timestamp, bytesUsed);
videodec/AmVideoDec.cpp:796:            // VideoDecLog(2, "mDurationUs:%lld, videoCacheDurationUs:%lld", mDurationUs, videoCacheDurationUs);
videodec/AmVideoDec.cpp:804:                    VideoDecLog(2, "%s:%d: workmode:%d, tmpEsData->pts:%lld,mLastPtsUs:%lld,mDurationUs:%lld\n",
videodec/AmVideoDec.cpp:820:    VideoDecLog(1, "setupOutputBufferNum %d\n", numOutputBuffers);
videodec/AmVideoDec.cpp:822:        VideoDecLog(1, "setupOutputBufferNum error, max is 64\n");
videodec/AmVideoDec.cpp:826:        VideoDecLog(1, "setupOutputBufferNum error, mVDAAdaptor is null\n");
videodec/AmVideoDec.cpp:881:    VideoDecLog(1, "buf %p, yaddr %lld, uvaddr %lld, ysize %zd, uvsize %zd\n",
videodec/AmVideoDec.cpp:899:        VideoDecLog(1, "queueOutputBuffer pictureBufferId %d mNumOutputBuffers %d invalid\n",
videodec/AmVideoDec.cpp:920:    VideoDecLog(1, "flush\n");
videodec/AmVideoDec.cpp:935:    VideoDecLog(1, "reset\n");
videodec/AmVideoDec.cpp:964:        ALOGE("sendCommand mVDAAdaptor null index %d\n", index);
videodec/AmVideoDec.cpp:991:        ALOGW("AmVideoDec::postAndReplyMsg, mVDAAdaptor == NULL");
videodec/AmVideoDec.cpp:1033:        VideoDecLog(1, "ion open fd %d\n", mIonFd);
videodec/AmVideoDec.cpp:1035:            ALOGE("ion open failed!\n");
videodec/AmVideoDec.cpp:1054:            VideoDecLog(4, "query heaps ret %d\n", ret);
videodec/AmVideoDec.cpp:1058:                    VideoDecLog(4, "%d, m=%x, 1<<heap_id=%x, heap_mask=%x, name=%s\n",
videodec/AmVideoDec.cpp:1065:    VideoDecLog(4, "ion_query_heap_cnt ret %d, heap_cnt %d\n", ret, num_heaps);
videodec/AmVideoDec.cpp:1068:        ALOGE("ion alloc error ret %d\n", ret);
videodec/AmVideoDec.cpp:1075:        ALOGE("ion mmap error!\n");
videodec/AmVideoDec.cpp:1084:    VideoDecLog(1, "allocIonBuffer shared_fd=%d, mIonFd=%d, fd_ptr=%p, fd=%d\n",
videodec/AmVideoDec.cpp:1092:        ALOGE("freeIonBuffer failed, mIonFd %d, mIonBuf size %d\n",
videodec/AmVideoDec.cpp:1102:        ALOGE("freeIonBuffer failed: mapaddr %p", (void*)mapaddr);
videodec/AmVideoDec.cpp:1110:        VideoDecLog(1, "All ion buffer freed, close ion device\n");
videodec/AmVideoDec.cpp:1119:        //ALOGE("freeIonBuffer failed, mIonFd %d, mIonBuf size %d\n",
videodec/AmVideoDec.cpp:1131:    VideoDecLog(1, "freeAllIonBuffer\n");
videodec/AmVideoDec.cpp:1138:        ALOGE("is over mOutputBufferNum");
videodec/AmVideoDec.cpp:1159:        ALOGE("mmap error!\n");
videodec/AmVideoDec.cpp:1169:    VideoDecLog(1, "allocUvmBuffer shared_fd=%d, mDmaFd=%d, fd_ptr=%p, fd=%d\n",
videodec/AmVideoDec.cpp:1191:    VideoDecLog(1, "freeAllUvmBuffer\n");
videodec/AmVideoDec.cpp:1251:        VideoDecLog(4, "pictureid %d bitstreamid%d not recorded, ignore", pictureBufferId, bitstreamId);
videodec/AmVideoDec.cpp:1275:        VideoDecLog(4, "pictureReady bps %lld, fps %2.1f, evg_bps %lld, evg_fps %2.1f\n",
videodec/AmVideoDec.cpp:1280:    VideoDecLog(4, "READY ID %4d, size %8lld, \t [ID-IQ=%8lld, OD-IQ=%8lld, IQDelta=%8lld],"
videodec/AmVideoDec.cpp:1317:    //ALOGI("pictureReady bitstreamId %lld\n", bitstreamId);
videodec/AmVideoDec.cpp:1347:    VideoDecLog(4, "userdataReady size %d\n", (int)userdata.size());
videodec/AmVideoDec.cpp:1353:    VideoDecLog(4, "updateInfo size %d\n",(int)decinfo.size());
videodec/AmVideoDec.cpp:1361:    VideoDecLog(4, "NotifyEndOfBitstreamBuffer bitstreamId: %d\n",(int)bitstreamId);
videodec/AmVideoDec.cpp:1378:    VideoDecLog(4, "notifyInputBufferInfo bitstreamId: %d\n",(int)bitstreamId);
videodec/AmVideoDec.cpp:1384:    VideoDecLog(1, "notifyFlushDone\n");
videodec/AmVideoDec.cpp:1390:    VideoDecLog(1, "notifyResetDone\n");
videodec/AmVideoDec.cpp:1434:            ALOGI("open /sys/class/amstream/vcodec_feature fail.(%s)",strerror(errno));
videodec/AmVideoDec.cpp:1459:        ALOGI("open /sys/class/amstream/vcodec_feature fail.(%s)",strerror(errno));
videodec/AmVideoDec.cpp:1508:        ALOGI("open /sys/class/amstream/video_max_src fail.(%s)", strerror(errno));
videodec/AmVideoDec.cpp:1514:    //ALOGI("video_max_src %s \n",bcmd);
videodec/AmVideoDec.cpp:1543:                ALOGI("error type:%d \n",type);
videodec/Android.bp:113:        "liblog",
videodec/Android.bp:125:        "-DGOOGLE_STRIP_VLOG_LEVEL=2",
videodec/Android.bp:166:       "libmediahal_tsplogger_headers",
videodec/Android.bp:241:        "liblog",
videodec/Android.bp:253:        "-DGOOGLE_STRIP_VLOG_LEVEL=2",
videodec/Android.bp:294:        "libmediahal_tsplogger_headers",
videodec/Android.bp:362:        "liblog",
videodec/Android.bp:411:        "libmediahal_tsplogger_headers",
videodec/wrapper/BufferPoolWrapper.cpp:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videodec/wrapper/BufferPoolWrapper.cpp:9:#define LOG_NDEBUG 0
videodec/wrapper/BufferPoolWrapper.cpp:10:#define LOG_TAG "BufferPoolWrapper"
videodec/wrapper/BufferPoolWrapper.cpp:19:#include <utils/Log.h>
videodec/wrapper/BufferPoolWrapper.cpp:22:#include "log_debug.h"
videodec/wrapper/BufferPoolWrapper.cpp:30:#define BFWLog(level, f, s...) VDLog(level, "[%d]"#f, mCurInstNum, ##s)
videodec/wrapper/BufferPoolWrapper.cpp:55:        ALOGI("so have load");
videodec/wrapper/BufferPoolWrapper.cpp:67:        ALOGE("unable to find dmabufmanage_support:%s", dlerror());
videodec/wrapper/BufferPoolWrapper.cpp:77:        ALOGE("unable to find dmabufmanage_init:%s", dlerror());
videodec/wrapper/BufferPoolWrapper.cpp:84:        ALOGE("unable to find dmabufmanage_uninit:%s", dlerror());
videodec/wrapper/BufferPoolWrapper.cpp:91:        ALOGE("unable to find dmabufmanage_allocDmabuf:%s", dlerror());
videodec/wrapper/BufferPoolWrapper.cpp:98:        ALOGE("unable to find dmabufmanage_getPaddr:%s", dlerror());
videodec/wrapper/BufferPoolWrapper.cpp:105:        ALOGE("unable to find dmabufmanage_exportByInfo:%s", dlerror());
videodec/wrapper/BufferPoolWrapper.cpp:134:            BFWLog(LOG_INFO, "pageshift:%d", mPageShift);
videodec/wrapper/BufferPoolWrapper.cpp:149:        BFWLog(LOG_ERR, "can not get handle!, please check");
videodec/wrapper/BufferPoolWrapper.cpp:163:    BFWLog(LOG_INFO, "BufferPoolWrapper use dmabuf manager version %d", mDmabufManagerVersion);
videodec/wrapper/BufferPoolWrapper.cpp:168:    VideoDec_propertyGetInt(PROPERTY_VIDEODEC_BUFFERPOOL_LOGLEVELS, NULL, (int*)&gloglevel);
videodec/wrapper/BufferPoolWrapper.cpp:169:    BFWLog(LOG_INFO, "%s:%d", __func__, __LINE__);
videodec/wrapper/BufferPoolWrapper.cpp:176:      BFWLog(LOG_INFO, "free bufferpool region memory");
videodec/wrapper/BufferPoolWrapper.cpp:183:    BFWLog(LOG_INFO, "%s:%d", __func__, __LINE__);
videodec/wrapper/BufferPoolWrapper.cpp:190:        BFWLog(LOG_ERR, "bufferpool or handle init failed, please check first");
videodec/wrapper/BufferPoolWrapper.cpp:209:    BFWLog(LOG_INFO, "%s:%d fd:%d phyadr:0x%llx size:%x(%x)", __func__, __LINE__, mBufPoolRegion.fd,
videodec/wrapper/BufferPoolWrapper.cpp:219:        BFWLog(LOG_ERR, "bufferpool or handle init failed, please check first");
videodec/wrapper/BufferPoolWrapper.cpp:223:        BFWLog(LOG_ERR, "%s:%d cannot alloc buffer %d, need retry", __func__, __LINE__, size);
videodec/wrapper/BufferPoolWrapper.cpp:333:    BFWLog(LOG_DEBUG_LEVEL2, "%s:%d alloc fd:%d, size:%d, paddr:[0x%llx~0x%llx,%d], vir:%p",
videodec/wrapper/BufferPoolWrapper.cpp:345:        BFWLog(LOG_ERR, "bufferpool or handle init failed, please check first");
videodec/wrapper/BufferPoolWrapper.cpp:353:    BFWLog(LOG_DEBUG_LEVEL2, "%s:%d free fd %d, phyaddr:0x%llx, size:%d",
videodec/wrapper/BufferPoolWrapper.cpp:360:        BFWLog(LOG_ERR, "bufferpool or handle init failed, please check first");
videodec/wrapper/BufferPoolWrapper.cpp:365:        BFWLog(LOG_DEBUG_LEVEL2, "%s:%d free fd %d", __func__, __LINE__, iter->second.fd);
videodec/wrapper/include/BufferPoolWrapper.h:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videodec/wrapper/include/SecureVdecPool.h:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videodec/wrapper/SecureVdecPool.cpp:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videodec/wrapper/SecureVdecPool.cpp:10://#define LOG_NDEBUG 0
videodec/wrapper/SecureVdecPool.cpp:11:#define LOG_TAG "SecureVdecPool"
videodec/wrapper/SecureVdecPool.cpp:14:#include <utils/Log.h>
videodec/wrapper/SecureVdecPool.cpp:49:        ALOGE("Failed to load library: libsecmem.so (%s)", dlerror());
videodec/wrapper/SecureVdecPool.cpp:106:                        ALOGI("Secmem change to V2 %d %x", enforcement, ret);
videodec/wrapper/SecureVdecPool.cpp:111:                    ALOGI("Secmem V3 session create fail change to v2");
videodec/wrapper/SecureVdecPool.cpp:115:                ALOGI("Secmem V3 miss syms change to v2");
videodec/wrapper/SecureVdecPool.cpp:145:            ALOGE("Invalid mSecmemVersion is %d", mSecmemVersion);
videodec/wrapper/SecureVdecPool.cpp:183:    ALOGI("Create SecmemVersion %d Secmem Session is %p mTvpMultiSegment is %d ",
videodec/wrapper/SecureVdecPool.cpp:210:                    ALOGE("Failed to destroy secure pool 0x%x", ret);
videodec/wrapper/SecureVdecPool.cpp:216:                ALOGE("Failed to release secmem resource 0x%x", ret);
videodec/wrapper/SecureVdecPool.cpp:232:                    ALOGE("Failed to destroy secure pool 0x%x", ret);
videodec/wrapper/SecureVdecPool.cpp:238:                ALOGE("Failed to release secmem resource 0x%x", ret);
videodec/wrapper/SecureVdecPool.cpp:293:        ALOGI("TP_VDA_Start_Tvp %" PRId64, systemTime(SYSTEM_TIME_MONOTONIC));
videodec/wrapper/SecureVdecPool.cpp:296:            ALOGE("Failed to enable tvp %x", ret);
videodec/wrapper/SecureVdecPool.cpp:297:        ALOGI("TP_VDA_End_Tvp %" PRId64, systemTime(SYSTEM_TIME_MONOTONIC));
videodec/wrapper/SecureVdecPool.cpp:309:        ALOGE("Failed to enable tvp async %x", ret);
videodec/wrapper/SecureVdecPool.cpp:441:        ALOGE("Failed to init secure channel 0x%x", ret);
videodec/wrapper/SecureVdecPool.cpp:521:        ALOGE("Invalid mode handle");
videodec/wrapper/SecureVdecPool.cpp:529:            ALOGE("Failed to mmap error");
videodec/wrapper/SecureVdecPool.cpp:547:                ALOGI("Please update secure library");
videodec/wrapper/SecureVdecPool.cpp:557:                ALOGI("Failed get secure space information");
videodec/wrapper/SecureVdecPool.cpp:563:                ALOGI("Please update secure library");
videodec/wrapper/SecureVdecPool.cpp:573:                ALOGI("Failed get secure space information");
videodec/wrapper/SecureVdecPool.cpp:582:        ALOGI("Please check the input buffer count %d %d %d",
videodec/wrapper/SecureVdecPool.cpp:615:                ALOGE("Failed to flush vdec pool");
videodec/wrapper/SecureVdecPool.cpp:623:                ALOGE("Failed to flush vdec pool");
videodec/lcevc/lcevc_processor.h:60:    void LogCallback(const char* msg, size_t len, LCEVC_LogLevel logLevel);
videodec/lcevc/lcevc_processor.h:142:                                            LCEVC_LogCallback logCallback, LCEVC_LogLevel logLevel,
videodec/lcevc/lcevc_processor.h:143:                                            void* logUserData, LCEVC_DecoderHandle* decoder);
videodec/lcevc/lcevc_processor.h:235:                            LCEVC_LogCallback logCallback, LCEVC_LogLevel logLevel,
videodec/lcevc/lcevc_processor.h:236:                            void* logUserData, LCEVC_DecoderHandle* decoder);
videodec/lcevc/lcevc_processor.cc:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/lcevc/lcevc_processor.cc:12://#define LOG_NDEBUG 0
videodec/lcevc/lcevc_processor.cc:13:#define LOG_TAG "LCEVC"
videodec/lcevc/lcevc_processor.cc:33:#include <utils/Log.h>
videodec/lcevc/lcevc_processor.cc:34:#include <base/logging.h>
videodec/lcevc/lcevc_processor.cc:39:#include "log_debug.h"
videodec/lcevc/lcevc_processor.cc:47:#define LCEVC_LOG(level, f, s...) VDLog(level, "[%d#] " f, mInstanceNum, ##s)
videodec/lcevc/lcevc_processor.cc:90:static void lcevcLogCallback(void* userData, const char* msg, size_t len, LCEVC_LogLevel logLevel) {
videodec/lcevc/lcevc_processor.cc:92:        ((LcevcProcessor *)userData)->LogCallback(msg, len, logLevel);
videodec/lcevc/lcevc_processor.cc:106:    ALOGI("releaseUserdataCallbackFunction decoder %p, PTS %" PRId64 ", userdata %p", lcevcDecoder,
videodec/lcevc/lcevc_processor.cc:121:    VideoDec_propertyGetInt(PROPERTY_VIDEODEC_LCEVC_LOGlEVELS,
videodec/lcevc/lcevc_processor.cc:122:        PROPERTY_VIDEODEC_LCEVC_LOGlEVELS, (int*)&gloglevel);
videodec/lcevc/lcevc_processor.cc:123:    LCEVC_LOG(LOG_INFO, "[%s instance %d]", __FUNCTION__, mInstanceNum);
videodec/lcevc/lcevc_processor.cc:148:    mEsBufferPool = std::make_shared<LcevcEsBufferPool>(mInstanceNum, gloglevel);
videodec/lcevc/lcevc_processor.cc:149:    mLcevcBufferPool = std::make_shared<LcevcBufferPool>(mInstanceNum, gloglevel);
videodec/lcevc/lcevc_processor.cc:153:    LCEVC_LOG(LOG_INFO, "[%s instance %d]", __FUNCTION__, mInstanceNum);
videodec/lcevc/lcevc_processor.cc:166:    LCEVC_LOG(LOG_INFO, "[%s]", __FUNCTION__);
videodec/lcevc/lcevc_processor.cc:168:        LCEVC_LOG(LOG_ERR, "[%s] Error: %s is NULL object!", __FUNCTION__,
videodec/lcevc/lcevc_processor.cc:197:    LCEVC_LOG(LOG_INFO, "[%s] mResidualPacking %d", __FUNCTION__, mResidualPacking);
videodec/lcevc/lcevc_processor.cc:204:        LCEVC_LOG(LOG_ERR, "[%s] can not open uvm", __FUNCTION__);
videodec/lcevc/lcevc_processor.cc:207:        LCEVC_LOG(LOG_INFO, "[%s] open uvm", __FUNCTION__);
videodec/lcevc/lcevc_processor.cc:223:    LCEVC_LOG(LOG_DEBUG_LEVEL2, "[%s] bitStreamId = %d, timestamp = %lld",
videodec/lcevc/lcevc_processor.cc:228:        LCEVC_LOG(LOG_ERR,
videodec/lcevc/lcevc_processor.cc:255:        LCEVC_LOG(LOG_ERR, "[%s] malloc failed", __FUNCTION__);
videodec/lcevc/lcevc_processor.cc:275:        LCEVC_LOG(LOG_ERR, "[%s] not found match bitstream_id %d",
videodec/lcevc/lcevc_processor.cc:289:        LCEVC_LOG(LOG_ERR, "[%s] Error: %s is NULL object!", __FUNCTION__,
videodec/lcevc/lcevc_processor.cc:294:    LCEVC_LOG(LOG_DEBUG_LEVEL2,
videodec/lcevc/lcevc_processor.cc:300:        LCEVC_LOG(LOG_ERR, "[%s] bitstream_id = %d failed.", __FUNCTION__, bitstream_id);
videodec/lcevc/lcevc_processor.cc:309:        LCEVC_LOG(LOG_ERR, "[%s] Error: %s is NULL object!", __FUNCTION__,
videodec/lcevc/lcevc_processor.cc:316:        LCEVC_LOG(LOG_ERR,
videodec/lcevc/lcevc_processor.cc:322:    LCEVC_LOG(LOG_DEBUG_LEVEL2, "[%s] bitstream_id = %d, hw_dma_fd = %d",
videodec/lcevc/lcevc_processor.cc:355:        LCEVC_LOG(LOG_ERR, "[%s] Attach failed, uvm_setinfo return %d, bitstream_id = %d",
videodec/lcevc/lcevc_processor.cc:367:        LCEVC_LOG(LOG_ERR, "[%s] Error: %s is NULL object!", __FUNCTION__,
videodec/lcevc/lcevc_processor.cc:375:        LCEVC_LOG(LOG_INFO, "[%s] [fd=%d] is new base DMABUFFER",
videodec/lcevc/lcevc_processor.cc:380:        LCEVC_LOG(LOG_ERR,
videodec/lcevc/lcevc_processor.cc:386:    LCEVC_LOG(LOG_DEBUG_LEVEL2, "[%s] fd = %d, index = %d, bitstream_id = %d",
videodec/lcevc/lcevc_processor.cc:401:    LCEVC_LOG(LOG_INFO, "[%s]", __FUNCTION__);
videodec/lcevc/lcevc_processor.cc:403:        LCEVC_LOG(LOG_ERR, "[%s] Error: %s is NULL object!", __FUNCTION__,
videodec/lcevc/lcevc_processor.cc:419:    LCEVC_LOG(LOG_INFO, "[%s]", __FUNCTION__);
videodec/lcevc/lcevc_processor.cc:499:    LCEVC_LOG(LOG_INFO, "[%s] Done", __FUNCTION__);
videodec/lcevc/lcevc_processor.cc:519:                                        LCEVC_LogCallback logCallback, LCEVC_LogLevel logLevel,
videodec/lcevc/lcevc_processor.cc:520:                                        void* logUserData, LCEVC_DecoderHandle* decoder) {
videodec/lcevc/lcevc_processor.cc:525:                                logCallback, logLevel, logUserData, decoder);
videodec/lcevc/lcevc_processor.cc:771:            LCEVC_LOG(LOG_ERR, "No lcevc DVP library!");
videodec/lcevc/lcevc_processor.cc:918:    LCEVC_LOG(LOG_INFO, "Load lcevc DVP OK!");
videodec/lcevc/lcevc_processor.cc:923:    LCEVC_LOG(LOG_ERR, "dlsym %s failed", symbol);
videodec/lcevc/lcevc_processor.cc:941:            LCEVC_LOG(LOG_ERR, "No lcevc extractor library!");
videodec/lcevc/lcevc_processor.cc:953:    LCEVC_LOG(LOG_INFO, "Load lcevc extractor OK!");
videodec/lcevc/lcevc_processor.cc:958:    LCEVC_LOG(LOG_ERR, "dlsym %s failed", symbol);
videodec/lcevc/lcevc_processor.cc:974:    ret = _LCEVC_CreateDecoder(lcevcLogCallback, LCEVC_LogLevel_Info, (void *)this, &mLcevcDecoderHandler);
videodec/lcevc/lcevc_processor.cc:976:        LCEVC_LOG(LOG_ERR, "Failed to create LCEVC decoder instance: %d", ret);
videodec/lcevc/lcevc_processor.cc:1041:        LCEVC_LOG(LOG_ERR, "LCEVC_InitializeDecoder failed: %d", ret);
videodec/lcevc/lcevc_processor.cc:1045:    LCEVC_LOG(LOG_INFO, "InitializeLcevcDecoder done");
videodec/lcevc/lcevc_processor.cc:1051:    LCEVC_LOG(LOG_ERR, "Failed to config %s, ret = %d", configName, ret);
videodec/lcevc/lcevc_processor.cc:1064:            LCEVC_LOG(LOG_ERR, "softwareUnpack: Input buffer too small,"
videodec/lcevc/lcevc_processor.cc:1070:            LCEVC_LOG(LOG_ERR, "softwareUnpack: Output buffer too small,"
videodec/lcevc/lcevc_processor.cc:1117:            LCEVC_LOG(LOG_ERR,
videodec/lcevc/lcevc_processor.cc:1138:            LCEVC_LOG(LOG_ERR, "Failed to open file <%s>: %s",
videodec/lcevc/lcevc_processor.cc:1185:    LCEVC_LOG(LOG_INFO, "dumpBuffer len = %zu written = %d", len, written);
videodec/lcevc/lcevc_processor.cc:1202:        LCEVC_LOG(LOG_ERR,
videodec/lcevc/lcevc_processor.cc:1217:        LCEVC_LOG(LOG_ERR,
videodec/lcevc/lcevc_processor.cc:1247:        LCEVC_LOG(LOG_ERR, "[%s] malloc failed for userData", __FUNCTION__);
videodec/lcevc/lcevc_processor.cc:1256:    LCEVC_LOG(LOG_DEBUG_LEVEL2,
videodec/lcevc/lcevc_processor.cc:1296:        //ALOGD("bitstream_id = %d, Found LCEVC data size %zu", bitstream_id, pktDataSize);
videodec/lcevc/lcevc_processor.cc:1299:        LCEVC_LOG(LOG_DEBUG_LEVEL2,
videodec/lcevc/lcevc_processor.cc:1313:    LCEVC_LOG(LOG_DEBUG_LEVEL2, "[%s] timestamp = %lld, userData = %p",
videodec/lcevc/lcevc_processor.cc:1320:            LCEVC_LOG(LOG_ERR, "[%s] malloc LCEVC_CommandBuffer failed", __FUNCTION__);
videodec/lcevc/lcevc_processor.cc:1349:    LCEVC_LOG(LOG_INFO, "[%s]", __FUNCTION__);
videodec/lcevc/lcevc_processor.cc:1357:            LCEVC_LOG(LOG_INFO, "[%s] flush commandBuffers timestamp = %lld free userData %p",
videodec/lcevc/lcevc_processor.cc:1368:        LCEVC_LOG(LOG_ERR, "[%s] LCEVC_Flush failed", __FUNCTION__);
videodec/lcevc/lcevc_processor.cc:1414:            LCEVC_LOG(LOG_INFO, "Kernel length %zu : ", kernel.len);
videodec/lcevc/lcevc_processor.cc:1416:                LCEVC_LOG(LOG_INFO, "[%d]:%d %d,", i, kernel.k[0][i], kernel.k[1][i]);
videodec/lcevc/lcevc_processor.cc:1427:            LCEVC_LOG(LOG_ERR, "[%s] LCEVC_StartResidualExtract failed, ret = %d",
videodec/lcevc/lcevc_processor.cc:1435:            LCEVC_LOG(LOG_ERR, "[%s] LCEVC_FinishResidualExtract failed, ret = %d",
videodec/lcevc/lcevc_processor.cc:1441:        ALOGE("commandBufferState timestamp = %lld no lcevc data, skip it",
videodec/lcevc/lcevc_processor.cc:1450:            LCEVC_LOG(LOG_INFO,
videodec/lcevc/lcevc_processor.cc:1462:                LCEVC_LOG(LOG_INFO,
videodec/lcevc/lcevc_processor.cc:1492:                    LCEVC_LOG(LOG_ERR, "[%s] GetBufferFree is null", __FUNCTION__);
videodec/lcevc/lcevc_processor.cc:1504:        LCEVC_LOG(LOG_ERR, "[%s] commandBufferState userData is NULL", __FUNCTION__);
videodec/lcevc/lcevc_processor.cc:1518:        LCEVC_LOG(LOG_ERR, "[%s] LCEVC_StartResidualExtract failed, ret = %d",
videodec/lcevc/lcevc_processor.cc:1528:        LCEVC_LOG(LOG_ERR, "[%s] LCEVC_FinishResidualExtract failed, ret = %d",
videodec/lcevc/lcevc_processor.cc:1535:    LCEVC_LOG(LOG_DEBUG_LEVEL2,
videodec/lcevc/lcevc_processor.cc:1559:        LCEVC_LOG(LOG_DEBUG_LEVEL1,
videodec/lcevc/lcevc_processor.cc:1563:        LCEVC_LOG(LOG_DEBUG_LEVEL2,
videodec/lcevc/lcevc_processor.cc:1578:    LCEVC_LOG(LOG_INFO, "LcevcEnhancementDataTaskEntry");
videodec/lcevc/lcevc_processor.cc:1591:                        LCEVC_LOG(LOG_DEBUG_LEVEL2,
videodec/lcevc/lcevc_processor.cc:1596:                        LCEVC_LOG(LOG_ERR, "handleLcevcData failed, es_bitstream_id = %d ret = %d",
videodec/lcevc/lcevc_processor.cc:1608:                LCEVC_LOG(LOG_INFO, "LCEVC SignalEOS");
videodec/lcevc/lcevc_processor.cc:1614:    LCEVC_LOG(LOG_INFO, "LcevcEnhancementDataTaskEntry exit");
videodec/lcevc/lcevc_processor.cc:1622:    LCEVC_LOG(LOG_INFO, "LcevcDecodeTaskEntry in");
videodec/lcevc/lcevc_processor.cc:1634:                LCEVC_LOG(LOG_ERR, "doFlush failed");
videodec/lcevc/lcevc_processor.cc:1646:            LCEVC_LOG(LOG_INFO, "LcevcDecodeTask waiting");
videodec/lcevc/lcevc_processor.cc:1648:            LCEVC_LOG(LOG_INFO, "LcevcDecodeTask wait done");
videodec/lcevc/lcevc_processor.cc:1662:                LCEVC_LOG(LOG_ERR, "commandBufferState userData is NULL");
videodec/lcevc/lcevc_processor.cc:1673:                    LCEVC_LOG(LOG_DEBUG_LEVEL1, "receiveCmdBuffer ret %d", ret);
videodec/lcevc/lcevc_processor.cc:1683:                LCEVC_LOG(LOG_INFO, "Saw output EOS");
videodec/lcevc/lcevc_processor.cc:1690:                LCEVC_LOG(LOG_DEBUG_LEVEL1, "no available commandBuffer, continue");
videodec/lcevc/lcevc_processor.cc:1692:                    LCEVC_LOG(LOG_ERR, "no available commandBuffer after retry %d times",
videodec/lcevc/lcevc_processor.cc:1703:                LCEVC_LOG(LOG_ERR, "commandBufferState userData is NULL");
videodec/lcevc/lcevc_processor.cc:1717:            LCEVC_LOG(LOG_ERR, "uvm_buffer is NULL, continue");
videodec/lcevc/lcevc_processor.cc:1747:    LCEVC_LOG(LOG_INFO, "LcevcDecodeTaskEntry exit");
videodec/lcevc/lcevc_processor.cc:1750:void LcevcProcessor::LogCallback(const char* msg, size_t len, LCEVC_LogLevel logLevel) {
videodec/lcevc/lcevc_processor.cc:1751:    if (logLevel == LCEVC_LogLevel_Error) {
videodec/lcevc/lcevc_processor.cc:1752:        LCEVC_LOG(LOG_ERR, "[LCEVC_SDK] %s", msg);
videodec/lcevc/lcevc_processor.cc:1753:    } else if (logLevel == LCEVC_LogLevel_Warning) {
videodec/lcevc/lcevc_processor.cc:1754:        LCEVC_LOG(LOG_INFO, "[LCEVC_SDK] %s", msg);
videodec/lcevc/lcevc_processor.cc:1755:    } else if (logLevel == LCEVC_LogLevel_Debug) {
videodec/lcevc/lcevc_processor.cc:1756:        LCEVC_LOG(LOG_INFO, "[LCEVC_SDK] %s", msg);
videodec/lcevc/lcevc_processor.cc:1757:    } else if (logLevel == LCEVC_LogLevel_Info) {
videodec/lcevc/lcevc_processor.cc:1758:        LCEVC_LOG(LOG_INFO, "[LCEVC_SDK] %s", msg);
videodec/lcevc/lcevc_processor.cc:1760:        LCEVC_LOG(LOG_DEBUG_LEVEL2, "[LCEVC_SDK] %s", msg);
videodec/lcevc/lcevc_processor.cc:1766:    //LCEVC_LOG(LOG_INFO, "DVPCallback type = %d timeHandle = %lld", callbackType, (long long)timehandle);
videodec/lcevc/lcevc_uvm_bufferpool.cc:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/lcevc/lcevc_uvm_bufferpool.cc:12://#define LOG_NDEBUG 0
videodec/lcevc/lcevc_uvm_bufferpool.cc:13:#define LOG_TAG "LCEVC"
videodec/lcevc/lcevc_uvm_bufferpool.cc:18:#include <utils/Log.h>
videodec/lcevc/lcevc_uvm_bufferpool.cc:26:#include <amlogic/am_gralloc_ext.h>
videodec/lcevc/lcevc_uvm_bufferpool.cc:30:#include <base/logging.h>
videodec/lcevc/lcevc_uvm_bufferpool.cc:34:#include "log_debug.h"
videodec/lcevc/lcevc_uvm_bufferpool.cc:36:#define LCEVC_LOG(level, f, s...) VDLog(level, "[%d#] " f, mInstanceNum, ##s)
videodec/lcevc/lcevc_uvm_bufferpool.cc:60:LcevcBufferPool::LcevcBufferPool(int32_t instance, uint32_t loglevel) {
videodec/lcevc/lcevc_uvm_bufferpool.cc:62:    gloglevel = loglevel;
videodec/lcevc/lcevc_uvm_bufferpool.cc:63:    LCEVC_LOG(LOG_INFO, "[%s instance %d]", __FUNCTION__, mInstanceNum);
videodec/lcevc/lcevc_uvm_bufferpool.cc:81:    LCEVC_LOG(LOG_INFO, "[%s instance %d]", __FUNCTION__, mInstanceNum);
videodec/lcevc/lcevc_uvm_bufferpool.cc:100:    LCEVC_LOG(LOG_INFO,
videodec/lcevc/lcevc_uvm_bufferpool.cc:123:                LCEVC_LOG(LOG_ERR,
videodec/lcevc/lcevc_uvm_bufferpool.cc:136:        LCEVC_LOG(LOG_ERR, "[LcevcBufferPool::%s] Invalid index = %d",
videodec/lcevc/lcevc_uvm_bufferpool.cc:159:    LCEVC_LOG(LOG_ERR,
videodec/lcevc/lcevc_uvm_bufferpool.cc:170:            LCEVC_LOG(LOG_DEBUG_LEVEL2, "[LcevcBufferPool::%s-%d] Wait free buffer",
videodec/lcevc/lcevc_uvm_bufferpool.cc:173:            LCEVC_LOG(LOG_DEBUG_LEVEL2, "[LcevcBufferPool::%s-%d] Wait free buffer done",
videodec/lcevc/lcevc_uvm_bufferpool.cc:176:            LCEVC_LOG(LOG_INFO,
videodec/lcevc/lcevc_uvm_bufferpool.cc:196:                LCEVC_LOG(LOG_DEBUG_LEVEL2, "[LcevcBufferPool::%s-%d] Wait free buffer",
videodec/lcevc/lcevc_uvm_bufferpool.cc:199:                LCEVC_LOG(LOG_DEBUG_LEVEL2, "[LcevcBufferPool::%s-%d] Wait free buffer done",
videodec/lcevc/lcevc_uvm_bufferpool.cc:217:                LCEVC_LOG(LOG_INFO,
videodec/lcevc/lcevc_uvm_bufferpool.cc:222:                    LCEVC_LOG(LOG_ERR, "[LcevcBufferPool::%s] realloc dma buffer failed",
videodec/lcevc/lcevc_uvm_bufferpool.cc:233:    LCEVC_LOG(LOG_ERR, "[LcevcBufferPool::%s] Failed to get buffer",
videodec/lcevc/lcevc_uvm_bufferpool.cc:253:        LCEVC_LOG(LOG_ERR, "[LcevcBufferPool::%s] bitstreamid %d decode failed",
videodec/lcevc/lcevc_uvm_bufferpool.cc:324:    LCEVC_LOG(LOG_INFO,
videodec/lcevc/lcevc_uvm_bufferpool.cc:338:        LCEVC_LOG(LOG_ERR, "[LcevcBufferPool::%s] alloc buffer failed", __FUNCTION__);
videodec/lcevc/lcevc_uvm_bufferpool.cc:345:            LCEVC_LOG(LOG_ERR, "[LcevcBufferPool::%s] get fd fail", __FUNCTION__);
videodec/lcevc/lcevc_uvm_bufferpool.cc:353:            LCEVC_LOG(LOG_ERR,
videodec/lcevc/lcevc_uvm_bufferpool.cc:368:    LCEVC_LOG(LOG_INFO,
videodec/lcevc/lcevc_uvm_bufferpool.cc:380:    LCEVC_LOG(LOG_INFO, "[LcevcBufferPool::%s] dma_fd = %d cpu_ptr = %p",
videodec/lcevc/lcevc_uvm_bufferpool.cc:407:        LCEVC_LOG(LOG_ERR, "[LcevcBufferPool::%s] UVM_IMM_ALLOC failed : %d",
videodec/lcevc/lcevc_uvm_bufferpool.cc:415:        LCEVC_LOG(LOG_ERR,
videodec/lcevc/lcevc_uvm_bufferpool.cc:423:    LCEVC_LOG(LOG_INFO,
videodec/lcevc/lcevc_uvm_bufferpool.cc:434:    LCEVC_LOG(LOG_INFO,
videodec/lcevc/lcevc_uvm_bufferpool.cc:452:    LCEVC_LOG(LOG_INFO, "[LcevcBufferPool::%s]", __FUNCTION__);
videodec/lcevc/lcevc_uvm_bufferpool.cc:458:LcevcEsBufferPool::LcevcEsBufferPool(int32_t instance, uint32_t loglevel) {
videodec/lcevc/lcevc_uvm_bufferpool.cc:460:    gloglevel = loglevel;
videodec/lcevc/lcevc_uvm_bufferpool.cc:461:    LCEVC_LOG(LOG_INFO, "[%s instance %d]", __FUNCTION__, mInstanceNum);
videodec/lcevc/lcevc_uvm_bufferpool.cc:470:        LCEVC_LOG(LOG_INFO, "[%s] malloc size %d", __FUNCTION__, DEFAULT_ES_BUFF_SIZE);
videodec/lcevc/lcevc_uvm_bufferpool.cc:482:                LCEVC_LOG(LOG_ERR, "[%s] Usage error of std::vector", __FUNCTION__);
videodec/lcevc/lcevc_uvm_bufferpool.cc:503:    LCEVC_LOG(LOG_INFO, "[%s instance %d]", __FUNCTION__, mInstanceNum);
videodec/lcevc/lcevc_uvm_bufferpool.cc:524:            LCEVC_LOG(LOG_DEBUG_LEVEL2, "[LcevcEsBufferPool::%s-%d] Wait free buffer",
videodec/lcevc/lcevc_uvm_bufferpool.cc:527:            LCEVC_LOG(LOG_DEBUG_LEVEL2, "[LcevcEsBufferPool::%s-%d] Wait free buffer done",
videodec/lcevc/lcevc_uvm_bufferpool.cc:530:            LCEVC_LOG(LOG_INFO,
videodec/lcevc/lcevc_uvm_bufferpool.cc:544:                    LCEVC_LOG(LOG_ERR, "[LcevcEsBufferPool::%s] malloc buffer failed, size = %zu",
videodec/lcevc/lcevc_uvm_bufferpool.cc:549:                    LCEVC_LOG(LOG_INFO, "[LcevcEsBufferPool::%s] malloc buffer succeeded, size = %zu",
videodec/lcevc/lcevc_uvm_bufferpool.cc:564:                LCEVC_LOG(LOG_DEBUG_LEVEL2, "[LcevcEsBufferPool::%s-%d] Wait free buffer",
videodec/lcevc/lcevc_uvm_bufferpool.cc:567:                LCEVC_LOG(LOG_DEBUG_LEVEL2, "[LcevcEsBufferPool::%s-%d] Wait free buffer done",
videodec/lcevc/lcevc_uvm_bufferpool.cc:583:                    LCEVC_LOG(LOG_ERR,
videodec/lcevc/lcevc_uvm_bufferpool.cc:605:    LCEVC_LOG(LOG_ERR, "[LcevcEsBufferPool::%s] Failed to get buffer", __FUNCTION__);
videodec/lcevc/lcevc_uvm_bufferpool.cc:632:    LCEVC_LOG(LOG_INFO, "[LcevcEsBufferPool::%s] mEsBuffers size = %zu",
videodec/lcevc/lcevc_uvm_bufferpool.cc:657:        LCEVC_LOG(LOG_ERR, "[LcevcEsBufferPool::%s] { buff != &(mEsBuffers[i] }",
videodec/lcevc/lcevc_uvm_bufferpool.cc:661:        LCEVC_LOG(LOG_ERR,
videodec/lcevc/lcevc_uvm_bufferpool.cc:670:    LCEVC_LOG(LOG_INFO, "[LcevcEsBufferPool::%s]", __FUNCTION__);
videodec/lcevc/lcevc_uvm_bufferpool.h:78:    LcevcBufferPool(int32_t instance, uint32_t loglevel);
videodec/lcevc/lcevc_uvm_bufferpool.h:113:    LcevcEsBufferPool(int32_t instance, uint32_t loglevel);
videodec/lcevc/include/LCEVC_DVP.h:106: * \brief Enum defining LCEVC Log levels, with increasing levels of verbosity. */
videodec/lcevc/include/LCEVC_DVP.h:107:typedef enum LCEVC_LogLevel
videodec/lcevc/include/LCEVC_DVP.h:109:    LCEVC_LogLevel_None = 0,
videodec/lcevc/include/LCEVC_DVP.h:110:    LCEVC_LogLevel_Error = 1,
videodec/lcevc/include/LCEVC_DVP.h:111:    LCEVC_LogLevel_Warning = 2,
videodec/lcevc/include/LCEVC_DVP.h:112:    LCEVC_LogLevel_Info = 3,
videodec/lcevc/include/LCEVC_DVP.h:113:    LCEVC_LogLevel_Debug = 4,
videodec/lcevc/include/LCEVC_DVP.h:114:    LCEVC_LogLevel_Verbose = 5,
videodec/lcevc/include/LCEVC_DVP.h:115:} LCEVC_LogLevel;
videodec/lcevc/include/LCEVC_DVP.h:117:typedef void (*LCEVC_LogCallback)(void* userData, const char* msg, size_t len, LCEVC_LogLevel logLevel);
videodec/lcevc/include/LCEVC_DVP.h:158: * @param[in]   logCallback    Function pointer to a logging callback function
videodec/lcevc/include/LCEVC_DVP.h:159: * @param[in]   logLevel       The desired log level
videodec/lcevc/include/LCEVC_DVP.h:160: * @param[in]   logUserData    Some userData associated with logging
videodec/lcevc/include/LCEVC_DVP.h:171:LCEVC_ReturnCode LCEVC_CreateDecoder(LCEVC_LogCallback logCallback, LCEVC_LogLevel logLevel,
videodec/lcevc/include/LCEVC_DVP.h:172:                                     void* logUserData, LCEVC_DecoderHandle* decoder);
videodec/lcevc/include/LCEVC_DVP.h:220: * \brief set the desired log level.
videodec/lcevc/include/LCEVC_DVP.h:223: * @param[in] logLevel desired log level. All logs of this level and below will be sent via the callback.
videodec/lcevc/include/LCEVC_DVP.h:225:void LCEVC_SetLogLevel(LCEVC_DecoderHandle decoder, LCEVC_LogLevel logLevel);
videodec/lcevc/lcevc_uvm_wrapper.cc:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/lcevc/lcevc_uvm_wrapper.cc:12:#define LOG_TAG "LCEVC-UVM"
videodec/lcevc/lcevc_uvm_wrapper.cc:26: #include <utils/Log.h>
videodec/lcevc/lcevc_uvm_wrapper.cc:35:        ALOGE("[%s] open uvm dev fail", __FUNCTION__);
videodec/lcevc/lcevc_uvm_wrapper.cc:50:        ALOGE("[%s] need open uvm first", __FUNCTION__);
videodec/lcevc/lcevc_uvm_wrapper.cc:65:        ALOGE("[%s] alloc error ret = %x", __FUNCTION__, ret);
videodec/lcevc/lcevc_uvm_wrapper.cc:75:        ALOGE("[%s] invalid arguments!",
videodec/lcevc/lcevc_uvm_wrapper.cc:85:        ALOGE("[%s] get metadata error ret = %x", __FUNCTION__, ret);
videodec/lcevc/lcevc_uvm_wrapper.cc:108:        ALOGE("[%s] uvmfd = %d", __FUNCTION__, uvmfd);
videodec/lcevc/lcevc_uvm_wrapper.cc:112:        ALOGE("[%s] lcevc_buffer_info = NULL", __FUNCTION__);
videodec/lcevc/lcevc_uvm_wrapper.cc:129:        ALOGE("[%s] UVM_IOC_ATTACH failed, ret = %d",
videodec/lcevc/lcevc_uvm_wrapper.cc:160:        ALOGE("[%s] UVM_IOC_GET_INFO failed, ret = %d",
videodec/lcevc/lcevc_uvm_wrapper.cc:171:        ALOGE("[%s] uvmfd = %d", __FUNCTION__, uvmfd);
videodec/lcevc/lcevc_uvm_wrapper.cc:175:        ALOGE("[%s] lcevc_buffer_info = NULL", __FUNCTION__);
videodec/lcevc/lcevc_uvm_wrapper.cc:195:            ALOGE("[%s] UVM_IOC_ATTACH failed, ret = %d",
videodec/lcevc/lcevc_uvm_wrapper.cc:203:            ALOGE("[%s] UVM_IOC_SET_INFO failed, ret = %d",
videodec/V4l2Adaptor.cpp:5://#define LOG_NDEBUG 0
videodec/V4l2Adaptor.cpp:6:#define LOG_TAG "V4l2Adaptor"
videodec/V4l2Adaptor.cpp:27:#include <utils/Log.h>
videodec/V4l2Adaptor.cpp:60:            ALOGE("Component thread failed to start.");
videodec/V4l2Adaptor.cpp:90:    ALOGI("V4l2Adaptor::onInit instanceNum = %d\n", instanceNum);
videodec/V4l2Adaptor.cpp:93:        ALOGE("Re-initialize() is not allowed");
videodec/V4l2Adaptor.cpp:114:        ALOGE("Failed to initialize VDA");
videodec/V4l2Adaptor.cpp:131:            ALOGD("%s setpriority error: %s, niceval:%d",  __func__, strerror(errno), niceval);
videodec/V4l2Adaptor.cpp:142:    ALOGI("V4l2Adaptor::initialize flags is 0x%x", flags);
videodec/V4l2Adaptor.cpp:212:    ALOGI("onAssignPictureBuffers numOutputBuffers %d\n", numOutputBuffers);
videodec/V4l2Adaptor.cpp:221:    ALOGI("assignPictureBuffers numOutputBuffers %d\n", numOutputBuffers);
videodec/V4l2Adaptor.cpp:243:    ALOGI("onImportBufferForPicture pictureBufferId %d, dmabufFd %d, metaFd %d, plane size %d\n",
videodec/V4l2Adaptor.cpp:251:        ALOGI("onImportBufferForPicture addr %p, stride %d, offset %d, size %" PRId64 "\n",
videodec/V4l2Adaptor.cpp:260:    ALOGI("importBufferForPicture pictureBufferId %d, dmabufFd %d, metaFd %d\n",
videodec/V4l2Adaptor.cpp:412:        ALOGE("not support input the codec now!");
videodec/V4l2Adaptor.cpp:415:    ALOGI("V4l2Adaptor::GetSupportedProfiles inputcoded %d, inputFormatFourcc %x\n",
videodec/V4l2Adaptor.cpp:434:    LOG_ALWAYS_FATAL_IF(value == std::end(kSupportedPixelFormats),
videodec/V4l2Adaptor.cpp:446:    ALOGI("V4l2Adaptor::ProvidePictureBuffers %d\n", requested_num_of_buffers);
videodec/V4l2Adaptor.cpp:473:    //ALOGI("NotifyEndOfBitstreamBuffer bitstream_buffer_id %d\n", bitstream_buffer_id);
videodec/V4l2Adaptor.cpp:503:        ALOGE("Unknown error code: %d", static_cast<int>(error));
videodec/v4l2/ranges.h:16:#include "base/logging.h"
videodec/v4l2/v4l2_video_decode_accelerator.cc:7://#define LOG_NDEBUG 0
videodec/v4l2/v4l2_video_decode_accelerator.cc:10:#define LOG_TAG "VDA"
videodec/v4l2/v4l2_video_decode_accelerator.cc:21:#include <utils/Log.h>
videodec/v4l2/v4l2_video_decode_accelerator.cc:51:#include "log_debug.h"
videodec/v4l2/v4l2_video_decode_accelerator.cc:57:#define DVLOGF(level) DVLOG(level) << __func__ << "(): "
videodec/v4l2/v4l2_video_decode_accelerator.cc:58:#define VLOGF(level) VLOG(level) << __func__ << "(): "
videodec/v4l2/v4l2_video_decode_accelerator.cc:59:#define VPLOGF(level) VPLOG(level) << __func__ << "(): "
videodec/v4l2/v4l2_video_decode_accelerator.cc:61:#define VDALog(level, f, s...) VDLog(level, "[%d##%d]" f, caller_instance_id_, decoder_instance_num_, ##s)
videodec/v4l2/v4l2_video_decode_accelerator.cc:70:    VDALog(LOG_ERR, "Setting error state FAILED line %d, errstat %x, decoder stat %s\n", __LINE__, x,\
videodec/v4l2/v4l2_video_decode_accelerator.cc:80:      VDALog(LOG_ERR, "IOCRL() %s FAILED line %d, %s(%d), ret %d,decoder stat %s\n", type_str, __LINE__, \
videodec/v4l2/v4l2_video_decode_accelerator.cc:94:      VDALog(LOG_ERR, "IOCRL() %s FAILED line %d, %s(%d) ret %d, decoder stat %s\n", type_str, __LINE__,\
videodec/v4l2/v4l2_video_decode_accelerator.cc:116:#define IOCTL_OR_LOG_ERROR(type, arg)           \
videodec/v4l2/v4l2_video_decode_accelerator.cc:120:      VDALog(LOG_ERR, "IOCRL() FAILED line %d, %s(%d),  decoder stat %s\n", __LINE__,\
videodec/v4l2/v4l2_video_decode_accelerator.cc:133:    VDALog(level, format" {IN=%d/%d, OUT=%d/%d[%s(%d) %s(%d) %s(%d)]}",\
videodec/v4l2/v4l2_video_decode_accelerator.cc:174:#define V4L2_CID_USER_AMLOGIC_BASE (V4L2_CID_USER_BASE + 0x1100)
videodec/v4l2/v4l2_video_decode_accelerator.cc:175:#define AML_V4L2_SET_DRMMODE (V4L2_CID_USER_AMLOGIC_BASE + 0)
videodec/v4l2/v4l2_video_decode_accelerator.cc:176:#define AML_V4L2_GET_INPUT_BUFFER_NUM (V4L2_CID_USER_AMLOGIC_BASE + 1)
videodec/v4l2/v4l2_video_decode_accelerator.cc:177:#define AML_V4L2_SET_UEVENT_DURATION (V4L2_CID_USER_AMLOGIC_BASE + 2) //for AFR
videodec/v4l2/v4l2_video_decode_accelerator.cc:178:#define AML_V4L2_SET_INPUT_BUFFER_NUM_CACHE (V4L2_CID_USER_AMLOGIC_BASE + 4)
videodec/v4l2/v4l2_video_decode_accelerator.cc:179:#define AML_V4L2_GET_DECODER_INFO (V4L2_CID_USER_AMLOGIC_BASE + 5)// 5 is decoder info. hardware\amlogic\media_modules\drivers\amvdec_ports\aml_vcodec_dec.
videodec/v4l2/v4l2_video_decode_accelerator.cc:180:#define AML_V4L2_GET_BITDEPTH (V4L2_CID_USER_AMLOGIC_BASE + 6)
videodec/v4l2/v4l2_video_decode_accelerator.cc:181:#define AML_V4L2_DEC_PARMS_CONFIG (V4L2_CID_USER_AMLOGIC_BASE + 7)
videodec/v4l2/v4l2_video_decode_accelerator.cc:182:#define AML_V4L2_GET_INST_ID  (V4L2_CID_USER_AMLOGIC_BASE + 8)
videodec/v4l2/v4l2_video_decode_accelerator.cc:183:#define AML_V4L2_SET_STREAM_MODE  (V4L2_CID_USER_AMLOGIC_BASE + 9)
videodec/v4l2/v4l2_video_decode_accelerator.cc:184:#define AML_V4L2_SET_ES_DMABUF_TYPE (V4L2_CID_USER_AMLOGIC_BASE + 10)
videodec/v4l2/v4l2_video_decode_accelerator.cc:185:#define AML_V4L2_SET_VF_DURATION (V4L2_CID_USER_AMLOGIC_BASE + 11)
videodec/v4l2/v4l2_video_decode_accelerator.cc:186:#define AML_V4L2_GET_WIDTH_ALIGN (V4L2_CID_USER_AMLOGIC_BASE + 12)
videodec/v4l2/v4l2_video_decode_accelerator.cc:187:#define AML_V4L2_SET_SCREEN_MODE (V4L2_CID_USER_AMLOGIC_BASE + 15)
videodec/v4l2/v4l2_video_decode_accelerator.cc:188:#define AML_V4L2_GET_HEIGHT_ALIGN (V4L2_CID_USER_AMLOGIC_BASE + 16)
videodec/v4l2/v4l2_video_decode_accelerator.cc:189:#define AML_V4L2_SET_CHANNEL_PRIORITY (V4L2_CID_USER_AMLOGIC_BASE + 17)
videodec/v4l2/v4l2_video_decode_accelerator.cc:536:  log_fd_ = -1;
videodec/v4l2/v4l2_video_decode_accelerator.cc:553:  VideoDec_propertyGetInt(PROPERTY_VIDEODEC_LOGlEVELS, PROPERTY_VIDEODEC_LOGlEVELS_OLD, (int*)&gloglevel);
videodec/v4l2/v4l2_video_decode_accelerator.cc:562:  if (log_level_ & 1)
videodec/v4l2/v4l2_video_decode_accelerator.cc:563:    log_fd_ = open("/dev/dec_stat", O_RDWR | O_NONBLOCK | O_CLOEXEC);
videodec/v4l2/v4l2_video_decode_accelerator.cc:583:      VDALog(LOG_DEBUG_LEVEL1, "get linux version failed");
videodec/v4l2/v4l2_video_decode_accelerator.cc:588:  VDALog(LOG_INFO, "open dec_stat fd %d, gloglevel %d use_pts_id_ is %d force dmabuf mode %d send_userdata_:%d\n",
videodec/v4l2/v4l2_video_decode_accelerator.cc:589:    log_fd_, gloglevel, use_pts_id_, force_dmabuf_mode_, send_userdata_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:597:  DVLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:612:  if (log_fd_ >= 0)
videodec/v4l2/v4l2_video_decode_accelerator.cc:613:    close(log_fd_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:644:  VDALog(LOG_INFO, "%s:%d", __func__, __LINE__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:657:      VDALog(LOG_INFO, "[warning] config v4l2paras len:%d, but videodec v4l2paras len:%d", configlen, hal_struct_len);
videodec/v4l2/v4l2_video_decode_accelerator.cc:660:    VDALog(LOG_INFO, "v4l2 private parms, magic:%x len:%d, adaptiveback:%d height:%d width:%d,format:%s",
videodec/v4l2/v4l2_video_decode_accelerator.cc:685:    VDALog(LOG_INFO, "MediaHal SetConfig enable no head mode %d", pamldeccfg->cfg.low_latency_mode);
videodec/v4l2/v4l2_video_decode_accelerator.cc:711:        VDALog(LOG_INFO, "setConfig: LOWLATENCY_FENCE mode\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:729:    IOCTL_OR_LOG_ERROR(VIDIOC_S_PARM, &param);
videodec/v4l2/v4l2_video_decode_accelerator.cc:753:    IOCTL_OR_LOG_ERROR(VIDIOC_G_PARM, &param);
videodec/v4l2/v4l2_video_decode_accelerator.cc:779:      VDALog(LOG_ERR, "not support set type %d now, please check!", (id - V4L2_CID_USER_AMLOGIC_BASE));
videodec/v4l2/v4l2_video_decode_accelerator.cc:787:    VDALog(LOG_ERR, "not support set type %s %d", idstr, (id - V4L2_CID_USER_AMLOGIC_BASE));
videodec/v4l2/v4l2_video_decode_accelerator.cc:794:  VDALog(LOG_DEBUG_LEVEL1, "sctrl set type %s %d val:%d", idstr, (id - V4L2_CID_USER_AMLOGIC_BASE), val);
videodec/v4l2/v4l2_video_decode_accelerator.cc:831:      VDALog(LOG_DEBUG_LEVEL2,
videodec/v4l2/v4l2_video_decode_accelerator.cc:838:        VDALog(LOG_INFO, "force send picture ready, bitstream_buffer_id=%lld",
videodec/v4l2/v4l2_video_decode_accelerator.cc:843:      VDALog(LOG_DEBUG_LEVEL2, "matching residual found: bitstream_buffer_id=%lld",
videodec/v4l2/v4l2_video_decode_accelerator.cc:895:      VDALog(LOG_INFO, "Not lcevc stream, disable lcevc.");
videodec/v4l2/v4l2_video_decode_accelerator.cc:988:  VLOGF(2) << "profile: " << config.profile
videodec/v4l2/v4l2_video_decode_accelerator.cc:1007:  VDALog(LOG_INFO, "%s LCEVC", lcevc_enable ? "Enabled" : "Disabled");
videodec/v4l2/v4l2_video_decode_accelerator.cc:1009:    VDALog(LOG_INFO, "LCEVC is not support secure_mode");
videodec/v4l2/v4l2_video_decode_accelerator.cc:1013:      VDALog(LOG_INFO, "LCEVC is not support for stream mode");
videodec/v4l2/v4l2_video_decode_accelerator.cc:1036:  VDALog(LOG_INFO, "Initialize instance_num %d\n", config.instance_num);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1097:  VDALog(LOG_INFO, "Initialize codec2_mode_:%d,"
videodec/v4l2/v4l2_video_decode_accelerator.cc:1171:    VLOGF(1) << "Failed to open device for profile: " << config.profile
videodec/v4l2/v4l2_video_decode_accelerator.cc:1173:    VDALog(LOG_ERR, "Failed to open device for profile: %d, fourcc:0x%x", config.profile, input_format_fourcc_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1188:    VDALog(LOG_INFO, "Decoder v4l support no head mode %d", support_no_header_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1196:    VDALog(LOG_INFO, "MediaHal enable no head mode %d",pamldeccfg->cfg.low_latency_mode);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1202:  VDALog(LOG_INFO, "Initialize decoder_instance_num_ = %d", decoder_instance_num_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1205:  VDALog(LOG_INFO, "TP_VDA_Initialize %" PRId64 ", flags is %d\n", systemTime(SYSTEM_TIME_MONOTONIC), flags);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1222:    VLOGF(1) << "ioctl() failed: VIDIOC_QUERYCAP"
videodec/v4l2/v4l2_video_decode_accelerator.cc:1224:    VDALog(LOG_ERR, "ioctl() failed: VIDIOC_QUERYCAP, caps check failed: 0x%x", caps.capabilities);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1252:    VLOGF(1) << "decoder thread failed to start";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1253:    VDALog(LOG_ERR, "decoder thread failed to start");
videodec/v4l2/v4l2_video_decode_accelerator.cc:1276:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1277:  VDALog(LOG_INFO, "InitializeTask");
videodec/v4l2/v4l2_video_decode_accelerator.cc:1309:    VDALog(LOG_INFO, "init bufferpool bufferpool_size = %d", bufferpool_size);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1333:  VDALog(LOG_INFO, "v4l2_params_.width %d, height %d", v4l2_params_.width, v4l2_params_.height);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1335:    VDALog(LOG_INFO, "stream is 16k, use 16k input buffer.");
videodec/v4l2/v4l2_video_decode_accelerator.cc:1338:    VDALog(LOG_INFO, "stream is 8k, use 8k input buffer.");
videodec/v4l2/v4l2_video_decode_accelerator.cc:1356:    VDALog(LOG_ERR, "setDecoderId stream_mode_ %d decoder_instance_num_ %d instance_num_ %d\n",stream_mode_, decoder_instance_num_,instance_num_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1359:  if (gloglevel & LOG_DEBUG_LEVEL2)
videodec/v4l2/v4l2_video_decode_accelerator.cc:1371:    DVLOGF(4) << "unsupport report error frame";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1377:      DVLOGF(4) << "unsupport report error";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1385:      DVLOGF(4) << "afd event ioctl failed";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1392:      DVLOGF(4) << "hdr info ioctl failed";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1399:      DVLOGF(4) << "vdec statistic ioctl failed";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1407:      DVLOGF(4) << "vdec cc ioctl failed";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1414:      DVLOGF(4) << "vdec frame info ioctl failed";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1421:      DVLOGF(4) << "signal info sub ioctl failed";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1428:      DVLOGF(4) << "stream info sub ioctl failed";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1450:      VDALog(LOG_ERR, "%s setpriority error: %s, niceval=%d",  __func__, strerror(errno), niceval);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1459:  DVLOGF(4) << "input_id=" << bitstream_buffer.id()
videodec/v4l2/v4l2_video_decode_accelerator.cc:1461:  VDALog(LOG_BUFFER, "input_id=%d, size=%d", bitstream_buffer.id(),(int)bitstream_buffer.size());
videodec/v4l2/v4l2_video_decode_accelerator.cc:1465:    VDALog(LOG_ERR, "Decoder state error return\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:1470:    VLOGF(1) << "Invalid bitstream_buffer, id: " << bitstream_buffer.id();
videodec/v4l2/v4l2_video_decode_accelerator.cc:1471:    VDALog(LOG_ERR, "Invalid bitstream_buffer, id:%d", bitstream_buffer.id());
videodec/v4l2/v4l2_video_decode_accelerator.cc:1489:  VLOGF(2) << "buffer_count=" << buffers.size();
videodec/v4l2/v4l2_video_decode_accelerator.cc:1490:  VDALog(LOG_INFO, "%s buffer_count=%d", __func__,(int)buffers.size());
videodec/v4l2/v4l2_video_decode_accelerator.cc:1502:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1503:  VDALog(LOG_INFO, "%s decoder_state_=%s", __func__, DecoderStateStr(decoder_state_));
videodec/v4l2/v4l2_video_decode_accelerator.cc:1511:    VLOGF(1) << "Failed to provide requested picture buffers. (Got "
videodec/v4l2/v4l2_video_decode_accelerator.cc:1513:    VDALog(LOG_INFO, "Failed to provide requested picture buffers. (Got %d, requested %d)\n",
videodec/v4l2/v4l2_video_decode_accelerator.cc:1533:    VLOGF(1) << "Could not allocate enough output buffers";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1534:    VDALog(LOG_ERR, "%s Could not allocate enough output buffers", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1560:    DVLOGF(3) << "buffer[" << i << "]: picture_id=" << output_record.picture_id;
videodec/v4l2/v4l2_video_decode_accelerator.cc:1561:    VDALog(LOG_BUFFER, "%s buffer[%d]:picture_id=%d\n", __func__, (int)i, output_record.picture_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1568:    VDALog(LOG_INFO, "In reset_pending_, now PictureBuffers is ready, continue reset\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:1578:  DVLOGF(3) << "picture_buffer_id=" << picture_buffer_id;
videodec/v4l2/v4l2_video_decode_accelerator.cc:1579:  VDALog(LOG_BUFFER, "ImportBufferForPicture picture_buffer_id %d\n", picture_buffer_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1583:    VLOGF(1) << "Cannot import in non-import mode";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1584:    VDALog(LOG_ERR, "%s Cannot import in non-import mode", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1629:  DVLOGF(3) << "picture_buffer_id=" << picture_buffer_id
videodec/v4l2/v4l2_video_decode_accelerator.cc:1641:    DVLOGF(4) << "early out: kError state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1642:    VDALog(LOG_ERR, "%s early out: kError state", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1648:    DVLOGF(4) << "early out: kChangingResolution state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1649:    VDALog(LOG_INFO, "%s early out: kChangingResolution state", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1655:      VDALog(LOG_INFO, "%s early out: kAwaitingPictureBuffers state", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1670:    DVLOGF(3) << "got picture id=" << picture_buffer_id
videodec/v4l2/v4l2_video_decode_accelerator.cc:1672:    VDALog(LOG_ERR, "%s got picture id=%d, not in use(any more)", __func__, picture_buffer_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1678:    VLOGF(1) << "Cannot import buffer not owned by client";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1679:    VDALog(LOG_ERR, "%s Cannot import buffer not owned by client", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1697:  BufferStatus(LOG_INFO, "%s fd=%lld, index=%d\n", __func__,(long long)iter->processor_output_fds[0], (int)picture_buffer_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1711:  VDALog(LOG_BUFFER, "%s:%d dmabuf_fds %lld, picture_id %d, free_v4l2buffers:%d\n", __func__, __LINE__,
videodec/v4l2/v4l2_video_decode_accelerator.cc:1713:  DVLOGF(3) << "picture_buffer_id=" << picture_buffer_id
videodec/v4l2/v4l2_video_decode_accelerator.cc:1725:    DVLOGF(4) << "early out: kError state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1726:    VDALog(LOG_ERR, "%s early out: kError state", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1732:    DVLOGF(4) << "early out: kChangingResolution state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1733:    VDALog(LOG_INFO, "%s early out: kChangingResolution state", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1739:      VDALog(LOG_INFO, "%s early out: kAwaitingPictureBuffers", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1752:      VDALog(LOG_ERR, "%s got fd=%lld, pictureId:%d, but same dmabuf fd is in use, please check",
videodec/v4l2/v4l2_video_decode_accelerator.cc:1762:      VDALog(LOG_DEBUG_LEVEL2, "%s can not get noused v4l2 buffer, need retry", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1783:    VLOGF(1) << "Cannot import buffer not owned by client";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1784:    VDALog(LOG_ERR, "%s Cannot import buffer not owned by client, bufferstatus:%s", __func__, OutputbufferStateStr(output_record.state));
videodec/v4l2/v4l2_video_decode_accelerator.cc:1798:  BufferStatus(LOG_INFO, "%s fd=%lld, index=%d\n", __func__,
videodec/v4l2/v4l2_video_decode_accelerator.cc:1808:  DVLOGF(4) << "picture_buffer_id=" << picture_buffer_id;
videodec/v4l2/v4l2_video_decode_accelerator.cc:1824:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1825:  VDALog(LOG_INFO, "%s", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1833:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1834:  VDALog(LOG_INFO, "%s", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1850:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1852:  VDALog(LOG_INFO, "%s:%d", __func__, __LINE__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1874:  VLOGF(2) << "Destroyed.";
videodec/v4l2/v4l2_video_decode_accelerator.cc:1892:  VDALog(LOG_INFO, "GetDecoderStatusInfo status info error_type:%d decoder_count:%d decoder_error_count:%d",
videodec/v4l2/v4l2_video_decode_accelerator.cc:1918:    VDALog(LOG_INFO, "%s set [%d][%f]", __func__, duration_96K_based, rate);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1941:    VDALog(LOG_INFO, "%s set [%d]", __func__, duration_96K_based);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1953:      VDALog(LOG_INFO, "%s set need_disable_afr from [%d] to false", __func__, need_disable_afr);
videodec/v4l2/v4l2_video_decode_accelerator.cc:1981:    VDALog(LOG_INFO, "%s set [%d] framerate[%f]", __func__, duration_96K_based, framerate);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2004:    VDALog(LOG_INFO, "%s set AML_V4L2_SET_UEVENT_DURATION", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2015:    VDALog(LOG_INFO, "%s set AML_V4L2_SET_VF_DURATION", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2019:    VDALog(LOG_INFO, "%s set DECODER_SET_SCREEN_MODE", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2031:    ALOGI("V4l2Adaptor::postAndReplyMsg callerinstanceid : %d",caller_instance_id_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2039:    VDALog(LOG_INFO,"decoderID:%d", decoder_instance_num_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2057:    VDALog(LOG_INFO,"bitdepth:%d", depth);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2064:    VDALog(LOG_INFO, "[%s@%d] got widthalign:%d", __FUNCTION__, __LINE__, widthAlign);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2071:    VDALog(LOG_INFO, "[%s@%d] got heightalign:%d", __FUNCTION__, __LINE__, heightAlign);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2093:      VDALog(LOG_INFO, "%s set framerate [%f] afr_force_on:%d", __func__,framerate, afr_on_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2160:    ALOGI("V4l2Adaptor::postAndReplyMsg pipelineworknumber : %d",pipeline_work_number_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2165:    VDALog(LOG_INFO, "enable to get decoder statistic data");
videodec/v4l2/v4l2_video_decode_accelerator.cc:2188:    VDALog(LOG_INFO, "%s set DECODER_SET_SCREEN_MODE", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2199:    VDALog(LOG_INFO,"diPostToPreBuffNum update output_dpb_size_: %d", output_dpb_size_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2212:    VDALog(LOG_INFO, "%s set AML_V4L2_SET_CHANNEL_PRIORITY: %d", __func__, priority);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2221:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2240:  DVLOGF(4) << "input_id=" << bitstream_buffer.id();
videodec/v4l2/v4l2_video_decode_accelerator.cc:2261:          VDALog(LOG_ERR, "%s could not map bitstream_buffer", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2262:          VLOGF(1) << "could not map bitstream_buffer";
videodec/v4l2/v4l2_video_decode_accelerator.cc:2266:        DVLOGF(4) << "mapped at=" << bitstream_record->shm->memory();
videodec/v4l2/v4l2_video_decode_accelerator.cc:2283:    VDALog(LOG_INFO, "Skip empty buffer.\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:2309:    VLOGF(2) << "early out: kError state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:2310:    VDALog(LOG_ERR, "%s early out: kError state\n", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2322:  VDALog(LOG_INFO, "%s SetEOS trigger\n", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2325:    VDALog(LOG_INFO, "%s buffer all done\n", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2334:  VDALog(LOG_INFO, "%s notify eos to decoder\n", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2340:  DVLOGF(4);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2347:    VDALog(LOG_INFO, "%s input need pending, will retry\n", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2352:    VDALog(LOG_INFO, "%s decoder_state_ = %s -> kDecoding", __func__, DecoderStateStr(decoder_state_));
videodec/v4l2/v4l2_video_decode_accelerator.cc:2353:    DVLOGF(3) << "Change state to kDecoding in DecodeBufferTask";
videodec/v4l2/v4l2_video_decode_accelerator.cc:2357:    DVLOGF(3) << "early out: state=" << decoder_state_;
videodec/v4l2/v4l2_video_decode_accelerator.cc:2358:    VDALog(LOG_ERR, "%s DecodeBufferTask early out: state=%s\n", __func__, DecoderStateStr(decoder_state_));
videodec/v4l2/v4l2_video_decode_accelerator.cc:2365:      VDALog(LOG_INFO, "%s We're waiting for a new buffer\n", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2371:        VDALog(LOG_INFO, "%s We're asked to delay decoding on this and subsequent buffers\n", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2380:      DVLOGF(4) << "reading input_id="
videodec/v4l2/v4l2_video_decode_accelerator.cc:2385:      DVLOGF(4) << "reading input_id=kFlushBufferId";
videodec/v4l2/v4l2_video_decode_accelerator.cc:2390:    VDALog(LOG_INFO, "%s eos notify \n", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2416:      VLOGF(2) << "enqueued flush buffer";
videodec/v4l2/v4l2_video_decode_accelerator.cc:2489:          DVLOGF(4) << "finished input_id=" << input_id;
videodec/v4l2/v4l2_video_decode_accelerator.cc:2503:            VDALog(LOG_INFO, "%s id:%d", typestr, queryctrl->id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2509:            VDALog(LOG_INFO, "[%s:%d] id:%d(index:%d), val:%d", typestr, __LINE__,
videodec/v4l2/v4l2_video_decode_accelerator.cc:2510:                   decoder_msg->id, decoder_msg->id - V4L2_CID_USER_AMLOGIC_BASE, decoder_msg->value);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2519:            VDALog(LOG_INFO, "[%s:%d] type:%d", typestr, __LINE__,  subscribe->type);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2524:            VDALog(LOG_INFO, "[%s:%d] count:%d, type:%d memory:%d", typestr, __LINE__,
videodec/v4l2/v4l2_video_decode_accelerator.cc:2530:            VDALog(LOG_INFO, "[%s:%d] type:%d", typestr, __LINE__, *(unsigned int*)arg);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2534:            VDALog(LOG_INFO, "[%s:%d] cmd:%d",  typestr, __LINE__, cmd->cmd);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2539:            VDALog(LOG_INFO, "[%s:%d] type:%d, pixformat:%d, sizeimg:%d, numplanes:%d", typestr, __LINE__,
videodec/v4l2/v4l2_video_decode_accelerator.cc:2546:            VDALog(LOG_INFO, "[%s:%d] type:%d", typestr, __LINE__, parm->type);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2550:            VDALog(LOG_INFO, "[%s:%d] type:%d, target:%d", typestr, __LINE__,
videodec/v4l2/v4l2_video_decode_accelerator.cc:2556:            VDALog(LOG_INFO, "[%s:%d] type:%d", typestr, __LINE__, crop->type);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2577:      VDALog(LOG_ERR, "not support set type %d now, please check!", (id - V4L2_CID_USER_AMLOGIC_BASE));
videodec/v4l2/v4l2_video_decode_accelerator.cc:2618:  DVLOGF(3) << "data=" << data << ", size=" << size;
videodec/v4l2/v4l2_video_decode_accelerator.cc:2664:  DVLOGF(4) << "data=" << data << ", size=" << size;
videodec/v4l2/v4l2_video_decode_accelerator.cc:2716:          VDALog(LOG_ERR, "Update frame info error res %x\n", res);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2721:      VDALog(LOG_BUFFER, "instance_id is %d  secure_flags is 0x%x frame_size is %d \
videodec/v4l2/v4l2_video_decode_accelerator.cc:2773:        VDALog(LOG_BUFFER, "need_update_csd_ is true, copy csd data to input buffer  csd_data_len_: %d", csd_data_len_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2836:    VDALog(LOG_BUFFER, "%s:%d index:%d", __func__, __LINE__, decoder_current_input_buffer_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2891:                VDALog(LOG_INFO, "csd size is too big %d %d, should mixed in first frame", csd_data_len_,(int)size);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2899:                VDALog(LOG_INFO, "clear csd data");
videodec/v4l2/v4l2_video_decode_accelerator.cc:2902:                VDALog(LOG_INFO, "csd size is too big %d %d", csd_data_len_,(int)size);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2910:                VDALog(LOG_INFO, "addCsdHead failed");
videodec/v4l2/v4l2_video_decode_accelerator.cc:2918:                  VDALog(LOG_INFO, "No more space to add csd data");
videodec/v4l2/v4l2_video_decode_accelerator.cc:2970:  DVLOGF(4);
videodec/v4l2/v4l2_video_decode_accelerator.cc:2984:        VDALog(LOG_INFO, "AppendToInputFrame FlushInputFrame return\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:2998:        DVLOGF(4) << "stalled for input buffers";
videodec/v4l2/v4l2_video_decode_accelerator.cc:3019:    VDALog(LOG_INFO, "AppendToInputFrame size 0 return\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3026:    VLOGF(1) << "over-size frame, erroring";
videodec/v4l2/v4l2_video_decode_accelerator.cc:3027:    VDALog(LOG_ERR, "over-size frame, erroring\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3067:  DVLOGF(4);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3101:  DVLOGF(4) << "submitting input_id=" << input_record.input_id;
videodec/v4l2/v4l2_video_decode_accelerator.cc:3148:  DVLOGF(4);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3153:    DVLOGF(3) << "early out: kResetting state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:3154:    VDALog(LOG_DEBUG_LEVEL2, "%s early out: kResetting state", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3157:    DVLOGF(3) << "early out: kError state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:3158:    VDALog(LOG_ERR, "%s early out: kError state", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3161:    DVLOGF(3) << "early out: kChangingResolution state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:3162:    VDALog(LOG_DEBUG_LEVEL2, "%s early out: kChangingResolution state", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3170:        VDALog(LOG_DEBUG_LEVEL1, "no size and dpb changed, ignore the event");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3179:      VDALog(LOG_DEBUG_LEVEL1, "Got a resolution change event resolution_change_count is %d", resolution_change_count);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3196:        VDALog(LOG_INFO, "timeout wait output_stream_ setting to true, nofity flush done");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3216:    BufferStatus(LOG_INFO, "%s INs=%d/%d, OUTs=%d/%d",
videodec/v4l2/v4l2_video_decode_accelerator.cc:3223:        (gloglevel >= LOG_BUFFER) &&
videodec/v4l2/v4l2_video_decode_accelerator.cc:3226:        VDALog(LOG_DEBUG_LEVEL2, "%s outputdmabufs: fd:%lld, pictureId:%d, state:%s", __func__,
videodec/v4l2/v4l2_video_decode_accelerator.cc:3244:  DVLOGF(4);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3274:      VDALog(LOG_INFO, "flush id\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3296:      VPLOGF(1) << "SetDevicePollInterrupt failed";
videodec/v4l2/v4l2_video_decode_accelerator.cc:3306:      VDALog(LOG_INFO, "----enqueue input VIDIOC_STREAMON----\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3320:      VPLOGF(1) << "SetDevicePollInterrupt(): failed";
videodec/v4l2/v4l2_video_decode_accelerator.cc:3330:      VDALog(LOG_INFO, "----enqueue output STREAMON----\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3340:  DVLOGF(3);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3348:    VDALog(LOG_DEBUG_LEVEL2, "got V4L2_EVENT type : %x, id:%d\n", ev.type, ev.id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3350:        VDALog(LOG_DEBUG_LEVEL2, "got V4L2_EVENT_SOURCE_CHANGE change event. changes %x input total count: %d\n",
videodec/v4l2/v4l2_video_decode_accelerator.cc:3356:          VLOGF(2) << "got resolution change event.";
videodec/v4l2/v4l2_video_decode_accelerator.cc:3359:          VDALog(LOG_INFO, "TP_VDA_Res_Confirmed %" PRId64, systemTime(SYSTEM_TIME_MONOTONIC));
videodec/v4l2/v4l2_video_decode_accelerator.cc:3369:        VDALog(LOG_DEBUG_LEVEL2, "got HDR Info\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3380:        VDALog(LOG_INFO, "invalid state, may need check!!");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3386:        VDALog(LOG_INFO, "clear resolution change event");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3396:                VDALog(LOG_INFO, "error input id: %d, maybe need check",bitstream_buffer_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3401:            VDALog(LOG_INFO, "error frame id: %lld, maybe need check", (long long)bitstream_buffer_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3408:        VDALog(LOG_INFO, "error frame id: %lld, send error frame to omx2", (long long)bitstream_buffer_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3447:        VDALog(LOG_DEBUG_LEVEL2, "signal bitstream_buffer_id:%d signal:0x%x", bitstream_buffer_id, signal);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3450:      VDALog(LOG_ERR, "Unsupported stream");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3453:      VLOGF(1) << "got an event (" << ev.type << ") we haven't subscribed to.";
videodec/v4l2/v4l2_video_decode_accelerator.cc:3454:      VDALog(LOG_INFO, "got an event (%x) we haven't subscribed to.\n", ev.type);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3466:      VDALog(LOG_DEBUG_LEVEL1, "no size and dpb changed, ignore the event");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3475:    VDALog(LOG_DEBUG_LEVEL1, "Got a resolution change event resolution_change_count is %d", resolution_change_count);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3481:  DVLOGF(4);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3504:        VDALog(LOG_BUFFER, "%s:input_id:%d, phyAddr:%x", __func__, (int) iter->first, (uint32_t) iter->second.phyAddr);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3535:        VDALog(LOG_DEBUG_LEVEL2, "========== DQ input EAGAIN %d ==========\n", input_dequeue_eagain_count_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3538:    VPLOGF(1) << "ioctl() failed: VIDIOC_DQBUF";
videodec/v4l2/v4l2_video_decode_accelerator.cc:3555:      VDALog(LOG_ERR, "%s: Invalid decorder frame %d", __func__, (int)decoder_input_map_.size());
videodec/v4l2/v4l2_video_decode_accelerator.cc:3597:      VDALog(LOG_DEBUG_LEVEL2, "%s: Can't found input_id %d information", __func__, (int)input_record.input_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3605:    VDALog(LOG_INFO, "TP_VDA_InputBuf_First_DeQue %" PRId64 " dequeue first input index:%d  id: %d", systemTime(SYSTEM_TIME_MONOTONIC), dqbuf.index, input_record.input_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3609:  BufferStatus(LOG_BUFFER, "dequeue input index=%d, id=%d, secure handle=0x%x, fd=%d v4l2 decode %lld ms ",
videodec/v4l2/v4l2_video_decode_accelerator.cc:3658:        VDALog(LOG_BUFFER, "========== %s EAGAIN %d ==========\n", __func__,  (int)output_dequeue_eagain_count_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3661:      DVLOGF(3) << "Got EPIPE. Last output buffer was already dequeued.";
videodec/v4l2/v4l2_video_decode_accelerator.cc:3662:      VDALog(LOG_DEBUG_LEVEL1, "Got EPIPE. Last output buffer was already dequeued.");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3665:    VPLOGF(1) << "ioctl() failed: VIDIOC_DQBUF";
videodec/v4l2/v4l2_video_decode_accelerator.cc:3666:    VDALog(LOG_ERR, "dqbuf fail errno %d\n", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3691:            VDALog(LOG_ERR, "%s current fd %d not used, please check!!", __func__, dqbuf.m.fd);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3699:    BufferStatus(LOG_BUFFER, "dequeue output index=%d, dq.tv_sec=%ld, dq.field=%x, dq.flags=%x, \
videodec/v4l2/v4l2_video_decode_accelerator.cc:3763:          VDALog(LOG_INFO, "%s set dur to decoder:%d!!", __func__, dur);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3780:            VDALog(LOG_ERR, "%s current fd %d not used, please check!!", __func__, dqbuf.m.fd);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3811:      VDALog(LOG_INFO, "TP_VDA_CapBuf_First_DeQue %" PRId64 " dequeue first output index:%d  id: %d", systemTime(SYSTEM_TIME_MONOTONIC), dqbuf.index, bitstream_buffer_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3814:    BufferStatus(LOG_BUFFER, "dequeue output index=%d, id=%d, dq.tv_usec=%ld, dq.tv_sec=%ld,"\
videodec/v4l2/v4l2_video_decode_accelerator.cc:3828:    DVLOGF(3) << "Got last output buffer. Waiting last buffer="
videodec/v4l2/v4l2_video_decode_accelerator.cc:3830:    VDALog(LOG_INFO, "Got last output buffer. Waiting last buffer=%d\n", flush_awaiting_last_output_buffer_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3849:          VDALog(LOG_DEBUG_LEVEL1, "flush_pending_ is false\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:3859:        VDALog(LOG_DEBUG_LEVEL1, "Over a resolution change resolution_change_count is %d", resolution_change_count);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3883:  DVLOGF(4);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3913:  VDALog(LOG_DEBUG_LEVEL1, "VIDIOC_QBUF %ld  id: %d", qbuf.timestamp.tv_sec, input_record.input_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3917:    VDALog(LOG_INFO, "TP_VDA_InputBuf_First_Que %" PRId64 " enqueue first input index:%d  id: %d", systemTime(SYSTEM_TIME_MONOTONIC), qbuf.index, input_record.input_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:3936:  BufferStatus(LOG_BUFFER, "enqueue input id=%d,tv_sec=%ld,tv_usec=%ld,size=%d,fd=%d\
videodec/v4l2/v4l2_video_decode_accelerator.cc:3952:  DVLOGF(4) << "enqueued input_id=" << input_record.input_id
videodec/v4l2/v4l2_video_decode_accelerator.cc:3967:  DVLOGF(4) << "buffer " << buffer;
videodec/v4l2/v4l2_video_decode_accelerator.cc:3996:  DVLOGF(4) << "qbuf.index=" << qbuf.index;
videodec/v4l2/v4l2_video_decode_accelerator.cc:4005:    VDALog(LOG_INFO, "TP_VDA_CapBuf_First_Que %" PRId64 " enqueue first output index:%d", systemTime(SYSTEM_TIME_MONOTONIC), buffer);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4022:    BufferStatus(LOG_BUFFER, "enqueue output index=%d, length=%d, state=%s",
videodec/v4l2/v4l2_video_decode_accelerator.cc:4025:    BufferStatus(LOG_BUFFER, "enqueue output index=%d, fd=%d, state=%s",
videodec/v4l2/v4l2_video_decode_accelerator.cc:4037:    VDALog(LOG_DEBUG_LEVEL1, "We have enough output buffer force to decoding change is %d %d",
videodec/v4l2/v4l2_video_decode_accelerator.cc:4043:      VPLOGF(1) << "SetDevicePollInterrupt(): failed";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4053:      VDALog(LOG_INFO, "----enqueue output STREAMON----\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4064:  DVLOGF(4) << "picture_buffer_id=" << picture_buffer_id;
videodec/v4l2/v4l2_video_decode_accelerator.cc:4069:    DVLOGF(4) << "early out: kError state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4070:    VDALog(LOG_ERR, "%s early out: kError state", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4075:    DVLOGF(4) << "early out: kChangingResolution";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4076:    VDALog(LOG_INFO, "%s early out: kChangingResolution", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4091:    DVLOGF(3) << "got picture id= " << picture_buffer_id
videodec/v4l2/v4l2_video_decode_accelerator.cc:4093:    VDALog(LOG_ERR, "got picture id= %d, not in use", picture_buffer_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4099:    VLOGF(1) << "picture_buffer_id not reusable " << picture_buffer_id << " output_record.state " << output_record.state;
videodec/v4l2/v4l2_video_decode_accelerator.cc:4109:  VDALog(LOG_BUFFER, "%s picture_buffer_id= %d\n",__func__, picture_buffer_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4116:  DVLOGF(4) << "picture_buffer_id=" << picture_buffer_id;
videodec/v4l2/v4l2_video_decode_accelerator.cc:4121:    DVLOGF(4) << "early out: kError state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4122:    VDALog(LOG_ERR, "%s early out: kError state", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4127:    DVLOGF(4) << "early out: kChangingResolution state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4128:    VDALog(LOG_INFO, "%s early out: kChangingResolution state", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4133:      VDALog(LOG_INFO, "%s early out: kAwaitingPictureBuffers state", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4142:    VDALog(LOG_ERR, "%s current pictureId %d not used, please check!!", __func__, picture_buffer_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4147:    VDALog(LOG_DEBUG_LEVEL1, "%s pictureId %d state not reuseable %s", __func__, picture_buffer_id, OutputbufferStateStr(dma_iter->second.state));
videodec/v4l2/v4l2_video_decode_accelerator.cc:4155:        VDALog(LOG_DEBUG_LEVEL2, "%s not get unused outputrecord %d, will retry\n",__func__, picture_buffer_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4180:  VDALog(LOG_BUFFER, "%s picture_buffer_id= %d, index=%d, fd:%lld, free_v4l2buffers:%d\n",__func__,
videodec/v4l2/v4l2_video_decode_accelerator.cc:4189:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4190:  VDALog(LOG_INFO, "FlushTask");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4194:    VLOGF(2) << "early out: kError state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4228:  VDALog(LOG_INFO, "FlushTask NotifyFlushDoneIfNeeded");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4252:      DVLOGF(3) << "Some input bitstream buffers are not queued.";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4253:      VDALog(LOG_INFO, "Some input bitstream buffers are not queued. decoder_input_queue_ %d,"
videodec/v4l2/v4l2_video_decode_accelerator.cc:4261:    DVLOGF(3) << "Current input buffer != -1";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4262:    VDALog(LOG_INFO, "Current input buffer != -1");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4266:    DVLOGF(3) << "Some input buffers are not dequeued.";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4267:    VDALog(LOG_INFO, "Some input buffers are not dequeued. input_ready_queue_.size() %d,"
videodec/v4l2/v4l2_video_decode_accelerator.cc:4273:    DVLOGF(3) << "Waiting for last output buffer.";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4275:        VDALog(LOG_INFO, "Waiting for last output buffer. wait_cnt %d\n", flush_wait_count_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4290:    VDALog(LOG_INFO, "StopDevicePoll() && StopOutputStream() && StopInputStream()");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4295:    VDALog(LOG_INFO, "StartDevicePoll()");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4300:  VLOGF(2) << "returning flush";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4301:  VDALog(LOG_INFO, "returning flush");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4318:    VLOGF(2) << "V4L2_DEC_CMD_STOP is not supported.";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4326:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4327:  VDALog(LOG_INFO, "SendDecoderCmdStop");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4343:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4346:  VDALog(LOG_INFO, "ResetTask\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4348:    VDALog(LOG_INFO, "ResetTask in error state notify reset done\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4376:    VDALog(LOG_INFO, "current in kChangingResolution or kAwaitingPictureBuffers [state: %d], need wait\n", decoder_state_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4386:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4389:  VDALog(LOG_INFO, "FinishReset\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4395:      VDALog(LOG_INFO, "FinishReset DequeueResolutionChangeEvent\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4400:    VDALog(LOG_INFO, "FinishReset StopInputStream fail\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4409:    VDALog(LOG_INFO, "%s:StopDevicePoll && StopOutputStream fail\n", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4420:  VDALog(LOG_INFO, "SendPictureReady\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4423:  VDALog(LOG_INFO, "post ResetDoneTask\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4445:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4448:  VDALog(LOG_INFO, "ResetDoneTask\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4450:    VLOGF(2) << "early out: kError state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4451:    VDALog(LOG_INFO, "ResetDoneTask early out: kError state\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4458:        VDALog(LOG_INFO, "ResetDoneTask StartDevicePoll fail\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4475:  VDALog(LOG_INFO, "NotifyResetDone\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4486:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4488:  BufferStatus(LOG_INFO, "%s INS=%d/%d, OUTS=%d/%d",
videodec/v4l2/v4l2_video_decode_accelerator.cc:4528:  VDALog(LOG_INFO, "%s:%d", __func__, __LINE__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4530:    VDALog(LOG_INFO, "%s:%d destroy done signal.", __func__, __LINE__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4536:  DVLOGF(3);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4538:  VDALog(LOG_INFO, "StartDevicePoll\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4554:  DVLOGF(3);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4556:  VDALog(LOG_INFO, "StopDevicePoll\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4564:    VPLOGF(1) << "SetDevicePollInterrupt(): failed";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4591:  DVLOGF(3) << "device poll stopped";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4596:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4604:  VDALog(LOG_INFO, "----stop output VIDIOC_STREAMOFF----\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4616:      VDALog(LOG_BUFFER, "Stop[%d] dmabuf fd:%lld state %s\n", i++, (long long)iter->first, OutputbufferStateStr(iter->second.state));
videodec/v4l2/v4l2_video_decode_accelerator.cc:4630:      VDALog(LOG_BUFFER, "Stop v4l2 buffer index:%d, status:%s", (int)i, OutputbufferStateStr(output_record.state));
videodec/v4l2/v4l2_video_decode_accelerator.cc:4632:      VDALog(LOG_BUFFER, "Stop[%d] state %s\n", (int)i, OutputbufferStateStr(output_record.state));
videodec/v4l2/v4l2_video_decode_accelerator.cc:4653:    VDALog(LOG_DEBUG_LEVEL2, "adjust outbuffer total count when resolution, %d->%d\n",
videodec/v4l2/v4l2_video_decode_accelerator.cc:4656:    BufferStatus(LOG_INFO, "%s INS=%d/%d, OUTS=%d/%d",
videodec/v4l2/v4l2_video_decode_accelerator.cc:4670:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4671:  VDALog(LOG_INFO, "StopInputStream input_streamon %d, input_buffer_map_.size %d\n",
videodec/v4l2/v4l2_video_decode_accelerator.cc:4679:  VDALog(LOG_INFO, "----stop input VIDIOC_STREAMOFF----\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:4691:      VDALog(LOG_BUFFER, "%s:StopInputStream i is %d input_record.secure_handle is 0x%x", __func__,
videodec/v4l2/v4l2_video_decode_accelerator.cc:4702:          VDALog(LOG_BUFFER, "%s: finished for secure input_id %d", __func__, input_record.input_id);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4746:        VDALog(LOG_INFO, "[%s] Couldn't get format information after resolution change, should ignore the resolution", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4757:    VDALog(LOG_INFO, "[%s] dpb(%d->%d),size(%dx%d->%dx%d), is_interlace_changed_:%d", __FUNCTION__,
videodec/v4l2/v4l2_video_decode_accelerator.cc:4774:  VLOGF(2) << "Initiate resolution change";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4785:    VLOGF(1) << "Failed destroying output buffers.";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4789:  VDALog(LOG_INFO, "[%s] into resolution", __func__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4798:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4801:    VLOGF(2) << "early out: kError state";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4810:    VLOGF(1) << "Couldn't get format information after resolution change";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4818:    VLOGF(1) << "Couldn't reallocate buffers after resolution change";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4831:  DVLOGF(4);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4847:      VDLog(LOG_ERR, "%s setpriority error: %s, niceval:%d",  __func__, strerror(errno), niceval);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4877:      VDLog(LOG_ERR, "Setting error state FAILED line %d, errstat %x, decoder stat %s\n", __LINE__, PLATFORM_FAILURE, v4l2decoder->DecoderStateStr(v4l2decoder->decoder_state_));
videodec/v4l2/v4l2_video_decode_accelerator.cc:4902:      VDLog(LOG_ERR, "Setting error state FAILED line %d, errstat %x, decoder stat %s\n", __LINE__, PLATFORM_FAILURE, v4l2decoder->DecoderStateStr(v4l2decoder->decoder_state_));
videodec/v4l2/v4l2_video_decode_accelerator.cc:4927:  VLOGF(1);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4943:  VLOGF(1);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4950:    VLOGF(1) << "Couldn't get format information after resolution change";
videodec/v4l2/v4l2_video_decode_accelerator.cc:4958:    VDALog(LOG_INFO, "%s: format.fmt.pix_mp.field %d\n", __func__, field);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4961:    VDALog(LOG_INFO, "%s format.fmt.pix.field %d\n", __func__,  field);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4985:  VLOGF(1);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4990:    VDALog(LOG_INFO, "%s: format.fmt.pix_mp.field %d\n", __func__, field);
videodec/v4l2/v4l2_video_decode_accelerator.cc:4993:    VDALog(LOG_INFO, "%s: format.fmt.pix.field %d\n", __func__, field);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5017:  VLOGF(1);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5079:      VDALog(LOG_INFO, "%s#%d Decoder not suported format, notify an ILLEGAL_STATE error to client", __FUNCTION__, __LINE__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5083:      VPLOGF(1) << "ioctl() failed: VIDIOC_G_FMT";
videodec/v4l2/v4l2_video_decode_accelerator.cc:5091:    VLOGF(1) << "Unexpected format from G_FMT on output";
videodec/v4l2/v4l2_video_decode_accelerator.cc:5092:    VDALog(LOG_INFO, "[%s] Unexpected format from G_FMT on output", __FUNCTION__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5103:    VDALog(LOG_INFO, "VIDIOC_G_FMT format.fmt.pix.width %d\n", width);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5116:  VDALog(LOG_INFO, "output_planes_count_ %d, format.fmt.pix.width %d\n",
videodec/v4l2/v4l2_video_decode_accelerator.cc:5124:  VLOGF(2) << "new resolution: " << coded_size_.ToString()
videodec/v4l2/v4l2_video_decode_accelerator.cc:5144:    VLOGF(2) << "VIDIOC_G_SELECTION is supported";
videodec/v4l2/v4l2_video_decode_accelerator.cc:5147:    VLOGF(2) << "Fallback to VIDIOC_G_CROP";
videodec/v4l2/v4l2_video_decode_accelerator.cc:5155:      VPLOGF(1) << "ioctl() VIDIOC_G_CROP failed";
videodec/v4l2/v4l2_video_decode_accelerator.cc:5167:  VDALog(LOG_INFO, "[%s] visible width %d, height %d\n", __FUNCTION__, visible_rect->width, visible_rect->height);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5168:  VLOGF(2) << "visible rectangle is " << rect.ToString();
videodec/v4l2/v4l2_video_decode_accelerator.cc:5170:    DVLOGF(3) << "visible rectangle " << rect.ToString()
videodec/v4l2/v4l2_video_decode_accelerator.cc:5175:    VLOGF(1) << "visible size is empty";
videodec/v4l2/v4l2_video_decode_accelerator.cc:5181:    VLOGF(1) << "Unexpected visible rectangle " << rect.ToString()
videodec/v4l2/v4l2_video_decode_accelerator.cc:5190:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5208:  VDALog(LOG_INFO, "CreateInputBuffers count %d instance_num_: %d\n", input_buf_count, instance_num_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5252:        VPLOGF(1) << "mmap() failed";
videodec/v4l2/v4l2_video_decode_accelerator.cc:5269:    VDALog(LOG_INFO, "----create input VIDIOC_STREAMON----\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:5277:  ALOGI("IsSupportedOutputFormat v4l2_format %x\n", v4l2_format);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5303:  VDALog(LOG_INFO, "v4l2_params_.width %d, height %d\n",
videodec/v4l2/v4l2_video_decode_accelerator.cc:5307:      VDALog(LOG_INFO, "use 16K input size\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:5313:      VDALog(LOG_INFO, "use 8K input size\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:5316:      VDALog(LOG_INFO, "not 8k use max input size\n");
videodec/v4l2/v4l2_video_decode_accelerator.cc:5333:    VLOGF(1) << "Input fourcc " << input_format_fourcc_
videodec/v4l2/v4l2_video_decode_accelerator.cc:5346:     VDALog(LOG_DEBUG_LEVEL2, "vc1 singlemode set pixelformat to V4L2_PIX_FMT_VC1_ANNEX_G");
videodec/v4l2/v4l2_video_decode_accelerator.cc:5351:  VDALog(LOG_INFO, "TP_VDA_SFmt_Start %" PRId64, systemTime(SYSTEM_TIME_MONOTONIC));
videodec/v4l2/v4l2_video_decode_accelerator.cc:5353:  VDALog(LOG_INFO, "TP_VDA_SFmt_End %" PRId64, systemTime(SYSTEM_TIME_MONOTONIC));
videodec/v4l2/v4l2_video_decode_accelerator.cc:5363:  VDALog(LOG_INFO, "%s set outformat:%s", __func__, Outformat2Str(pixelformat));
videodec/v4l2/v4l2_video_decode_accelerator.cc:5384:    VLOGF(2) << "Image processor not available";
videodec/v4l2/v4l2_video_decode_accelerator.cc:5387:  VLOGF(2) << "Output format=" << output_format_fourcc_;
videodec/v4l2/v4l2_video_decode_accelerator.cc:5406:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5427:    VDALog(LOG_INFO, "[%s@%d] got widthalign:%d", __FUNCTION__, __LINE__, width_align_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5434:    VDALog(LOG_INFO, "[%s@%d] got heightalign:%d", __FUNCTION__, __LINE__, height_align_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5439:  VDALog(LOG_INFO, "output_dpb_size_ %d, output buffer %d, coded_size_ %d x %d width_align:%d height_align_:%d\n",
videodec/v4l2/v4l2_video_decode_accelerator.cc:5453:      VDALog(LOG_INFO, "(%d,%d) crop to (%d,%d)",coded_size_.width(), coded_size_.height(),
videodec/v4l2/v4l2_video_decode_accelerator.cc:5482:  VDALog(LOG_INFO, "%s decoder_state_ change to %s\n", __func__, DecoderStateStr(decoder_state_));
videodec/v4l2/v4l2_video_decode_accelerator.cc:5488:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5493:  VDALog(LOG_INFO, "%s:%d", __func__, __LINE__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5513:  IOCTL_OR_LOG_ERROR(VIDIOC_REQBUFS, &reqbufs);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5530:  VLOGF(2);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5536:  VDALog(LOG_INFO, "%s:%d", __func__, __LINE__);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5543:    DVLOGF(3) << "dismissing PictureBuffer id=" << output_record.picture_id;
videodec/v4l2/v4l2_video_decode_accelerator.cc:5561:    VPLOGF(1) << "ioctl() failed: VIDIOC_REQBUFS";
videodec/v4l2/v4l2_video_decode_accelerator.cc:5595:  BufferStatus(LOG_DEBUG_LEVEL2, "destroy output buf");
videodec/v4l2/v4l2_video_decode_accelerator.cc:5635:      VDALog(LOG_DEBUG_LEVEL2, "%s: finished to input_id %lld", __func__, (long long)bitStreamId);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5649:      VDALog(LOG_DEBUG_LEVEL2, "%s: finished input_id %lld", __func__, (long long)iter->first);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5658:        VDALog(LOG_DEBUG_LEVEL2, "%s: finished input_id %lld", __func__, (long long)iter->first);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5716:                        VDALog(LOG_DEBUG_LEVEL2, "secure decoded input map size is too many(%zu:%u), "
videodec/v4l2/v4l2_video_decode_accelerator.cc:5730:  VDALog(LOG_DEBUG_LEVEL2, "%s: %lld-%d-%d-%d-%d-%d Secure Input Wait Decode %ld Wait Report %ld",
videodec/v4l2/v4l2_video_decode_accelerator.cc:5753:  DVLOGF(4);
videodec/v4l2/v4l2_video_decode_accelerator.cc:5788:                VDALog(LOG_DEBUG_LEVEL2, "Block by input %lld dequeued spend %lld ms",
videodec/v4l2/v4l2_video_decode_accelerator.cc:5802:                        VDALog(LOG_DEBUG_LEVEL2, "Waiting input %lld dequeued spend %lld ms",
videodec/v4l2/v4l2_video_decode_accelerator.cc:5820:      VDALog(LOG_BUFFER, "[%s:%d] cleared=%d, decoder_state_=%d, decoder_flushing_=%d,\
videodec/v4l2/v4l2_video_decode_accelerator.cc:5845:      DVLOGF(4) << "cleared=" << pending_picture_ready_.front().cleared
videodec/v4l2/v4l2_video_decode_accelerator.cc:5849:      VDALog(LOG_BUFFER, "[%s:%d] cleared=%d, decoder_state_=%d, decoder_flushing_=%d,\
videodec/v4l2/v4l2_video_decode_accelerator.cc:5911:  DVLOGF(4) << "clearing count=" << picture_clearing_count_;
videodec/v4l2/v4l2_video_decode_accelerator.cc:5934:          VDALog(LOG_ERR, "Invalid State not found timestamp information");
videodec/v4l2/v4l2_video_decode_accelerator.cc:5976:            VDALog(LOG_ERR, "Invalid State not found timestamp information");
videodec/v4l2/v4l2_video_decode_accelerator.cc:6045:      VDALog(LOG_ERR, "Insufficient number of parameters: %d, or the corresponding VDA instance: %d does not need to dump YUV.", index, instance_num_);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6071:    VDALog(LOG_ERR, "width or height invalid.");
videodec/v4l2/v4l2_video_decode_accelerator.cc:6079:            VDALog(LOG_DEBUG_LEVEL2, "do nothing");
videodec/v4l2/v4l2_video_decode_accelerator.cc:6109:            VDALog(LOG_ERR, "double write mode: %d does not support dump YUV", dw);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6154:    VDALog(LOG_ERR, "Ioctl set ext fail errno %d", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6160:      VDALog(LOG_DEBUG_LEVEL2, "%s GetAfdData afd_data[%d] = %x", __func__, i, afd_data[i]);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6164:    VDALog(LOG_ERR, "Ioctl get ext fail errno %d\n", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6197:    VDALog(LOG_ERR, "Ioctl set ext fail errno %d", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6205:        VDALog(LOG_DEBUG_LEVEL1, "CC size:%d outof MAX CC size:%d", getSize, MAX_CC_LEN);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6211:      VDALog(LOG_DEBUG_LEVEL2, "%02x , cc_sum:%d", cc_data[i], cc_sum);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6213:    VDALog(LOG_DEBUG_LEVEL1, "CC ready event report index:%d, sum:%d ", cc_index, cc_sum);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6239:    VDALog(LOG_DEBUG_LEVEL1, "CCData version_magic  0x%x, vdec_id %d raw size %d",
videodec/v4l2/v4l2_video_decode_accelerator.cc:6241:    VDALog(LOG_DEBUG_LEVEL1, "CCData video format 0x%x frame type 0x%x",
videodec/v4l2/v4l2_video_decode_accelerator.cc:6243:    VDALog(LOG_DEBUG_LEVEL1, "CCData poc_number %d, flags 0x%x,vpts 0x%x, records_in_que %d duration %d vpts_64 0x%llx",
videodec/v4l2/v4l2_video_decode_accelerator.cc:6255:    VDALog(LOG_ERR, "Ioctl get ext fail errno %d\n", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6284:    VDALog(LOG_ERR, "Ioctl set ext fail errno %d", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6292:    VDALog(LOG_ERR, "Ioctl get ext fail errno %d", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6294:  VDALog(LOG_DEBUG_LEVEL2, "%s ProcessHdrInfo matrix_coeff = %d, color_primaries=%d", __func__, matrix_coeff, color_primaries);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6304:    VDALog(LOG_ERR, "Ioctl subscribe report decinfo error %d", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6326:    VDALog(LOG_ERR, "Ioctl set ext fail errno %d", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6333:    VDALog(LOG_ERR, "Ioctl get ext fail errno %d", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6343:    VDALog(LOG_ERR, "Ioctl set ext fail errno %d", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6348:    VDALog(LOG_DEBUG_LEVEL2, "%s decoder_status = %08xH",
videodec/v4l2/v4l2_video_decode_accelerator.cc:6364:    VDALog(LOG_ERR, "Ioctl get ext fail errno %d", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6384:    VDALog(LOG_DEBUG_LEVEL2, "%s decoded_frames = %d, err_frames = %d, drop_frames =%d ",
videodec/v4l2/v4l2_video_decode_accelerator.cc:6388:    VDALog(LOG_INFO, "get decoder statistics data error");
videodec/v4l2/v4l2_video_decode_accelerator.cc:6423:    VDALog(LOG_ERR, "Ioctl set ext stream_info fail errno %d", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6438:    VDALog(LOG_DEBUG_LEVEL2, "%s frame_dur = %d codec2_frame_rate_:%f",
videodec/v4l2/v4l2_video_decode_accelerator.cc:6443:        VDALog(LOG_INFO, "restart calculate duration info");
videodec/v4l2/v4l2_video_decode_accelerator.cc:6465:          VDALog(LOG_INFO, "Ioctl set duration to decoder [%d]dur[%d]", stream_mode_, duration);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6473:    VDALog(LOG_INFO, "Ioctl get ext stream_info fail errno %d", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6479:    VDALog(LOG_INFO, "%s set video change[%d/%d], frame_rate:%d", __func__,
videodec/v4l2/v4l2_video_decode_accelerator.cc:6502:    VDALog(LOG_ERR, "ProcessFrameQos Ioctl set ext fail errno %d", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6508:    VDALog(LOG_ERR, "ProcessFrameQos Ioctl get ext fail errno %d", errno);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6510:  //VDALog(LOG_DEBUG_LEVEL2, "%s vdec_comm.u.frame_info.qos.num = %d", __func__, vdec_comm.u.frame_info.qos.num);
videodec/v4l2/v4l2_video_decode_accelerator.cc:6517:  VDALog(LOG_DEBUG_LEVEL1, "userdataReady end");
videodec/v4l2/bit_reader_core.h:11:#include "base/logging.h"
videodec/v4l2/bit_reader_core.h:95:  // Help function used by ReadBits to avoid inlining the bit reading logic.
videodec/v4l2/debug_utils.cc:1:#define LOG_NDEBUG 0
videodec/v4l2/debug_utils.cc:2:#define LOG_TAG "VideoDecDebugUtils"
videodec/v4l2/debug_utils.cc:7:#include <utils/Log.h>
videodec/v4l2/debug_utils.cc:24:    ALOGI("codec_mm_dump info\n");
videodec/v4l2/debug_utils.cc:30:            ALOGI("%s", p);
videodec/v4l2/debug_utils.cc:33:    ALOGI("config info\n");
videodec/v4l2/debug_utils.cc:39:            ALOGI("%s", p);
videodec/v4l2/debug_utils.cc:41:    ALOGI("tvp_enable info\n");
videodec/v4l2/debug_utils.cc:47:            ALOGI("%s", p);
videodec/v4l2/debug_utils.cc:49:    ALOGI("tvp_region info\n");
videodec/v4l2/debug_utils.cc:55:            ALOGI("%s", p);
videodec/v4l2/debug_utils.cc:58:    ALOGI("codec_mm_keeper_dump info\n");
videodec/v4l2/debug_utils.cc:64:            ALOGI("%s", p);
videodec/v4l2/debug_utils.cc:67:    ALOGI("codec_mm_scatter_dump info\n");
videodec/v4l2/debug_utils.cc:73:            ALOGI("%s", p);
videodec/v4l2/video_pixel_format.h:14:// Logged to UMA, so never reuse values. Leave gaps if necessary.
videodec/v4l2/video_pixel_format.h:69:      PIXEL_FORMAT_Y16,  // Must always be equal to largest entry logged.
videodec/v4l2/shared_memory_region.cc:31:    DVLOG(1) << "Invalid offset: " << offset_;
videodec/v4l2/video_decode_accelerator.cc:6:#include "base/logging.h"
videodec/v4l2/video_decode_accelerator.cc:36:  LOG(FATAL) << "This may only be called in the same process as VDA impl.";
videodec/v4l2/v4l2_video_decode_accelerator.h:68:    if (log_fd_ >= 0) { \
videodec/v4l2/v4l2_video_decode_accelerator.h:86:        ioctl(log_fd_, DECSTAT_IOC_VDA(instance_num_), &s); \
videodec/v4l2/v4l2_video_decode_accelerator.h:811:  int log_fd_;
videodec/v4l2/v4l2_video_decode_accelerator.h:812:  uint32_t log_level_;
videodec/v4l2/mpegConstant.h:2: * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
videodec/v4l2/v4l2_device.cc:7://#define LOG_NDEBUG 0
videodec/v4l2/v4l2_device.cc:8:#define LOG_TAG "VDA"
videodec/v4l2/v4l2_device.cc:16:#include <utils/Log.h>
videodec/v4l2/v4l2_device.cc:22:#include "log_debug.h"
videodec/v4l2/v4l2_device.cc:25:#define DVLOGF(level) DVLOG(level) << __func__ << "(): "
videodec/v4l2/v4l2_device.cc:26:#define VLOGF(level) VLOG(level) << __func__ << "(): "
videodec/v4l2/v4l2_device.cc:27:#define VPLOGF(level) VPLOG(level) << __func__ << "(): "
videodec/v4l2/v4l2_device.cc:32:  VideoDec_propertyGetInt(PROPERTY_VIDEODEC_LOGlEVELS, PROPERTY_VIDEODEC_LOGlEVELS_OLD, (int*)&gloglevel);
videodec/v4l2/v4l2_device.cc:67:      DVLOGF(1) << "Add more cases as needed";
videodec/v4l2/v4l2_device.cc:68:      VDLog(LOG_DEBUG_LEVEL2, "Add more cases as needee pix_fmt %x\n", pix_fmt);
videodec/v4l2/v4l2_device.cc:92:      LOG(FATAL) << "Add more cases as needed";
videodec/v4l2/v4l2_device.cc:93:      VDLog(LOG_DEBUG_LEVEL2, "Add more cases as needed VideoPixelFormat pix_fmt %x\n", format);
videodec/v4l2/v4l2_device.cc:100:  VDLog(LOG_DEBUG_LEVEL2, "VideoCodecProfileToV4L2PixFmt profile %x\n", profile);
videodec/v4l2/v4l2_device.cc:102:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_H264");
videodec/v4l2/v4l2_device.cc:105:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_VP9");
videodec/v4l2/v4l2_device.cc:108:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_H265");
videodec/v4l2/v4l2_device.cc:111:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_MPEG1");
videodec/v4l2/v4l2_device.cc:114:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_MPEG2");
videodec/v4l2/v4l2_device.cc:117:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_MPEG4");
videodec/v4l2/v4l2_device.cc:120:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_MJPEG");
videodec/v4l2/v4l2_device.cc:123:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_AVS2");
videodec/v4l2/v4l2_device.cc:126:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_AVS");
videodec/v4l2/v4l2_device.cc:129:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_AVS3");
videodec/v4l2/v4l2_device.cc:132:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_AV1");
videodec/v4l2/v4l2_device.cc:135:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_VC1_ANNEX_L");
videodec/v4l2/v4l2_device.cc:138:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_VC1_ANNEX_G");
videodec/v4l2/v4l2_device.cc:141:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_H266");
videodec/v4l2/v4l2_device.cc:144:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_dvavc");
videodec/v4l2/v4l2_device.cc:147:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_dvhevc");
videodec/v4l2/v4l2_device.cc:150:      VDLog(LOG_DEBUG_LEVEL2, "V4L2_PIX_FMT_JPEG");
videodec/v4l2/v4l2_device.cc:153:      LOG(FATAL) << "Add more cases as needed";
videodec/v4l2/v4l2_device.cc:154:      VDLog(LOG_DEBUG_LEVEL2, "Add more cases as needed profile ");
videodec/v4l2/v4l2_device.cc:238:      VLOGF(1) << "Unhandled pixelformat " << std::hex << "0x" << pix_fmt;
videodec/v4l2/v4l2_device.cc:264:    DVLOGF(5) << "Poll(): adding device fd to poll() set";
videodec/v4l2/v4l2_device.cc:272:    VPLOGF(1) << "poll() failed";
videodec/v4l2/v4l2_device.cc:304:  DVLOGF(4);
videodec/v4l2/v4l2_device.cc:309:    VPLOGF(1) << "write() failed";
videodec/v4l2/v4l2_device.cc:316:  DVLOGF(5);
videodec/v4l2/v4l2_device.cc:325:      VPLOGF(1) << "read() failed";
videodec/v4l2/v4l2_device.cc:333:  VLOGF(2);
videodec/v4l2/v4l2_device.cc:337:    VLOGF(1) << "No devices supporting " << std::hex << "0x" << v4l2_pixfmt
videodec/v4l2/v4l2_device.cc:343:    VLOGF(1) << "Failed opening " << path;
videodec/v4l2/v4l2_device.cc:349:    VLOGF(1) << "Failed creating a poll interrupt fd";
videodec/v4l2/v4l2_device.cc:360:  VLOGF(2);
videodec/v4l2/v4l2_device.cc:391:      VLOGF(1) << "Failed opening " << device.first;
videodec/v4l2/v4l2_device.cc:441:    VLOGF(1) << "GetSupportedResolution failed to get maximum resolution for "
videodec/v4l2/v4l2_device.cc:447:    VLOGF(1) << "GetSupportedResolution failed to get minimum resolution for "
videodec/v4l2/v4l2_device.cc:462:    DVLOGF(3) << "Found " << fmtdesc.description << std::hex << " (0x"
videodec/v4l2/v4l2_device.cc:494:      DVLOGF(3) << "Found decoder profile " << GetProfileName(profile.profile)
videodec/v4l2/v4l2_device.cc:515:  VLOGF(2);
videodec/v4l2/v4l2_device.cc:529:      LOG(ERROR) << "Only decoder type is supported!!";
videodec/v4l2/v4l2_device.cc:555:      DVLOGF(3) << "Found device: " << path;
videodec/v4l2/frame_data_util.cc:1:#define LOG_NDEBUG 0
videodec/v4l2/frame_data_util.cc:2:#define LOG_TAG "FrameDataUtil"
videodec/v4l2/frame_data_util.cc:5:#include <utils/Log.h>
videodec/v4l2/frame_data_util.cc:10:#include "log_debug.h"
videodec/v4l2/frame_data_util.cc:13:#define FDTLog(level, f, s...) VDLog(level, f, ##s)
videodec/v4l2/frame_data_util.cc:26:    VideoDec_propertyGetInt(PROPERTY_VIDEODEC_LOGlEVELS, PROPERTY_VIDEODEC_LOGlEVELS_OLD, (int*)&gloglevel);
videodec/v4l2/frame_data_util.cc:48:        FDTLog(LOG_INFO, "raw data is too large!! %d",data_size);
videodec/v4l2/frame_data_util.cc:53:        FDTLog(LOG_INFO, "raw data buf size changed %d -> %d", (int32_t)input->length, (int32_t)reallocsize);
videodec/v4l2/frame_data_util.cc:61:            FDTLog(LOG_ERR, "realloc raw data buffer failed.");
videodec/v4l2/frame_data_util.cc:81:              FDTLog(LOG_DEBUG_LEVEL2, "omx have add header");
videodec/v4l2/frame_data_util.cc:111:                FDTLog(LOG_INFO, "omx have add header mjpeg head");
videodec/v4l2/frame_data_util.cc:186:        FDTLog(LOG_ERR, "wmv3 csd size is too big %d %d", size, maxSize);
videodec/v4l2/frame_data_util.cc:190:    /*add amlogic frame headers.*/
videodec/v4l2/frame_data_util.cc:262:            //FDTLog(LOG_INFO, "frame_number : %d, mag : %d; index_sz : %d\n", frame_number, mag, index_sz);
videodec/v4l2/frame_data_util.cc:266:                //FDTLog(LOG_ERR, " Wrong marker2 : 0x%X --> 0x%X\n", marker, buf[mag_ptr]);
videodec/v4l2/frame_data_util.cc:290:            //FDTLog(LOG_ERR, "DATA overflow : 0x%X --> 0x%X\n", total_datasize, dsize);
videodec/v4l2/frame_data_util.cc:307:            /*add amlogic frame headers.*/
videodec/v4l2/frame_data_util.cc:328:                //FDTLog(LOG_INFO, "data has gaps,set to 0\n");
videodec/v4l2/frame_data_util.cc:331:                //FDTLog(LOG_ERR, "ERROR!!! data over writed!!!! over write %d\n", fdata + 16 + framesize - old_header);
videodec/v4l2/frame_data_util.cc:363:        //FDTLog(LOG_INFO, "[1] aml_es_bytes_left : %d\n", aml_es_bytes_left);
videodec/v4l2/frame_data_util.cc:400:            FDTLog(LOG_ERR, "[line:%d] Error num aml_es_bytes_left : %d, frame num:%d, esinsize:%d, oubsize:%d\n",  __LINE__, aml_es_bytes_left, frame_number, size, aml_obu_type);
videodec/v4l2/frame_data_util.cc:411:            FDTLog(LOG_ERR, "[line:%d] Error aml_es_bytes_left : %d, frame num:%d, esinsize:%d, oubsize:%d\n",  __LINE__, aml_es_bytes_left, frame_number, size, aml_obu_type);
videodec/v4l2/frame_data_util.cc:417:        //FDTLog(LOG_INFO, "[2] aml_es_bytes_left : %d\n", aml_es_bytes_left);
videodec/v4l2/frame_data_util.cc:440:        //ALOGE_TAG("===========prepareEsData===:%d, ",*totalDataSize);
videodec/v4l2/frame_data_util.cc:466:            //VDALog(8, " aml_es_bytes_left = %d\n", aml_es_bytes_left);
videodec/v4l2/frame_data_util.cc:475:        //VDALog(8, " frame_number:%d : %d (0x%x)\n", frame_number, (int)dsize, (int)dsize);
videodec/v4l2/frame_data_util.cc:527:          //FDTLog(LOG_INFO, " - %d Bytes OBU written to ES, obu_type : ", (int)aml_obu_size);
videodec/v4l2/frame_data_util.cc:530:              case OBU_SEQUENCE_HEADER:{VDALog(8, "OBU_SEQUENCE_HEADER\n"); break;}
videodec/v4l2/frame_data_util.cc:531:              case OBU_TEMPORAL_DELIMITER:{VDALog(8, "OBU_TEMPORAL_DELIMITER\n"); break;}
videodec/v4l2/frame_data_util.cc:532:              case OBU_FRAME_HEADER:{VDALog(8, "OBU_FRAME_HEADER\n"); break;}
videodec/v4l2/frame_data_util.cc:533:              case OBU_TILE_GROUP:{VDALog(8, "OBU_TILE_GROUP\n"); break;}
videodec/v4l2/frame_data_util.cc:534:              case OBU_METADATA:{VDALog(8, "OBU_METADATA\n"); break;}
videodec/v4l2/frame_data_util.cc:535:              case OBU_FRAME:{VDALog(8, "OBU_FRAME\n"); break;}
videodec/v4l2/frame_data_util.cc:536:              case OBU_REDUNDANT_FRAME_HEADER:{VDALog(8, "OBU_REDUNDANT_FRAME_HEADER\n"); break;}
videodec/v4l2/frame_data_util.cc:537:              case OBU_TILE_LIST:{VDALog(8, "OBU_TILE_LIST\n"); break;}
videodec/v4l2/frame_data_util.cc:538:              case OBU_PADDING:{VDALog(8, "OBU_PADDING\n"); break;}
videodec/v4l2/frame_data_util.cc:539:              default: {VDALog(8, "OBU_TYPE_ERROR!!\n"); break;}
videodec/v4l2/frame_data_util.cc:607:  //VDALog(VDA_LOG_INFO,"_The Stream is Avc and have no start code, Add one.");
videodec/v4l2/frame_data_util.cc:621:            FDTLog(LOG_INFO, "omx have add header");
videodec/v4l2/frame_data_util.cc:626:    //VDALog(VDA_LOG_INFO,"_The Stream is Avc and have no start code, Add one.");
videodec/v4l2/frame_data_util.cc:627:    FDTLog(LOG_INFO, "add mjpeg  header");
videodec/v4l2/frame_data_util.cc:657:        FDTLog(LOG_INFO,"_The Stream is Vc1 and have no start code, Add one.");
videodec/v4l2/frame_data_util.cc:665:        FDTLog(LOG_INFO,"_The Stream is Vc1 and have start code.");
videodec/v4l2/frame_data_util.cc:718:    FDTLog(LOG_INFO,"_The Stream is Wmv3 and have no start code, Add one.");
videodec/v4l2/frame_data_util.cc:751:        FDTLog(LOG_INFO, "_The Stream is Vc1/Wmv3 error frame, add 1k ff error frame tag data.");
videodec/v4l2/subsample_entry.h:16:// encrypted bytes in a sample should be considered a single logical stream,
videodec/v4l2/subsample_entry.h:18:// should not be considered as part of decryption. This is logically equivalent
videodec/v4l2/video_codecs.cc:9:#include "base/logging.h"
videodec/include/V4l2Params.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/include/V4l2Params.h:105:     *            "linear", "log100", "log316", "iec61966-2-4",
videodec/include/AmportsAdaptor.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/include/AmlMessageBase.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/include/AmVideoDec.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/include/AmVideoDec.h:46:#define VideoDecLog(level, f, s...) \
videodec/include/AmVideoDec.h:48:    if (mLogFd >= 0 && level & mLogLevel) { \
videodec/include/AmVideoDec.h:52:        write(mLogFd, buf, n+8); \
videodec/include/AmVideoDec.h:54:        if (level & mLogLevel) \
videodec/include/AmVideoDec.h:55:            ALOGI("[No-%d]-[%d]"#f, mSyncPlayerInstanceNo, mHalCurInstanceId, ##s); \
videodec/include/AmVideoDec.h:63:    if (mLogFd >= 0) { \
videodec/include/AmVideoDec.h:70:        ioctl(mLogFd, DECSTAT_IOC_HAL(mHalCurInstanceId), &s); \
videodec/include/AmVideoDec.h:242:    int mLogFd;
videodec/include/AmVideoDec.h:244:    uint32_t mLogLevel;
videodec/include/AmlDebugConfig.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/include/AmlDebugConfig.h:27:    static constexpr uint8_t kDefaultLogLevel = 0;
videodec/include/AmlDebugConfig.h:34:    void addModuleLogLevel(void* moduleHandle, const string &propName, int logLevel);
videodec/include/AmlDebugConfig.h:35:    int getModuleLogLevel(void* moduleHandle);
videodec/include/AmlDebugConfig.h:45:    map<void*, string> mModulesLogLevels;
videodec/include/AmlDebugConfig.h:46:    map<string, int> mLogLevels;
videodec/include/AmVideoDecBase.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/include/AmDmxDrive.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/bufferpool/bufferpool.cpp:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videodec/bufferpool/bufferpool.cpp:10://#define LOG_NDEBUG 0
videodec/bufferpool/bufferpool.cpp:11:#define LOG_TAG "BufferPool"
videodec/bufferpool/bufferpool.cpp:19:#include <utils/Log.h>
videodec/bufferpool/bufferpool.cpp:60:    ALOGV("[%s] %s:%d", name, __func__, __LINE__);
videodec/bufferpool/bufferpool.cpp:71:    ALOGV("[%s] %s:%d", mName,__func__, __LINE__);
videodec/bufferpool/bufferpool.cpp:83:    ALOGV("[%s] %s:%d phyaddr:%llx, size:%d", mName, __func__, __LINE__, phys, size);
videodec/bufferpool/bufferpool.cpp:88:        ALOGV("[%s] %s:%d have add buffer area, now only support add one", mName, __func__, __LINE__);
videodec/bufferpool/bufferpool.cpp:118:        ALOGE("[%s] %s:%d no buffer area added, please check", mName, __func__, __LINE__);
videodec/bufferpool/bufferpool.cpp:121:    ALOGV("[%s] %s:%d, size:%d", mName, __func__, __LINE__, size);
videodec/bufferpool/bufferpool.cpp:138:            ALOGV("[%s] %s:%d availsize:%d", mName, __func__, __LINE__, chunk->avail);
videodec/bufferpool/bufferpool.cpp:158:                ALOGV("[%s] %s:%d, startbit:%d, nbit：%d", mName, __func__, __LINE__, start_bit, nbits);
videodec/bufferpool/bufferpool.cpp:183:            ALOGV("[%s] %s:%d cannot find available buffer, need retry", mName, __func__, __LINE__);
videodec/bufferpool/bufferpool.cpp:190:    ALOGV("[%s] %s:%d phyaddr:%llx",  mName,__func__, __LINE__, *phyaddr);
videodec/bufferpool/bufferpool.cpp:199:        ALOGE("[%s] %s:%d no bufferpool created or no buffer area, please check", mName, __func__, __LINE__);
videodec/bufferpool/bufferpool.cpp:202:    ALOGV("[%s] %s:%d", mName, __func__, __LINE__);
videodec/bufferpool/bufferpool.cpp:207:        ALOGE("[%s] %s:%d %llx not allocated, cannot free", mName, __func__, __LINE__, addr);
videodec/bufferpool/bufferpool.cpp:211:        ALOGV("[%s] %s:%d %llx only allocate %d, cannot free %d", mName, __func__, __LINE__,
videodec/bufferpool/bufferpool.cpp:239:        ALOGE("[%s] %s:%d addr %llx is not in area, can not free, please check", mName, __func__, __LINE__, addr);
videodec/bufferpool/bufferpool.cpp:243:    ALOGV("[%s] %s:%d phyaddr:%llx", mName, __func__, __LINE__, addr);
videodec/bufferpool/bufferpool.cpp:250:        ALOGE("[%s] %s:%d no buffer area added, please check", mName, __func__, __LINE__);
videodec/bufferpool/bufferpool.cpp:304:        ALOGE("[%s] %s:%d no buffer area added, please check", mName, __func__, __LINE__);
videodec/bufferpool/bufferpool.cpp:325:        ALOGE("[%s] %s:%d no buffer area added, please check", mName, __func__, __LINE__);
videodec/bufferpool/bufferpool.cpp:331:    ALOGI("[%s] %s:%d -------dump allocation-------", mName, __func__, __LINE__);
videodec/bufferpool/bufferpool.cpp:335:        ALOGI("Buffer Region [0x%llx-0x%llx]", chunk->start_addr, chunk->end_addr);
videodec/bufferpool/bufferpool.cpp:340:            ALOGI("[0x%llx-0x%llx] size:%dB", iter->first, (iter->first + iter->second - 1), iter->second);
videodec/bufferpool/bufferpool.cpp:342:            ALOGI("[0x%llx-0x%llx] size:%dK", iter->first, (iter->first + iter->second - 1), iter->second / 1024);
videodec/bufferpool/bufferpool.cpp:352:           ALOGV("%d: %x", i, (uint32)data[i]);
videodec/bufferpool/bufferpool.cpp:356:    ALOGI("[%s] %s:%d -------dump allocation end-------", mName, __func__, __LINE__);
videodec/bufferpool/bitmap.cpp:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videodec/bufferpool/bitmap.cpp:14://#define LOG_NDEBUG 0
videodec/bufferpool/bitmap.cpp:15:#define LOG_TAG "bitmap"
videodec/bufferpool/bitmap.cpp:17:#include <utils/Log.h>
videodec/bufferpool/include/bufferpool.h:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videodec/bufferpool/include/bitmap.h:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videodec/AmportsAdaptor.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/AmportsAdaptor.cpp:12://#define LOG_NDEBUG 0
videodec/AmportsAdaptor.cpp:13:#define LOG_TAG "AmportsAdaptor"
videodec/AmportsAdaptor.cpp:24:#include <utils/Log.h>
videodec/AmportsAdaptor.cpp:37:#include <TspLogger.h>
videodec/AmportsAdaptor.cpp:51:        ALOGE("Component thread failed to start.");
videodec/AmportsAdaptor.cpp:73:        ALOGE("Re-initialize() is not allowed");
videodec/AmportsAdaptor.cpp:79:    ALOGI("VideoCodecProfileToVFmt profile %d, vfmt %d\n", (uint32_t)profile, vfmt);
videodec/AmportsAdaptor.cpp:108:        ALOGI("need add this format\n");
videodec/AmportsAdaptor.cpp:115:            ALOGE("Failed to initialize VDA");
videodec/AmportsAdaptor.cpp:120:         ALOGI("fmt not supported\n");
videodec/AmportsAdaptor.cpp:149:        ALOGE("mVDA does not exist,onSendCommand() is not allowed");
videodec/AmportsAdaptor.cpp:214:        ALOGI("it is dolby es");
videodec/AmportsAdaptor.cpp:219:        ALOGI("do not support this profile %d\n", profile);
videodec/AmportsAdaptor.cpp:228:        ALOGE("mVDA does not exist, onDecodeFd() is not allowed");
videodec/AmportsAdaptor.cpp:258:        ALOGE("mVDA does not exist, onDecodeBuf() is not allowed");
videodec/AmportsAdaptor.cpp:285:        ALOGE("mVDA does not exist, onAssignPictureBuffers() is not allowed");
videodec/AmportsAdaptor.cpp:293:    ALOGI("assignPictureBuffers numOutputBuffers %d\n", numOutputBuffers);
videodec/AmportsAdaptor.cpp:306:        ALOGE("mVDA does not exist, onImportBufferForPicture() is not allowed");
videodec/AmportsAdaptor.cpp:311:    ALOGI("onImportBufferForPicture pictureBufferId %d, dmabufFd %d, metaFd %d, plane size %d\n",
videodec/AmportsAdaptor.cpp:320:    ALOGI("importBufferForPicture pictureBufferId %d, dmabufFd %d\n", pictureBufferId, dmabufFd);
videodec/AmportsAdaptor.cpp:330:        ALOGE("mVDA does not exist, onReusePictureBuffer() is not allowed");
videodec/AmportsAdaptor.cpp:349:        ALOGE("mVDA does not exist, onFlush() is not allowed");
videodec/AmportsAdaptor.cpp:364:        ALOGE("mVDA does not exist, onReset() is not allowed");
videodec/AmportsAdaptor.cpp:407:        ALOGE("need to add profile\n");
videodec/AmportsAdaptor.cpp:437:    //ALOGI("CLIENT PICTURE READY picture_buffer_id %d, bitstream_buffer_id %d\n",
videodec/AmportsAdaptor.cpp:479:        ALOGE("Unknown error code: %d", static_cast<int>(error));
videodec/AmportsAdaptor.cpp:486:        ALOGI("%s, mClient=NULL", __func__);
videodec/AmportsAdaptor.cpp:494:        ALOGI("%s, mClient=NULL", __func__);
videodec/ptsserv/PtsServer.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/ptsserv/PtsServerHal.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/ptsserv/PtsServerHal.cpp:10:#define LOG_TAG "PtsServHal"
videodec/ptsserv/PtsServerHal.cpp:12:#include <utils/Log.h>
videodec/ptsserv/PtsServerHal.cpp:19:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/ptsserv/PtsServerHal.cpp:20:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/ptsserv/PtsServerHal.cpp:21:#define FLOGW(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/ptsserv/PtsServerHal.cpp:22:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/ptsserv/PtsServerHal.cpp:51:    FLOGI(mPlayerInstansNo,"debug_level:%d\n",debug_level);
videodec/ptsserv/PtsServerHal.cpp:56:    FLOGI(mPlayerInstansNo,"Use videodec lib ptsserver\n");
videodec/ptsserv/PtsServerHal.cpp:61:    FLOGI(mPlayerInstansNo,"in");
videodec/ptsserv/PtsServerHal.cpp:64:    FLOGI(mPlayerInstansNo,"videodec lib ptsserver Release resources\n");
videodec/ptsserv/PtsServerHal.cpp:80:    FLOGI(mPlayerInstansNo,"ok");
videodec/ptsserv/PtsServerHal.cpp:84:    FLOGI(mPlayerInstansNo,"offset:0x%x AlignmentOffset:0x%x\n", baseOffset,AlignmentOffset);
videodec/ptsserv/PtsServerHal.cpp:91:    FLOGI(mPlayerInstansNo,"mPlayerInstansNo %d\n", PlayerInstansNo);
videodec/ptsserv/PtsServerHal.cpp:96:    FLOGI(mPlayerInstansNo,"TrickMode %d\n", mode);
videodec/ptsserv/PtsServerHal.cpp:114:            FLOGI(mPlayerInstansNo,"-->Checkin delete offset:0x%x pts(32:0x%x 64:%" PRId64 ")\n",delnode->offset,delnode->pts, delnode->pts_64);
videodec/ptsserv/PtsServerHal.cpp:121:        FLOGI(mPlayerInstansNo,"-->Checkin:%d CheckinPtsSize(%d) offset:0x%x pts(32:0x%x 64:%" PRId64 ")\n",
videodec/ptsserv/PtsServerHal.cpp:129:         FLOGI(mPlayerInstansNo,"-->First Checkin ListSize:%d CheckinPtsSize(%d)-> offset:0x%x pts(32:0x%x 64:%" PRId64 ")\n",
videodec/ptsserv/PtsServerHal.cpp:169:        FLOGI(mPlayerInstansNo,"-->First ListSize:%d offset:0x%x duration:%d\n",size,cur_offset,cur_duration);
videodec/ptsserv/PtsServerHal.cpp:172:        FLOGI(mPlayerInstansNo,"listSize:%d offset:0x%x duration:%d\n",size,cur_offset,cur_duration);
videodec/ptsserv/PtsServerHal.cpp:182:                    FLOGI(mPlayerInstansNo,"i:%d offsetTmp:%d node->offset:0x%x offset:0x%x \n",i,offsetTmp,node->offset ,cur_offset);
videodec/ptsserv/PtsServerHal.cpp:193:                        FLOGI(mPlayerInstansNo,"find size:%d i:%d offsetTmp:%d node->offset:0x%x offset:0x%x pts(32:0x%x 64:%" PRId64 ")\n",
videodec/ptsserv/PtsServerHal.cpp:212:            FLOGI(mPlayerInstansNo,"first frame lookup the nearest offset.");
videodec/ptsserv/PtsServerHal.cpp:226:                FLOGI(mPlayerInstansNo,"ok size:%d number:%d offsetDiff:%d node->offset:0x%x offset:0x%x pts(32:0x%x 64:%" PRId64 ")\n",
videodec/ptsserv/PtsServerHal.cpp:239:            FLOGE(mPlayerInstansNo,"fail mPtsCheckoutFailCount :%d\n", mPtsCheckoutFailCount);
videodec/ptsserv/PtsServerHal.cpp:246:                FLOGE(mPlayerInstansNo,"fail mDecoderDuration:%d pts(32:%d 64:%" PRId64 ")\n",
videodec/ptsserv/PtsServerHal.cpp:259:                FLOGE(mPlayerInstansNo,"fail FrameDuration(32:%d 64:%" PRId64 ") pts(32:%d 64:%" PRId64 ")\n",
videodec/ptsserv/PtsServerHal.cpp:287:              FLOGI(mPlayerInstansNo,"FrameDur(32:%d 64:%" PRId64 ") DoubleCheckFrameDuration(32:%d 64:%" PRId64 ")\n",
videodec/ptsserv/PtsServerHal.cpp:292:              FLOGI(mPlayerInstansNo,"LastDoubleCheckoutPts(32:%d 64:%" PRId64 ") pts(32:%d 64:%" PRId64 ") PtsCheckoutFailCount:%d\n",
videodec/ptsserv/PtsServerHal.cpp:309:                  FLOGE(mPlayerInstansNo,"DoubleCheckFrameDurationCount(%d) DoubleCheckFrameDuration(32:%d 64:%" PRId64 ")\n",
videodec/ptsserv/ptsserv.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/ptsserv/PtsServerDriver.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/ptsserv/PtsServerDriver.cpp:10:#define LOG_TAG "PtsServDriver"
videodec/ptsserv/PtsServerDriver.cpp:12:// #include <utils/Log.h>
videodec/ptsserv/PtsServerDriver.cpp:13:#include <TspLogger.h>
videodec/ptsserv/PtsServerDriver.cpp:31:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/ptsserv/PtsServerDriver.cpp:32:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/ptsserv/PtsServerDriver.cpp:33:#define FLOGW(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/ptsserv/PtsServerDriver.cpp:34:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/ptsserv/PtsServerDriver.cpp:91:        ALOGE("PtsServ_open [%s] failed,ret=%d error=%d(%s) used_times=%d*10(ms)\n",
videodec/ptsserv/PtsServerDriver.cpp:109:        ALOGE("PtsServ_ioctl cmd [%d] faided,ret:%d error:%d(%s)\n",
videodec/ptsserv/PtsServerDriver.cpp:148:    FLOGI(mPlayerInstansNo,"debug_level:%d\n",debug_level);
videodec/ptsserv/PtsServerDriver.cpp:165:    FLOGI(mPlayerInstansNo,"Use driver ptsserver,mPServerId:%d ret:%d\n",mPServerId,ret);
videodec/ptsserv/PtsServerDriver.cpp:169:    FLOGI(mPlayerInstansNo,"in");
videodec/ptsserv/PtsServerDriver.cpp:171:    FLOGI(mPlayerInstansNo,"driver ptsserver close dev\n");
videodec/ptsserv/PtsServerDriver.cpp:175:    FLOGI(mPlayerInstansNo,"ok");
videodec/ptsserv/PtsServerDriver.cpp:187:    FLOGI(mPlayerInstansNo,"offset:0x%x AlignmentOffset:0x%x\n", baseOffset,AlignmentOffset);
videodec/ptsserv/PtsServerDriver.cpp:200:    FLOGI(mPlayerInstansNo,"mPlayerInstansNo %d\n", PlayerInstansNo);
videodec/ptsserv/PtsServerDriver.cpp:205:    FLOGI(mPlayerInstansNo,"trickMode %d\n", mode);
videodec/ptsserv/PtsServerDriver.cpp:225:        FLOGI(mPlayerInstansNo,"[mediahal_kpi] First Checkin size:%d  pts:0x%x pts64:%" PRId64 "\n",size,pts_32,pts_64);
videodec/ptsserv/PtsServerDriver.cpp:239:    //FLOGI(mPlayerInstansNo,"-->Checkin size:%d  pts:%d pts64:%lld\n",size,pts_32,pts_64);
videodec/ptsserv/PtsServerDriver.cpp:246:        FLOGI(mPlayerInstansNo,"-->size:%d  pts:0x%x pts64:%" PRId64 ", offset:%" PRId64 " CheckinDuration:%" PRId64 "\n",
videodec/ptsserv/PtsServerDriver.cpp:259:                FLOGI(mPlayerInstansNo,"maybe play round back!");
videodec/ptsserv/PtsServerDriver.cpp:278:                            FLOGI(mPlayerInstansNo,
videodec/ptsserv/PtsServerDriver.cpp:296:                            FLOGI(mPlayerInstansNo,"--->no same duration mCheckinPts64Duration:%" PRId64 "",mCheckinPts64Duration);
videodec/ptsserv/PtsServerDriver.cpp:302:                    //FLOGI(mPlayerInstansNo,"--->no same duration mCheckinPts64Duration:%" PRId64 "",mCheckinPts64Duration);
videodec/ptsserv/PtsServerDriver.cpp:336:            FLOGI(mPlayerInstansNo," offset:0x%" PRIx64 " Recordoffset:0x%" PRIx64 "  \n",offset,mRecordAbnormalOffset);
videodec/ptsserv/PtsServerDriver.cpp:353:        FLOGI(mPlayerInstansNo,"[mediahal_kpi] First Checkout offset:0x%" PRIx64 " pts:0x%x pts64:%" PRId64 " time-consuming:%" PRId64 "\n",
videodec/ptsserv/PtsServerDriver.cpp:362:    FLOGI(mPlayerInstansNo,"offset:0x%llx frame_type:%d",offset,frame_type);
videodec/ptsserv/PtsServerDriver.cpp:364:        FLOGI(mPlayerInstansNo,"has I frame");
videodec/ptsserv/PtsServerDriver.cpp:366:        FLOGI(mPlayerInstansNo,"has P frame");
videodec/ptsserv/PtsServerDriver.cpp:368:        FLOGI(mPlayerInstansNo,"has B frame");
videodec/ptsserv/PtsServerDriver.cpp:376:                FLOGI(mPlayerInstansNo,
videodec/ptsserv/PtsServerDriver.cpp:395:                FLOGI(mPlayerInstansNo,"--->frame pts jump forward and backward, Use I framePts.");
videodec/ptsserv/PtsServerDriver.cpp:412:                FLOGI(mPlayerInstansNo,"has I frame");
videodec/ptsserv/PtsServerDriver.cpp:418:                FLOGI(mPlayerInstansNo,"has P frame");
videodec/ptsserv/PtsServerDriver.cpp:424:                FLOGI(mPlayerInstansNo,"has B frame");
videodec/ptsserv/PtsServerDriver.cpp:430:        FLOGI(mPlayerInstansNo,"-->offset:%" PRIx64 " cur_soffset:0x%" PRIx64 " duration:%d pts:0x%x pts64:%" PRId64 " us\n",
videodec/ptsserv/PtsServerDriver.cpp:435:        FLOGI(mPlayerInstansNo,"frame type form vdec :%d, Record Frame Type:0x%x",frameTypeFormVdec, mRecordFrameType);
videodec/ptsserv/PtsServerDriver.cpp:444:                FLOGI(mPlayerInstansNo,"---> only Use I framePts ");
videodec/ptsserv/ptsserv.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/ptsserv/ptsserv.cpp:10:#define LOG_TAG "PtsServ"
videodec/ptsserv/ptsserv.cpp:12:#include <utils/Log.h>
videodec/ptsserv/ptsserv.cpp:21:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/ptsserv/ptsserv.cpp:22:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/ptsserv/ptsserv.cpp:23:#define FLOGW(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/ptsserv/ptsserv.cpp:24:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
videodec/ptsserv/doublelist.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/ptsserv/PtsServerHal.h:2:  * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videodec/lcevc.go:46:    //vconfig := ctx.Config().VendorConfig("amlogic_vendorconfig")
videodec/lcevc.go:58:        p.Include_dirs = append(p.Include_dirs, "frameworks/native/libs/ui/include_vndk", "hardware/libhardware/include", "hardware/amlogic/gralloc")
videodec/lcevc.go:60:        p.Shared_libs = append(p.Shared_libs, "//hardware/amlogic:libamgralloc_ext")
mediahal_sdk.go.in:26:        hardMediahalSrcPath := "hardware/amlogic/media_hal"
mediahal_sdk.go.in:27:        vendorMediahalSrcPath := "vendor/amlogic/common/media_hal"
mediahal_sdk.go.in:53:        libdvpResisualsVendorPath := "vendor/amlogic/common/mediahal_sdk/lib/vendor/libdvp_residuals.so"
mediahal_sdk.go.in:54:        liblcevcExtractorVendorPath := "vendor/amlogic/common/mediahal_sdk/lib/vendor/liblcevc_extractor.so"
mediahal_sdk.go.in:75:        libdvpResisualsSystemPath := "vendor/amlogic/common/mediahal_sdk/lib/system/libdvp_residuals.system.so"
mediahal_sdk.go.in:76:        liblcevcExtractorSystemPath := "vendor/amlogic/common/mediahal_sdk/lib/system/liblcevc_extractor.system.so"
mediahal_sdk.go.in:97:        pdhpSrcPath := "hardware/amlogic/media_modules_5.15/drivers/frame_provider/aml_dhp/dhp_daemon"
mediahal_sdk.go.in:98:        tdhpSrcPath := "hardware/amlogic/media_modules/drivers/frame_provider/aml_dhp/dhp_daemon"
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:12:#define LOG_NDEBUG 0
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:13:#define LOG_TAG "VideodecNonTunnelWrapper"
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:15://#include <amlogic/am_gralloc_ext.h>
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:24:// #include <utils/Log.h>
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:25:#include <TspLogger.h>
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:48:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:49:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:50:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:170:    FLOGI(mPlayerInstansNo,"blackout:%d",blackout);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:174:    FLOGI(mPlayerInstansNo,"in\n");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:191:        FLOGV(mPlayerInstansNo,"release mVideoDecNonTunneLooper.clear\n");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:198:    FLOGI(mPlayerInstansNo,"ok\n");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:265:    FLOGI(mPlayerInstansNo,"in mode:%d vid:%d\n",mode,mVPid);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:294:    FLOGI(mPlayerInstansNo,"end\n");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:378:                //ALOGV("DequeueSurfaceBuffer success dqslot:%d pictureId:%d\n", dqslot, pictureId);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:404:                //ALOGV("QueueSurfaceBuffer now:%lld timestampUs:%lld\n",nowUs, timestampUs);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:424:    ALOGI("[No-%d](%p) %s start", PlayerInstansNo,mVideoDec, __FUNCTION__);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:438:                            ALOGI("[No-%d](%p) %s report video stuck event", mVideoDec->mPlayerInstansNo,mVideoDec, __FUNCTION__);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:449:    ALOGI("[No-%d](%p) %s return", PlayerInstansNo,mVideoDec, __FUNCTION__);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:454:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:470:        FLOGI(mPlayerInstansNo,"mRender == NULL \n");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:475:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:483:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:493:    FLOGI(mPlayerInstansNo,"in OnFlush mQueuedSlot.size():%d",(int)mQueuedSlot.size());
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:505:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:524:        FLOGI(mPlayerInstansNo,"mVPid:0x%x mVideoMime:%s\n",mVPid,mVideoMime != NULL ? mVideoMime : "NULL");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:535:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:537:        FLOGI(mPlayerInstansNo,"mState == STOPPED return\n");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:562:    FLOGI(mPlayerInstansNo,"ok");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:565:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:568:        FLOGI(mPlayerInstansNo,"mDisplay.reset %p\n",this);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:581:    FLOGI(mPlayerInstansNo,"ok");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:623:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:687:                            FLOGI(mPlayerInstansNo,"---->Render first frame mediaTimeUs:%" PRId64 " mRendTimeUs:%" PRId64 " nowTimeUs:%" PRId64 "\n",mediaTimeUs, timestamp, TSPLooper::GetNowUs());
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:697:                            FLOGI(mPlayerInstansNo,"---->Render Av Sync Done ! ");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:711:                 FLOGE(mPlayerInstansNo,"kWhatQueueOutPutNotify NoFind,timestampNs(%" PRId64 ") index(%d) BufferSlot.size(%d)\n",timestamp,pictureId,(int)mOutputBufferSlot.size());
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:719:                FLOGE(mPlayerInstansNo,"kWhatStop mState:%d return\n", mState);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:724:            FLOGI(mPlayerInstansNo,"kWhatStop onStop\n");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:732:            FLOGI(mPlayerInstansNo,"kWhatFlush vpid:%d\n",mVPid);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:740:                FLOGE(mPlayerInstansNo,"kWhatFlush mState:%d, mNeedFlush:%d\n", mState, mNeedFlush);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:818:            FLOGI(mPlayerInstansNo,"mVideoMime:%s, single demux only audio", mVideoMime);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:820:            FLOGE(mPlayerInstansNo,"mVideoMime:%s, size > 64!", mVideoMime);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:867:       FLOGE(mPlayerInstansNo,"not mInit\n");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:872:        FLOGE(mPlayerInstansNo,"return not STARTED(%d) mState:%d\n",STARTED,mState);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:905:    FLOGI(mPlayerInstansNo,"bufnum %d, width %d, height %d,mDqWidth:%d,mDqHeight:%d\n",
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:949:                FLOGE(mPlayerInstansNo,"RequestBuffer, slot:%d is null", slot);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:958:                FLOGI(mPlayerInstansNo,"createOutputBuffer slot:%d i:%d\n", slot,i);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:965:                    FLOGI(mPlayerInstansNo,"createOutputBuffer slot:%d to surface!i:%d\n", slot,i);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:977:                    FLOGI(mPlayerInstansNo,"createOutputBuffer slot:%d decode!i:%d \n", slot,i);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:987:                    FLOGI(mPlayerInstansNo,"createOutputBuffer slot:%d to surface!i:%d\n", slot,i);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1006:                    FLOGI(mPlayerInstansNo,"createOutputBuffer slot:%d decode!i:%d \n", slot,i);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1012:    FLOGI(mPlayerInstansNo,"ok");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1035:    //ALOGI("VideodecSurfaceWrapper::onOutputBufferDone pictureBufferId:%d TimeUs:%lld",pictureBufferId, TimeUs);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1057:                FLOGI(mPlayerInstansNo,"can not find bitstreamId %d\n", bitstreamId);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1096:        FLOGI(mPlayerInstansNo,"RegisterCb pFunc:%p disPlayHandle:%p\n",(void*)getDisplayVsyncAndPeriod, (void*)this);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1106:    FLOGI(mPlayerInstansNo,"info %p, size %d\n", info, isize);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1119:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1124:    FLOGV(mPlayerInstansNo,"error %d\n", error);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1129:    //FLOGV(mPlayerInstansNo,"event %d, param %p, paramsize %d\n", event, param, paramsize);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1141:            FLOGV(mPlayerInstansNo,"VIDEO FORMAT CHANGED [%d x %d] @%d fps\n",
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1224:    FLOGV(mPlayerInstansNo,"");
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1235:            FLOGI(mPlayerInstansNo,"pthread_create ok DequeueDisPlayerBufferThread:%ld\n",mDequeueDisPlayerBufferThreadFd);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1237:            FLOGE(mPlayerInstansNo,"pthread_create errno:%d (%s) \n",errno,strerror(errno));
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.cpp:1266:        FLOGI(mPlayerInstansNo,"input parameter was NULL, SetTraceInfo failed! \n");
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:12://#define LOG_NDEBUG 0
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:13:#define LOG_TAG "SurfaceDisplay"
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:17:#include <utils/Log.h>
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:21:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:22:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:23:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:37:#include <amlogic/am_gralloc_ext.h>
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:64:    ALOGV("gralloc usage: %#x(producer) + %#x(consumer) = %#x", usage, consumerUsage, finalUsage);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:68:    ALOGD("set up nativeWindow %p for %dx%d, color %#x, rotation %d, usage %#x",
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:98:        ALOGI("native_window_dequeue_buffer_and_wait in, i = %d \n",i);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:100:        ALOGI("native_window_dequeue_buffer_and_wait out, i = %d \n",i);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:129:    FLOGI(mPlayerInstansNo,"debuglevel:%d",debuglevel);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:137:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:148:             FLOGI(mPlayerInstansNo,"handle:0x%p mGraphicBuffer%p mSlot:%d dmafd:%d metafd:%d\n",
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:155:                 //ALOGI("ReleaseGraphicBuffer mSlot:%d dmafd:%d metafd%d\n", i, buffer->dmafd, buffer->metafd);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:168:        FLOGI(mPlayerInstansNo,"mSurface %p\n", mSurface.get());
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:180:    FLOGI(mPlayerInstansNo,"mClearLastFrame (%d).", Status);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:188:        FLOGI(mPlayerInstansNo,"");
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:205:       FLOGI(mPlayerInstansNo,"");
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:214://    ALOGE("%s:%d,mSurface is NULL,connect fail\n",__FUNCTION__,__LINE__);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:266:        FLOGE(mPlayerInstansNo,"RequestBuffer ret < 0\n");
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:288:    FLOGI(mPlayerInstansNo,"mSlot:%d dmafd:%d metafd:%d gSequence:%d, slotBuffer:%p\n",*slot,*dmafd,*metafd,gSequence, slotBuffer.get());
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:296:        FLOGI(mPlayerInstansNo,"in slot:%d \n",*slot);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:306:        FLOGE(mPlayerInstansNo,"DequeueBuffer ret < 0\n");
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:312:    //ALOGI("DequeueBuffer slotBuffer->handle:0x%p dmafd:%d metafd:%d\n", slotBuffer->handle, dmafd, metafd);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:327:            FLOGI(mPlayerInstansNo,"notfound!, handle:%p, mGraphicBuffer:%p", slotBuffer->handle, slotBuffer.get());
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:333:        FLOGI(mPlayerInstansNo,"out handle:0x%p dmafd:%d metafd:%d mSlot:%d fenceFd:%d, mGraphicBuffer:%p\n",
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:340:            FLOGE(mPlayerInstansNo,"has fenceFd,sync_wait ! mSlot:%d \n",*slot);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:344:            FLOGE(mPlayerInstansNo,"mSlot:%d waiting fence timeout!error:%d(%s)\n",*slot,errno,strerror(errno));
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:358:   // FLOGI(mPlayerInstansNo,"in, slot:%d\n", slot);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:376:   // ALOGI("QueueBuffer slot:%d\n", slot);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:379:        FLOGE(mPlayerInstansNo,"buffer error buffer has been queued!slot:%d\n",slot);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:385:        FLOGI(mPlayerInstansNo,"ret:%d, out,slot:%d rendertime %" PRId64 ", nowtime %" PRId64 " diff:%" PRId64 " width %d height %d, grapticbuffer:%p\n",
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:402:    FLOGI(mPlayerInstansNo,"in,detachBuffer slot:%d\n",slot);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:408:        FLOGE(mPlayerInstansNo,"buffer error buffer has been queued, dispbuf:%p, nativeWindow:%p, mGraphicBuffer:%p\n",
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.cpp:413:    FLOGI(mPlayerInstansNo,"out,detachBuffer slot:%d\n", slot);
AmTsplayer/vdnontunnelwrap/VideodecNonTunnelWrapper.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:13://#define LOG_NDEBUG 0
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:14:#define LOG_NDEBUG 0
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:15:#define LOG_TAG "VideoTunnelDisplay"
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:22://#include <amlogic/am_gralloc_ext.h>
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:31:#include <utils/Log.h>
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:40:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:41:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:42:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:83:    ALOGV("ctor videotunnel_ops\n");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:88:    ALOGV("videotunnel_ops leave\n");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:95:        ALOGE("videoTunnelLibInit has inited\n");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:102:            ALOGE( "unable to dlopen libvideotunnel.so: %s", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:111:        ALOGE(" dlsym meson_vt_open failed, err=%s \n", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:119:        ALOGE(" dlsym meson_vt_close failed, err=%s \n", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:127:        ALOGE("dlsym meson_vt_alloc_id failed, err=%s \n", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:135:        ALOGE("dlsym meson_vt_free_id failed, err=%s \n", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:143:        ALOGE("dlsym meson_vt_connect failed, err=%s \n", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:151:        ALOGE("dlsym meson_vt_disconnect failed, err=%s \n", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:159:        ALOGE("dlsym meson_vt_queue_buffer failed, err=%s \n", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:167:        ALOGE("dlsym meson_vt_dequeue_buffer failed, err=%s \n", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:175:        ALOGE("dlsym meson_vt_set_mode failed, err=%s \n", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:183:        ALOGE(" dlsym meson_vt_send_cmd failed, err=%s \n", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:191:        ALOGE(" dlsym meson_vt_set_sourceCrop failed, err=%s \n", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:199:        ALOGE("dlsym meson_vt_cancel_buffer failed, err=%s \n", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:209:        ALOGE("meson_vt_getDisplayVsyncAndPeriod failed, err=%s \n", dlerror());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:212:    ALOGI( "videoTunnelLibInit ok\n");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:226:    ALOGI("videoTunnelLibRelease\n");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:234:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:260:    FLOGI(mPlayerInstansNo,"mQueueBufferToVtNumberLimit:%d ok",mQueueBufferToVtNumberLimit);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:270:    FLOGI(mPlayerInstansNo,"in\n");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:272:    FLOGI(mPlayerInstansNo,"ok\n");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:278:        FLOGI(mPlayerInstansNo,"mTunnelId %d\n", mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:281:        FLOGI(mPlayerInstansNo,"err with surface == null\n");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:291:    FLOGI(mPlayerInstansNo, "mVideoTunnelFd:%d mTunnelId:%d transform:%d",
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:296:            FLOGE(mPlayerInstansNo, "VT_CMD_SET_VIDEO_TRANSFORM failed with %d mVideoTunnelFd:%d mTunnelId:%d",
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:299:            FLOGI(mPlayerInstansNo, "VT_CMD_SET_VIDEO_TRANSFORM success! mVideoTunnelFd:%d mTunnelId:%d",
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:309:    FLOGI(mPlayerInstansNo,"ReleaseGraphicBuffer uvm size:%d ",(int32_t)mUvmBuf.size());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:331:    FLOGI(mPlayerInstansNo,"mClearLastFrame (%d).", Status);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:346:    FLOGI(mPlayerInstansNo,"TotalSize: %d, dis: %d, limit: %d, QCount:%" PRId64 ", DQCount:%" PRId64 ", cancel: %d",
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:358:    FLOGI(mPlayerInstansNo, "%s", str.c_str());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:369:    FLOGI(mPlayerInstansNo,"uvm fd (%d).", mUvmHandle.uvm_getfd());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:394:    FLOGI(mPlayerInstansNo,"mUvmFd (%d),uad.fd:%d,mQueuedCount:%d", mUvmHandle.uvm_getfd(), *metafd,(int)mUvmBuf.size());
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:421:            //FLOGI(mPlayerInstansNo,"The first 4 frames do not dq buffer. with mQueuedCount:%d,*slot:%d",mQueuedCount,*slot);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:428:            FLOGI(mPlayerInstansNo,"in mVideoTunnelFd:%d",mVideoTunnelFd);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:435:                    FLOGE(mPlayerInstansNo,
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:444:                    FLOGE(mPlayerInstansNo,"dequeue buffer fail and wait 8 ms num:%d,need retry",dequeueFailNum);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:452:                        FLOGI(mPlayerInstansNo," dequeue -ENOTCONN, meson_vt_cancel_buffer ret1:%d num:%d",ret1,cancelBufferNum);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:464:            FLOGE(mPlayerInstansNo,"out failed with %d,metafd:%d need deq again,mDeQueuedCount:%d", ret,metafd,mDeQueuedErrCount);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:478:                            FLOGE(mPlayerInstansNo,"out File was deleted,mWaitFenceCount:%d\n",mWaitFenceErrCount);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:485:                        FLOGE(mPlayerInstansNo,"out fstat error:%s (%d),mWaitFenceCount:%d\n", strerror(-errno), errno,mWaitFenceErrCount);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:493:                     FLOGE(mPlayerInstansNo,"out fcntl error:%s (%d),mWaitFenceCount:%d\n", strerror(-errno), errno,mWaitFenceErrCount);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:499:                    FLOGI(mPlayerInstansNo,"metafd:%d fence_fd:%d,mWaitFenceCount:%d ", metafd, fence_fd,mWaitFenceErrCount);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:515:                        FLOGE(mPlayerInstansNo,"mStatus:%d, out metafd:%d fence_fd:%d  wait fence timeout,mWaitFenceCount:%d",
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:521:                    FLOGE(mPlayerInstansNo,"metafd:%d fence_id:%d , display stop and close fence_fd", metafd, fence_fd);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:537:                FLOGI(mPlayerInstansNo,"out slot:%d metafd:%d DQCount:%" PRId64 " VtCount:%" PRId64 "(%d) fence:%d WaitCount:%d DQECount:%d t-consuming:%" PRId64 " us",
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:550:                FLOGI(mPlayerInstansNo, "time-consuming:%" PRId64 "us frame_rate:%d fps double_frame_duration:%" PRId64 "us \n",
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:560:            FLOGE(mPlayerInstansNo,"out slot:%d,mVideoTunnelFd:%d,mTunnelId:%d",*slot,mVideoTunnelFd,mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:562:        FLOGE(mPlayerInstansNo,"out slot:%d,mVideoTunnelFd:%d,mTunnelId:%d",*slot,mVideoTunnelFd,mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:576:  //  ALOGE("%s:%d,mDeQueuedTest:%d,mDeQueuedAndGetFenceTest:%d,mQueuedTest:%d",__FUNCTION__,__LINE__,mDeQueuedTest,mDeQueuedAndGetFenceTest,mQueuedTest);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:580:                FLOGI(mPlayerInstansNo,"out Is Cancel Buffer QCount:%" PRId64 " vtCount:%" PRId64 "(%d) ",
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:604:                FLOGI(mPlayerInstansNo,"in timestamp:%" PRId64 " \n",timestamp);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:615:                FLOGE(mPlayerInstansNo,"meson_vt_queue_buffer failed with %d", err);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:622:                    FLOGI(mPlayerInstansNo,"The first 2 frames queue buffer to vt. with mQueueBufferCount:%" PRId64 ",slot:%d", mQueueBufferCount,slot);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:625:                    FLOGI(mPlayerInstansNo,"out slot:%d QCount:%" PRId64 " vtCount:%" PRId64 "(%d) metafd:%d fence_fd:%d",
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:635:            FLOGE(mPlayerInstansNo,"meson_vt_queue_buffer slot: %d, failed metafd %d", slot, metafd);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:638:        FLOGE(mPlayerInstansNo,"video tunnel queueBuffer failed, mVideoTunnelFd:%d, mTunnelId:%d", mVideoTunnelFd, mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:662:    FLOGI(mPlayerInstansNo,"in,clearlastframe:%d",clearlastframe);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:666:    FLOGI(mPlayerInstansNo,"mConnected Status == %s ",mConnected ? "true" : "false");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:670:            FLOGI(mPlayerInstansNo,"meson_vt_send_cmd with ret:%d mVideoTunnelFd:%d mTunnelId:%d", ret,mVideoTunnelFd, mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:674:            FLOGE(mPlayerInstansNo,"meson_vt_disconnect failed with %d mVideoTunnelFd:%d mTunnelId:%d", ret,mVideoTunnelFd, mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:677:            FLOGI(mPlayerInstansNo,"meson_vt_disconnect success! mVideoTunnelFd:%d mTunnelId:%d",mVideoTunnelFd, mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:685:            FLOGE(mPlayerInstansNo,"meson_vt_close nullptr!");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:687:        FLOGI(mPlayerInstansNo,"meson_vt_close done! mVideoTunnelFd:%d mTunnelId:%d",mVideoTunnelFd, mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:691:    FLOGI(mPlayerInstansNo,"ok");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:702:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:707:        FLOGI(mPlayerInstansNo,"return mConnected:%d mTunnelId:%d",mConnected,mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:713:            FLOGE(mPlayerInstansNo,"meson_vt_open failed with %d mVideoTunnelFd:%d mTunnelId:%d",err,mVideoTunnelFd,mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:715:            FLOGI(mPlayerInstansNo,"meson_vt_open success with mVideoTunnelFd:%d mTunnelId:%d",mVideoTunnelFd,mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:722:            FLOGE(mPlayerInstansNo,"meson_vt_connect failed with %d,mVideoTunnelFd:%d,mTunnelId:%d",err,mVideoTunnelFd,mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:726:            FLOGI(mPlayerInstansNo,"meson_vt_connect success!");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:729:        FLOGE(mPlayerInstansNo,"mVideoTunnelFd:%d, mTunnelId:%d meson_vt_connect%s",
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:734:    FLOGI(mPlayerInstansNo,"ok");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:740:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:741:    FLOGV(mPlayerInstansNo,"left:%d, top:%d, right:%d, bottom:%d",left, top, right, bottom);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:751:        FLOGI(mPlayerInstansNo,"return mTunnelId:%d",mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:758:            FLOGE(mPlayerInstansNo,"meson_vt_set_sourceCrop failed with %d,mVideoTunnelFd:%d,mTunnelId:%d",err,mVideoTunnelFd,mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:761:            FLOGI(mPlayerInstansNo,"meson_vt_set_sourceCrop success!");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:764:        FLOGE(mPlayerInstansNo,"mVideoTunnelFd:%d, mTunnelId:%d meson_vt_set_sourceCrop:%s",
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:769:    FLOGI(mPlayerInstansNo,"ok");
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:777:    FLOGI(mPlayerInstansNo,"(%s)with mVideoTunnelFd:%d mTunnelId:%d",Status == true ? "VIDEOSHOW" : "VIDEOHIDE",mVideoTunnelFd, mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:785:            FLOGE(mPlayerInstansNo,"VideoShow failed with %d mVideoTunnelFd:%d mTunnelId:%d",ret,mVideoTunnelFd, mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:787:            FLOGI(mPlayerInstansNo,"VideoShow success! mVideoTunnelFd:%d mTunnelId:%d",mVideoTunnelFd, mTunnelId);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:796:        FLOGI(mPlayerInstansNo,"frameRate:%d\n", frame_rate);
AmTsplayer/vdnontunnelwrap/VideoTunnelDisplay.cpp:810:            FLOGE(mPlayerInstansNo,"meson_vt_getDisplayVsyncAndPeriod failed with %d", ret);
AmTsplayer/vdnontunnelwrap/SurfaceDisplay.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.h:20:enum ErrorMonitorLogType {
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.h:21:    ERRORMONITOR_LOG_TYPE_LOGCAT = 0x1,
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.h:22:    ERRORMONITOR_LOG_TYPE_BUGREPORT = 0x2,
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.h:44:void ErrorMonitorWrapper_notify(int errorLevel, int logType, int errorType, const char* msg);
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.cpp:13:#define LOG_TAG "ErrorMonitorWrapper"
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.cpp:14:#include <utils/Log.h>
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.cpp:23:    ALOGI("ErrorMonitorWrapper_create\n");
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.cpp:27:            errorNotifyFun = (ErrorNotifyFun)dlsym(libHandle, "_ZN7android18AmlogicErrorNotifyEiiiiPKc");
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.cpp:29:                ALOGI("dlsym AmlogicErrorNotify fail, reason:%s", dlerror());
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.cpp:35:            ALOGI("liberrormonitorclient.so dlopen fail, reason:%s", dlerror());
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.cpp:40:void ErrorMonitorWrapper_notify(int errorLevel, int logType, int errorType, const char* msg)
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.cpp:43:        errorNotifyFun(ERRORMONITOR_SUBMODULE_MEDIAHAL, errorLevel, logType, errorType, msg);
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.cpp:44:        ALOGI("ErrorMonitorWrapper_notify libHandle:%p, errorLevel:%d, logType:%d, errorType:%d, msg:%s",
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.cpp:45:            libHandle, errorLevel, logType, errorType, msg);
AmTsplayer/errormonitorwrap/ErrorMonitorWrapper.cpp:55:    ALOGI("ErrorMonitorWrapper_release\n");
AmTsplayer/AmTsPlayer.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/AmTsPlayer.cpp:45:        ALOGE("AmTsPlayer_create create TsPlayer fail\n");
AmTsplayer/AmTsPlayer.cpp:58:        ALOGE("RegisterResmancb for resman fail\n");
AmTsplayer/AmTsPlayer.cpp:209:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/AmTsPlayer.cpp:1091: *@param:        analog_mute    If analog mute or unmute .
AmTsplayer/AmTsPlayer.cpp:1096:                                                        bool_t analog_mute,
AmTsplayer/AmTsPlayer.cpp:1109:    ret = player->SetAudioMute(analog_mute, digital_mute);
AmTsplayer/AmTsPlayer.cpp:1117: *@param:        *analog_unmute    If analog mute or unmute .
AmTsplayer/AmTsPlayer.cpp:1122:                                                         bool_t *analog_unmute,
AmTsplayer/AmTsPlayer.cpp:1135:    ret = player->GetAudioMute(analog_unmute, digital_unmute);
AmTsplayer/AmTsPlayer.cpp:1617:        ALOGE("ERROR: AmTsPlayer_getState NULL Pointer\n");
AmTsplayer/AmTsPlayer.cpp:1649:    ALOGE("AmTsPlayer PreemptEventFunc\n");
AmTsplayer/adhalwrap/AmlDvbAudio.cpp:2:#define LOG_NDEBUG 0
AmTsplayer/adhalwrap/AmlDvbAudio.cpp:3:#define LOG_TAG "TsAmlDvbAudio"
AmTsplayer/adhalwrap/AmlDvbAudio.cpp:13:    ALOGI("ctor AmlDvbAudioOps\n");
AmTsplayer/adhalwrap/AmlDvbAudio.cpp:18:    ALOGI("~AmlDvbAudioOps leave\n");
AmTsplayer/adhalwrap/AmlDvbAudio.cpp:25:        ALOGE("AmlDvbAudioLibInit has inited\n");
AmTsplayer/adhalwrap/AmlDvbAudio.cpp:32:            ALOGE( "unable to dlopen libAmlAudioOutPort.so: %s", dlerror());
AmTsplayer/adhalwrap/AmlDvbAudio.cpp:50:        ALOGE("dlsym dvb_audio_get_latencyms failed, err=%s \n", dlerror());
AmTsplayer/adhalwrap/AmlDvbAudio.cpp:57:        ALOGE("dlsym dvb_audio_get_ac4_active_pres_id failed, err=%s \n", dlerror());
AmTsplayer/adhalwrap/AmlDvbAudio.cpp:64:        ALOGE("dlsym dvb_audio_get_param failed, err=%s \n", dlerror());
AmTsplayer/adhalwrap/AmlDvbAudio.cpp:71:        ALOGE("dlsym dvb_audio_set_param failed, err=%s \n", dlerror());
AmTsplayer/adhalwrap/AmlDvbAudio.cpp:75:    ALOGI("AmlDvbAudioLibInit ok\n");
AmTsplayer/adhalwrap/AmlDvbAudio.cpp:89:    ALOGI("AmlDvbAudioRelease\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:10:#define LOG_NDEBUG 0
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:11:#define LOG_TAG "AmAudioHalWrapper"
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:21:#include <TspLogger.h>
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:23:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:24:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:25:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:38:    FLOGI(mPlayerInstansNo,"dmx_dev_id:%d mPipeLineMode:%s, mDecoderType:%d",mdmx_dev_id,
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:71:        FLOGI(mPlayerInstansNo,"find findCodecReportInfo");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:74:        FLOGI(mPlayerInstansNo,"no find findCodecReportInfo");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:89:    FLOGI(mPlayerInstansNo,"enable_thread:%d thread:%lu \n",enable_thread,thread);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:93:        FLOGI(mPlayerInstansNo,"pthread_join thread:%lu \n",thread);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:95:        FLOGI(mPlayerInstansNo,"%s thread=%ld\n",__func__,thread);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:124:        FLOGV(mPlayerInstansNo,"param1 0x%x param2 0x%x param3 0x%x fail\n",p->param1, p->param2,p->param3);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:147:    FLOGI(mPlayerInstansNo,"mdmx_dev_id:%d, sourceType:%d, audioPatchManageMode: %d\n", mdmx_dev_id, sourceType, audioPatchManageMode);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:160:        FLOGV(mPlayerInstansNo,"Am_AudioHalWrapper_SetAudioPatchManageMode failed\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:169:    FLOGV(mPlayerInstansNo,"aid %d afmt%d\n",aid,afmt);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:181:    FLOGV(mPlayerInstansNo,"hasvideo:%d \n",hasvideo);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:194:    FLOGV(mPlayerInstansNo,"MediaSyncId:%d \n",SyncInsId);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:202:    FLOGV(mPlayerInstansNo,"PresentationId:%d \n",PresentationId);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:210:            //ALOGV("%s at #line %d binder system control service failed\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:211:            FLOGV(mPlayerInstansNo,"binder system control service failed\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:215:            //ALOGV("%s at #line %d success\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:216:            FLOGV(mPlayerInstansNo,"SET_MEDIA_PRESENTATION_ID success\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:224:    FLOGI(mPlayerInstansNo,"apid:%x  dmx_dev_id:%d \n",aid,dmx_dev_id);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:232:        FLOGV(mPlayerInstansNo,"control service failed\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:294:        FLOGE(mPlayerInstansNo,"failed data is null, out");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:299:        FLOGE(mPlayerInstansNo,"mTransBuf is null, out");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:304:        FLOGE(mPlayerInstansNo,"retry when audio_stream not open, out!!!");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:310:        FLOGI(mPlayerInstansNo,"need to reallocate memory u32BufSsize:%d TranBufSize:%d hw_header_s:%d",u32BufSsize,g_tran_buf_size,hw_header_s);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:330:        FLOGV(mPlayerInstansNo,"AudioHalWrapper_WRITE Frame data failed\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:398:    FLOGI(mPlayerInstansNo,"type:%d fmt:0x%x\n",mfmt,afmt);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:410:    //FLOGI(mPlayerInstansNo,"param2:%p",(void *)p.param2);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:412:        FLOGV(mPlayerInstansNo,"AudioHalWrapper_OPEN_OUTPUT_STREAM failed\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:415:        FLOGV(mPlayerInstansNo,"AudioHalWrapper_OPEN_OUTPUT_STREAM success\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:449:            FLOGV(mPlayerInstansNo,"SetWMAdescr failed\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:452:            FLOGV(mPlayerInstansNo,"SetWMAdescr success\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:464:    FLOGV(mPlayerInstansNo,"mfmt:%d ",mfmt);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:466:        FLOGE(mPlayerInstansNo,"exception: invalid audio  mfmt:%d",mfmt);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:494:            //ALOGV("%s at #line %d binder system control service failed\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:495:            FLOGV(mPlayerInstansNo,"binder system control service failed\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:499:            //ALOGV("%s at #line %d success\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:500:            FLOGV(mPlayerInstansNo,"SET_MEDIA_SYCN_ID success\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:508:        FLOGV(mPlayerInstansNo,"binder system control service failed \n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:512:        FLOGV(mPlayerInstansNo,"success \n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:530:            FLOGI(mPlayerInstansNo,"open success! status:%d (%" PRId64 ")\n",getCloseStatus,TSPLooper::GetNowUs() - nowUs);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:558:    FLOGV(mPlayerInstansNo,"");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:566:            FLOGV(mPlayerInstansNo,"AudioHalWrapper_CLOSE_OUTPUT_STREAM failed");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:568:            FLOGV(mPlayerInstansNo,"AudioHalWrapper_CLOSE_OUTPUT_STREAM success");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:578:            FLOGV(mPlayerInstansNo,"please check system control service");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:580:            FLOGV(mPlayerInstansNo,"success");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:595:    FLOGV(mPlayerInstansNo,"in");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:598:        FLOGV(mPlayerInstansNo,"frmemode not need to start out");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:602:        FLOGV(mPlayerInstansNo,"Already started mIsStarted == true ok");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:625:    FLOGV(mPlayerInstansNo,"ok");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:634:        FLOGV(mPlayerInstansNo,"ok! enable_thread : %d \n",enable_thread);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:643:            FLOGI(mPlayerInstansNo,"create GetAudioStatus_thread error %s",strerror(err));
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:649:            FLOGI(mPlayerInstansNo,"create GetAudioStatus_thread success tid:%lu.\n", thread);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:661:    FLOGV(mPlayerInstansNo,"mfmt %d mvolum:%d mADVolum:%d mmute:%d mAudioWorkMode:%d",mfmt,mvolum,mADVolum,mmute,mAudioWorkMode);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:664:        ALOGE("%s at #line %d, Excption: invalid audio format:%d.\n", __func__,__LINE__,mfmt);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:670:        ALOGV("%s at #line %d binder system control service failed\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:675:        ALOGV("%s at #line %d success\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:714:    FLOGI(mPlayerInstansNo,"mIsStarted:%d,in",mIsStarted);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:716:        FLOGI(mPlayerInstansNo,"frame mode not need to stop,ok");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:736:        FLOGI(mPlayerInstansNo,"Has stopped. mIsStarted == false,ok");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:747:        ALOGV("%s at #line %d please check system control service\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:749:        ALOGV("%s at #line %d success\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:751:    FLOGV(mPlayerInstansNo,"ok");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:763:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:769:    FLOGV(mPlayerInstansNo,"mthread_created:%d thread:%lu",mthread_created,thread);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:771:        FLOGV(mPlayerInstansNo,"pthread_join thread:%lu",thread);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:777:    FLOGI(mPlayerInstansNo,"out");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:785:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:788:        FLOGI(mPlayerInstansNo,"end,audiohal not start record the pause status");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:800:    FLOGI(mPlayerInstansNo,"end");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:807:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:818:    FLOGI(mPlayerInstansNo,"end");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:824:   // FLOGV(mPlayerInstansNo,"mode:%d",mode);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:832:        FLOGI(mPlayerInstansNo,"ok,Now Mode == Change Mode(%s)\n",
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:847:        FLOGV(mPlayerInstansNo,"now work(normal mode) --> cache mode \n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:853:        FLOGV(mPlayerInstansNo,"now work(cache mode) --> normal mode \n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:867:    FLOGI(mPlayerInstansNo,"set wma extra descr:%s \n", mAudioExtraDescrStr);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:881:    FLOGI(mPlayerInstansNo,"set sample rate:%d,channels mask:0x%02x\n",
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:890:    FLOGV(mPlayerInstansNo,"");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:909:    //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:910:    FLOGV(mPlayerInstansNo,"");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:916:    //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:917:    FLOGV(mPlayerInstansNo,"");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:923:    //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:924:    FLOGV(mPlayerInstansNo,"");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:930:    //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:931:    FLOGV(mPlayerInstansNo,"");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:938:    FLOGV(mPlayerInstansNo,"volum:%d mIsOpen:%d mIsReadyStart:%d mIsStarted:%d ",volum,mIsOpen,mIsReadyStart,mIsStarted);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:942:    //ALOGV("%s at #line %d volum:%d mIsOpen:%d mIsReadyStart:%d mIsStarted:%d\n",__func__,__LINE__,volum,mIsOpen,mIsReadyStart,mIsStarted);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:943:    //FLOGV(mPlayerInstansNo,"volum:%d mIsOpen:%d mIsReadyStart:%d mIsStarted:%d ",volum,mIsOpen,mIsReadyStart,mIsStarted);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:984:    FLOGV(mPlayerInstansNo,"mvolum:%d",mvolum);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:992:    FLOGI(mPlayerInstansNo,"volum:%d",volum);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1005:    FLOGI(mPlayerInstansNo,"mADVolum:%d",mADVolum);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1014:    //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1015:    FLOGV(mPlayerInstansNo,"mute:%d mIsOpen:%d mIsReadyStart:%d mIsStarted:%d ",mute,mIsOpen,mIsReadyStart,mIsStarted);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1054:            FLOGI(mPlayerInstansNo,"esmode need set after open mvolum:%d",mvolum);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1086:        //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1087:        FLOGV(mPlayerInstansNo,"binder system control service failed\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1090:        //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1091:        FLOGV(mPlayerInstansNo,"SET_SPDIF success\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1101:    FLOGV(mPlayerInstansNo,"first_lang:0x%x second_lang:0x%x",
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1108:        //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1109:        FLOGV(mPlayerInstansNo,"binder system control service failed\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1112:        //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1113:        FLOGV(mPlayerInstansNo,"FIRST_LANG success\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1120:        //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1121:        FLOGV(mPlayerInstansNo,"binder system control service failed\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1124:        //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1125:        FLOGV(mPlayerInstansNo,"SECOND_LANG success\n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1136:    //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1137:    FLOGV(mPlayerInstansNo,"");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1146:    //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1147:    FLOGV(mPlayerInstansNo,"");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1163:   // ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1164:    FLOGV(mPlayerInstansNo,"");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1172:    //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1173:    FLOGV(mPlayerInstansNo,"stereo:%d",stereo);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1186:    FLOGV(mPlayerInstansNo,"mstereo:%d",mstereo);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1261:        FLOGE(mPlayerInstansNo,"can not findCodecReportInfo \n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1265:        FLOGE(mPlayerInstansNo,"get codec_report_info error \n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1273:    //FLOGI(mPlayerInstansNo,"bitrate=%u samplerate=%u channel_nums=%u channel_configuration=%u\n",
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1282:    FLOGV(mPlayerInstansNo,"");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1295:        FLOGE(mPlayerInstansNo,"open /dev/tsync error(%s)\n", strerror(errno));
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1298:    FLOGI(mPlayerInstansNo,"open /dev/tsync ok \n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1301:    FLOGI(mPlayerInstansNo,"set dmx_dev_id:%d player_id:%d apid:0x%x PCRpid:0x%x\n",
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1314:       FLOGI(mPlayerInstansNo,"send control failed, TSYNC_IOC_SET_DEMUX_INFO  t=%x errno=%d\n",r, errno);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1328:        FLOGE(mPlayerInstansNo,"open /dev/tsync error(%s)\n", strerror(errno));
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1331:    FLOGI(mPlayerInstansNo,"func:%s, open /dev/tsync ok \n", __FUNCTION__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1335:       FLOGE(mPlayerInstansNo,"send control failed, TSYNC_IOC_STOP_TYNC_PCR  r=%x errno=%d\n",r, errno);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1345:    //ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1353:        //ALOGI("decoded_frames : %d\n",mAdecStat->decoded_frames);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1357:        //ALOGI("decoded_err : %d\n",mAdecStat->decoded_err);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1361:        //ALOGI("decoded_drop : %d\n",mAdecStat->decoded_drop);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1368:        FLOGE(mPlayerInstansNo,"can not findCodecReportInfo \n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1373:        FLOGE(mPlayerInstansNo,"get codec_report_info error \n");
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1378:    //ALOGI("decoded_frames : %lld\n",mAdecStat->decoded_frames);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1381:    //ALOGI("decoded_err : %lld\n",mAdecStat->decoded_err);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1386:    //ALOGI("audio_standards : %s\n",mAdecStat->audio_standards);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1389:    //ALOGI("audio_format : %s\n",mAdecStat->audio_format);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1392:    //ALOGI("stream_level : %d\n",mAdecStat->stream_level);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1394:    //ALOGI("buf_latency : %d ms\n",mAdecStat->buf_latencyMs);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1419:            //FLOGV(mPlayerInstansNo,"GetLatencyms:%d",*GetLatencyms);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1435:        FLOGI(mPlayerInstansNo,"ac4_active_pres_id : %d \n",ret);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1439:        FLOGI(mPlayerInstansNo,"get ac4 pres id fail, ret:%d", ret);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1461:    FLOGV(mPlayerInstansNo,"enable:%d",enable);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1478:    FLOGV(mPlayerInstansNo,"master_vol:%d slave_vol:%d ",master_vol,slave_vol);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1492:    FLOGV(mPlayerInstansNo,"enable:%d ",enable);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1529:    FLOGV(mPlayerInstansNo,"level %d mfmt:%d",level,mfmt);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1574:            FLOGV(mPlayerInstansNo,"AudioSourceChange channels=%u channel_mask=%u sample_rate=%u\n",
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1584:                FLOGI(mPlayerInstansNo,"mfmt:%d, fmt:%d\n", mfmt, fmt);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1606:       ALOGI("[No-%d] Am_AudioHalWrapper_Event MSG == null\n",mPlayerInstansNo);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1623:    ALOGI("[No-%d] Am_AudioHalWrapper_GetAudioStatus_thread start\n",mPlayerInstansNo);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1635:                ALOGI("[No-%d] Am_AudioHalWrapper_GetAudioStatus_thread end\n",mPlayerInstansNo);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1644:                ALOGI("[No-%d] notifyEvent EVENT_TYPE_AUDIO_INVALID_DATA-2\n",mPlayerInstansNo);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1655:                //ALOGI("[No-%d](%p)-->GetAudioStatus_thread value:%s firstapts:%d size:%d enable_thread:%d",
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1662:                        ALOGI("[No-%d] mAudioHalWrapper == NULL \n",mPlayerInstansNo);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1672:                        ALOGI("[No-%d] mAudioCurPtsUs == 0x%llx ", mPlayerInstansNo,(long long)mAudioCurPtsUs);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1675:                        ALOGI("[No-%d] mAudioHalWrapper == NULL \n", mPlayerInstansNo);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1689:    ALOGI("[No-%d] Am_AudioHalWrapper_GetAudioStatus_thread end\n",mPlayerInstansNo);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1705:    //FLOGV(mPlayerInstansNo,"ptsDtsFlag:%d\n", ret);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1720:    //FLOGV(mPlayerInstansNo,"ptsDtsFlag:%d\n", ret);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1735:    //FLOGV(mPlayerInstansNo,"audio es cache:%d\n", ret);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1742:    FLOGV(mPlayerInstansNo,"audio patch address:%d \n",address);
AmTsplayer/adhalwrap/AmAudioHalWrapper.cpp:1762:            ALOGI("report no audio first frame event");
AmTsplayer/adhalwrap/AmAudioHalWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/TsPlayer.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/TsPlayer.cpp:13:#define LOG_NDEBUG 0
AmTsplayer/TsPlayer.cpp:14:#define LOG_TAG "TsPlayer"
AmTsplayer/TsPlayer.cpp:28:#include <TspLogger.h>
AmTsplayer/TsPlayer.cpp:74:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/TsPlayer.cpp:75:#define FLOGD(number,fmt,...) ALOGD("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/TsPlayer.cpp:76:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/TsPlayer.cpp:77:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/TsPlayer.cpp:81:    ALOGI("PreemptFunc!!!\n");
AmTsplayer/TsPlayer.cpp:98:    ALOGI("\n--------------------------------\n"
AmTsplayer/TsPlayer.cpp:128:        ALOGE("dmx_dev_id(%d) < 0",dmx_dev_id < 0);
AmTsplayer/TsPlayer.cpp:135:            ALOGV("AmTsPlayerFeatures:%s",AmTsPlayerFeatures);
AmTsplayer/TsPlayer.cpp:259:    //FLOGI(mPlayerInstansNo,"mIsBootplayMode %d" ,mIsBootplayMode);
AmTsplayer/TsPlayer.cpp:265:    mDebugServer->addModuleLogLevel(this, PROPERTY_AMTSPLAYER_DEBUGLEVEL, debugLevel);
AmTsplayer/TsPlayer.cpp:333:    FLOGI(mPlayerInstansNo,"dmx_dev_id:%d sourceType:%s demux:%s BootMode:%d Recovery:%d total:%d\n",
AmTsplayer/TsPlayer.cpp:358:            FLOGI(mPlayerInstansNo,"decoder feature info data_len:%zu actual_len:%zu\n",decFeature.data_len, decFeature.actual_len);
AmTsplayer/TsPlayer.cpp:368:        FLOGI(mPlayerInstansNo,"is support 4K:%d\n", isTsVideoDecoderSupport4K);
AmTsplayer/TsPlayer.cpp:373:        FLOGI(mPlayerInstansNo,"PipeLine Tunnel Mode");
AmTsplayer/TsPlayer.cpp:383:        FLOGI(mPlayerInstansNo,"PipeLine NonTunnel Mode");
AmTsplayer/TsPlayer.cpp:426:    FLOGI(mPlayerInstansNo,"in\n");
AmTsplayer/TsPlayer.cpp:437:    FLOGI(mPlayerInstansNo,"end\n");
AmTsplayer/TsPlayer.cpp:458:        //FLOGI(mPlayerInstansNo,"platform demux:AmHwMultiDemux");
AmTsplayer/TsPlayer.cpp:461:        //FLOGI(mPlayerInstansNo,"platform demux:AmHwDemux");
AmTsplayer/TsPlayer.cpp:489:        //FLOGI(mPlayerInstansNo,"Demux type:%d\n",mDemuxType);
AmTsplayer/TsPlayer.cpp:513:            ALOGI("mDemuxWrap.reset(new AmSwDemuxWrapper())");
AmTsplayer/TsPlayer.cpp:534:            ALOGI("mDemuxWrap.reset(new AmSwDemuxWrapper())");
AmTsplayer/TsPlayer.cpp:576:    FLOGI(mPlayerInstansNo,"initCheck %d\n", mState == INITIALIZING);
AmTsplayer/TsPlayer.cpp:581:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/TsPlayer.cpp:616:        FLOGI(mPlayerInstansNo,"delete mVdTunnelMode\n");
AmTsplayer/TsPlayer.cpp:621:        FLOGI(mPlayerInstansNo,"delete mAdWrap\n");
AmTsplayer/TsPlayer.cpp:627:        FLOGI(mPlayerInstansNo,"delete mJsWrap %p\n",this);
AmTsplayer/TsPlayer.cpp:633:        FLOGI(mPlayerInstansNo,"mDemuxWrap.reset\n");
AmTsplayer/TsPlayer.cpp:638:        FLOGI(mPlayerInstansNo,"mAdSoftWrap Release\n");
AmTsplayer/TsPlayer.cpp:644:        FLOGI(mPlayerInstansNo,"mAdAdecWrap Release\n");
AmTsplayer/TsPlayer.cpp:660:        FLOGI(mPlayerInstansNo,"mVdNonTunnelMode Stop()\n");
AmTsplayer/TsPlayer.cpp:662:        FLOGI(mPlayerInstansNo,"mVdNonTunnelMode clear()\n");
AmTsplayer/TsPlayer.cpp:669:        FLOGI(mPlayerInstansNo,"mRenderer clear\n");
AmTsplayer/TsPlayer.cpp:673:    FLOGI(mPlayerInstansNo,"--->unregisterPlayer  in\n");
AmTsplayer/TsPlayer.cpp:676:    FLOGI(mPlayerInstansNo,"--->unregisterPlayer ok total:%d\n",total);
AmTsplayer/TsPlayer.cpp:683:    FLOGI(mPlayerInstansNo,"release end\n");
AmTsplayer/TsPlayer.cpp:698:    FLOGI(mPlayerInstansNo,"mediasyncId : %d\n",mediasyncId);
AmTsplayer/TsPlayer.cpp:816:           // ALOGI("mAudioNewPts:%lld mAudioRendmediaTimeUs:%lld \n",mAudioNewPts,mAudioRendmediaTimeUs);
AmTsplayer/TsPlayer.cpp:827:                //ALOGI("mAudioFirstPtsUs:%lld \n",mAudioFirstPtsUs);
AmTsplayer/TsPlayer.cpp:903:                    FLOGI(mPlayerInstansNo,"audio_delay_time:%" PRId64 "us mediasync acache:%" PRId64 "us",
AmTsplayer/TsPlayer.cpp:942:        FLOGI(mPlayerInstansNo,"AudioNewPtsUs:%" PRId64 " firstPts:%" PRId64 " RendPtsUs:%" PRId64 " audio_delay_time:%" PRId64 " ms\n",
AmTsplayer/TsPlayer.cpp:1011:                            FLOGI(mPlayerInstansNo,
AmTsplayer/TsPlayer.cpp:1021:                            FLOGI(mPlayerInstansNo,
AmTsplayer/TsPlayer.cpp:1039:                    FLOGI(mPlayerInstansNo,"1-->demux inside discontinues mVideoNewPts:%" PRId64 " - VideoDemuxPts:%" PRId64 "= %" PRId64 "",
AmTsplayer/TsPlayer.cpp:1055:                    FLOGI(mPlayerInstansNo,"1-->dicontinue video_delay_time:%" PRId64 " PtsBefore-RendTime=%" PRId64 " ,NewPts-PtsAfter=%" PRId64 " DemuxNewVPts:%" PRId64 " Diff:%" PRId64 "\n",
AmTsplayer/TsPlayer.cpp:1089:                            FLOGI(mPlayerInstansNo,"2-->dicontinue video_delay_time:%" PRId64 " PtsBefore-RendmediaTime=%" PRId64 " ,NewPts-PtsAfter=%" PRId64 " DemuxVPts:%" PRId64 "\n",
AmTsplayer/TsPlayer.cpp:1126:            FLOGI(mPlayerInstansNo,"VideoNewPtsUs:%" PRId64 " firstPts:%" PRId64 " RendPtsUs:%" PRId64 " video_delay_time:%" PRId64 " ms\n",
AmTsplayer/TsPlayer.cpp:1242:            //FLOGI(mPlayerInstansNo,"wp:0x%x rp:0x%x size:%d\n",writeDecoder_stbuf_wp,stbuf_rp,writeDataLen);
AmTsplayer/TsPlayer.cpp:1287:        FLOGI(mPlayerInstansNo,"start:0x%x end:0x%x wp:0x%x rp:0x%x \n",start_addr,
AmTsplayer/TsPlayer.cpp:1291:        FLOGI(mPlayerInstansNo,"VfreeSize:%d VUseSize:%d AfreeSize:%d AUseSize:%d videoCache:%" PRId64 " ms audioCache:%" PRId64 " ms\n",
AmTsplayer/TsPlayer.cpp:1329:        FLOGI(mPlayerInstansNo,"get video size:%d \n",mVideoBufferStat.size);
AmTsplayer/TsPlayer.cpp:1336:        FLOGI(mPlayerInstansNo,"get audio size:%d \n",mAudioBufferStat.size);
AmTsplayer/TsPlayer.cpp:1373:    //FLOGI(mPlayerInstansNo,"use_size:%d video free_size:%d total:%d \n",
AmTsplayer/TsPlayer.cpp:1381:            FLOGI(mPlayerInstansNo,"No Write TS Data video use_size:%d video free_size:%d \n",
AmTsplayer/TsPlayer.cpp:1467:        FLOGI(mPlayerInstansNo,"isVideoNeedRetry:%d isAudioNeedRetry:%d need_retry:%d isSpecialCase:%d v.data_len:%d mStopVideoDecodingLevel:%d mFirstFrame:%d",
AmTsplayer/TsPlayer.cpp:1518:        //FLOGI(mPlayerInstansNo,"NoWrite:%d writerDecoderSize:%d dqbufFailCount:%d\n",
AmTsplayer/TsPlayer.cpp:1524:                FLOGI(mPlayerInstansNo,"No Write TsData BlockVideoBufferLevel:%d BlockVideoCount:%d dqbufFailCount:%d, mVideoMinDelayTime:%" PRId64 ", "
AmTsplayer/TsPlayer.cpp:1567:        FLOGE(mPlayerInstansNo,"buffer_level AmDemuxWrapperGetDmxMenInfo fail \n");
AmTsplayer/TsPlayer.cpp:1580:        FLOGI(mPlayerInstansNo,"-->use_size : %d AudioDelayTime:%" PRId64 " s mOnlyAudioWriteTsTotalSize:%d\n",
AmTsplayer/TsPlayer.cpp:1620:                       FLOGI(mPlayerInstansNo,"Audio is not ready to finish audio_ready_flag : %d \n",audio_ready_flag);
AmTsplayer/TsPlayer.cpp:1696:            FLOGI(mPlayerInstansNo,"audio_data_len:%d audio_delay_time:%" PRId64 " ms amstream_audio_delay_time:%" PRId64 " ms buf_latency:%d ms abuf.data_len:%d stream_level:%d\n",
AmTsplayer/TsPlayer.cpp:1703:            FLOGI(mPlayerInstansNo,"vbuf.data_len:%d video_delay_time:%" PRId64 " ms frame_count:%d error_count:%d need_retry:%d\n",vbuf.data_len,
AmTsplayer/TsPlayer.cpp:1729:                FLOGI(mPlayerInstansNo,"decoderVideoFrameCount:%d frame_count:%d NowTimeUs:%" PRId64 " mWriteNowUs:%" PRId64 " diff:%" PRId64 "",
AmTsplayer/TsPlayer.cpp:1749:                    FLOGI(mPlayerInstansNo,"wait vbufLen:%d abufLen:%d blockAbufer:%d blockVbufer:%d videoDelayTime:%" PRId64 " ms audioDelayTime:%" PRId64 " ms\n",
AmTsplayer/TsPlayer.cpp:1770:                FLOGI(mPlayerInstansNo,"Write data wait bufferlevel vbuf.data_len:%d abuf.data_len:%d  video_delay_time:%" PRId64 " audio delay time:%" PRId64 "\n",
AmTsplayer/TsPlayer.cpp:1862:                    FLOGI(mPlayerInstansNo,"Use Audiohal Cache curAudioEsCache:%d us, audio_delay_time:%" PRId64 " us\n",
AmTsplayer/TsPlayer.cpp:1902:            FLOGI(mPlayerInstansNo,"audio_data_len:%d abuf.size:%d audio_delay_time:%" PRId64 " ms audio_need_retry:%d, SpecialCase:%d\n",
AmTsplayer/TsPlayer.cpp:1908:            FLOGI(mPlayerInstansNo,"vbuf_data_len:%d vbuf.size:%d video_delay_time:%" PRId64 " ms video_need_retry:%d need_retry:%d avdiff:%" PRId64 "\n",
AmTsplayer/TsPlayer.cpp:1976:                    FLOGI(mPlayerInstansNo,"decoderVideoFrameCount:%d  pStat.frame_count:%d time diff:%" PRId64 "\n",decoderVideoFrameCount,pStat.frame_count,NowTimeUs - mWriteNowUs);
AmTsplayer/TsPlayer.cpp:1981:                FLOGI(mPlayerInstansNo,"read_pointer:%d write_pointer:%d writeDataLen:%d queueCount:%d dqbufFailCount:%d AudioNoWrite:%d VideoNoWrite:%d",
AmTsplayer/TsPlayer.cpp:1993:                    FLOGI(mPlayerInstansNo,"wait vbufLen:%d abufLen:%d videoDelayTime:%" PRId64 " ms audioDelayTime:%" PRId64 " ms\n",
AmTsplayer/TsPlayer.cpp:2008:                FLOGI(mPlayerInstansNo,"Write data wait bufferlevel v_free_len:%d v_size:%d a_free_len:%d a_size:%d video_delay_time:%" PRId64 " audio_delay_time:%" PRId64 "\n",
AmTsplayer/TsPlayer.cpp:2047:            FLOGI(mPlayerInstansNo,"<-------> in type:%s, timestamp:%" PRId64 ", len:%d \n",AV_type?"video":"audio", timestamp, len);
AmTsplayer/TsPlayer.cpp:2053:                    FLOGI(mPlayerInstansNo,"first video vpts:%" PRIx64 "(90K)",timestamp);
AmTsplayer/TsPlayer.cpp:2055:                FLOGI(mPlayerInstansNo,"--->video write in IntervalsTime_:%" PRId64 " vpts:%" PRIx64 "(90K) len:%d",
AmTsplayer/TsPlayer.cpp:2061:                FLOGI(mPlayerInstansNo,"video no write!");
AmTsplayer/TsPlayer.cpp:2083:                FLOGI(mPlayerInstansNo,"input audio pts:%" PRId64 ". ", timestamp);
AmTsplayer/TsPlayer.cpp:2087:                FLOGI(mPlayerInstansNo,"audio no write!");
AmTsplayer/TsPlayer.cpp:2115:                    FLOGI(mPlayerInstansNo,"first audio apts:%" PRIx64 "(90K)",timestamp);
AmTsplayer/TsPlayer.cpp:2117:                FLOGI(mPlayerInstansNo,"*******audio write in IntervalsTime_:%" PRId64 " apts:%" PRIx64 "(90K) len:%d",
AmTsplayer/TsPlayer.cpp:2124:                    FLOGE(mPlayerInstansNo,"write audio frame failed plz retry");
AmTsplayer/TsPlayer.cpp:2134:                FLOGI(mPlayerInstansNo, "<-------%s retry len:%d \n", (AV_type == 1 ? "video" : "audio"), len);
AmTsplayer/TsPlayer.cpp:2136:                FLOGI(mPlayerInstansNo, "------->%s ok len:%d \n", (AV_type == 1 ? "video" : "audio"), len);
AmTsplayer/TsPlayer.cpp:2164:        ALOGI("---------------------> enter WriteData vpid == 0x1FFF and apid == 0x1FFF ts len : %d \n",len);
AmTsplayer/TsPlayer.cpp:2178:                FLOGI(mPlayerInstansNo,"<-------> in len:%d \n",len);
AmTsplayer/TsPlayer.cpp:2184:                        FLOGI(mPlayerInstansNo,"<------- retry len:%d \n",len);
AmTsplayer/TsPlayer.cpp:2192:                        FLOGI(mPlayerInstansNo,"<------- retry len:%d \n",len);
AmTsplayer/TsPlayer.cpp:2198:                FLOGI(mPlayerInstansNo,"WriteData vpid==0x1FFF&&apid==0x1FFF len:%d \n",len);
AmTsplayer/TsPlayer.cpp:2204:            FLOGI(mPlayerInstansNo,"<-------> in len:%d \n",len);
AmTsplayer/TsPlayer.cpp:2209:                    FLOGI(mPlayerInstansNo,"<-------  retry len:%d \n",len);
AmTsplayer/TsPlayer.cpp:2218:                    FLOGI(mPlayerInstansNo,"<-------  retry len:%d",len);
AmTsplayer/TsPlayer.cpp:2229:            FLOGI(mPlayerInstansNo,"<------- retry len:%d ret:%d\n",len,ret);
AmTsplayer/TsPlayer.cpp:2235:        FLOGI(mPlayerInstansNo,"------->  ok len:%d ret:%d\n",len,ret);
AmTsplayer/TsPlayer.cpp:2250:        FLOGI(mPlayerInstansNo,"ok,Now Mode == Change Mode(%s)\n",
AmTsplayer/TsPlayer.cpp:2255:        FLOGI(mPlayerInstansNo,"in,Now Work Mode:(%s)--->change work mode:(%s)",
AmTsplayer/TsPlayer.cpp:2278:      //ALOGI("%s:%d,mode:%d\n",__FUNCTION__,__LINE__,mode);
AmTsplayer/TsPlayer.cpp:2279:        FLOGI(mPlayerInstansNo,"ok\n");
AmTsplayer/TsPlayer.cpp:2355:        //FLOGI(mPlayerInstansNo,"uStreamType : %d  get pts failed  %lld\n",uStreamType,mRendmediaTime);
AmTsplayer/TsPlayer.cpp:2408:        //FLOGI(mPlayerInstansNo,"no need to change unit.");
AmTsplayer/TsPlayer.cpp:2463:        //FLOGI(mPlayerInstansNo,"uStreamType : %d  get first pts failed  %lld\n",uStreamType,firstMediaTime);
AmTsplayer/TsPlayer.cpp:2471:    FLOGI(mPlayerInstansNo,"mode:%d\n",mode);
AmTsplayer/TsPlayer.cpp:2487:    FLOGI(mPlayerInstansNo,"mode:%d force_tsync_mode:%d\n",mode,force_tsync_mode);
AmTsplayer/TsPlayer.cpp:2520:                FLOGI(mPlayerInstansNo,"close mPcrpid:0x%x\n",mPcrpid);
AmTsplayer/TsPlayer.cpp:2535:        FLOGI(mPlayerInstansNo,"Repeat to set the PCR PID:0x%x  mPcrpid:0x%x\n",pid,mPcrpid);
AmTsplayer/TsPlayer.cpp:2539:    FLOGI(mPlayerInstansNo,"mPcrpid:0x%x\n",mPcrpid);
AmTsplayer/TsPlayer.cpp:2572:            //ALOGI("GetDelayTime time : %lld ms\n",*time);
AmTsplayer/TsPlayer.cpp:2585:           // ALOGI(" GetDelayTime *time:%lld ms\n",*time);
AmTsplayer/TsPlayer.cpp:2622:            ALOGI("only support get video or audio cache uStreamType:%d",stream_type);
AmTsplayer/TsPlayer.cpp:2662:    FLOGI(mPlayerInstansNo,"scale:%f\n",scale);
AmTsplayer/TsPlayer.cpp:2710:    FLOGI(mPlayerInstansNo,"trickmode:%d\n",trickmode);
AmTsplayer/TsPlayer.cpp:2797:    FLOGI(mPlayerInstansNo,"x:%d y:%d w:%d h:%d\n", x, y, width, height);
AmTsplayer/TsPlayer.cpp:2821:    FLOGI(mPlayerInstansNo,"left:%d top:%d right:%d bottom:%d\n", left, top, right, bottom);
AmTsplayer/TsPlayer.cpp:2853:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/TsPlayer.cpp:2873:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/TsPlayer.cpp:2882:            //FLOGI(mPlayerInstansNo,"videoShow process will delay \n");
AmTsplayer/TsPlayer.cpp:2886:    FLOGI(mPlayerInstansNo,"end");
AmTsplayer/TsPlayer.cpp:2891:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/TsPlayer.cpp:2904:    FLOGI(mPlayerInstansNo,"ok");
AmTsplayer/TsPlayer.cpp:2929:    //ALOGI("SetVideoParams\n");
AmTsplayer/TsPlayer.cpp:2931:        FLOGI(mPlayerInstansNo,"DEBUG NoVideo \n");
AmTsplayer/TsPlayer.cpp:2935:        FLOGE(mPlayerInstansNo,"error: (pParams == NULL) \n");
AmTsplayer/TsPlayer.cpp:2942:    FLOGI(mPlayerInstansNo,"vpid:0x%x vcodecType:%d vsecuLevel 0x%x\n",mVideoCfg.vpid,mVideoCfg.vcodecType,mVideoCfg.vsecuLevel);
AmTsplayer/TsPlayer.cpp:2947:    FLOGI(mPlayerInstansNo,"in blackout:%d",blackout);
AmTsplayer/TsPlayer.cpp:2960:    FLOGI(mPlayerInstansNo,"out");
AmTsplayer/TsPlayer.cpp:2968:        FLOGI(mPlayerInstansNo, "video has stopped!\n");
AmTsplayer/TsPlayer.cpp:2995:        FLOGI(mPlayerInstansNo, "video has stopped!\n");
AmTsplayer/TsPlayer.cpp:3012:    FLOGI(mPlayerInstansNo, "in");
AmTsplayer/TsPlayer.cpp:3014:        FLOGI(mPlayerInstansNo, "video has started, don't start duplicated\n");
AmTsplayer/TsPlayer.cpp:3022:        FLOGI(mPlayerInstansNo," Video PID invalid, return it\n");
AmTsplayer/TsPlayer.cpp:3031:            FLOGI(mPlayerInstansNo,"fd4Recv == NULL\n");
AmTsplayer/TsPlayer.cpp:3038:            FLOGI(mPlayerInstansNo,"mVideoEsFile == NULL\n");
AmTsplayer/TsPlayer.cpp:3043:        FLOGI(mPlayerInstansNo,"DEBUG NoVideo \n");
AmTsplayer/TsPlayer.cpp:3048:        FLOGI(mPlayerInstansNo,"unsupport format:%d", mVideoCfg.vcodecType);
AmTsplayer/TsPlayer.cpp:3059:            FLOGI(mPlayerInstansNo,"Video has started,busy\n");
AmTsplayer/TsPlayer.cpp:3084:        FLOGI(mPlayerInstansNo,"tunnel mode, mState:%d\n", mState);
AmTsplayer/TsPlayer.cpp:3087:            FLOGI(mPlayerInstansNo,"Reset Video\n");
AmTsplayer/TsPlayer.cpp:3110:            FLOGI(mPlayerInstansNo,"new VideodecNonTunnelWrapper display mpde:%d\n",(int)mode);
AmTsplayer/TsPlayer.cpp:3132:            FLOGI(mPlayerInstansNo,"non tunnel mode\n");
AmTsplayer/TsPlayer.cpp:3150:                    FLOGI(mPlayerInstansNo,"Reset Video\n");
AmTsplayer/TsPlayer.cpp:3185:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/TsPlayer.cpp:3192:    FLOGI(mPlayerInstansNo,"finished\n");
AmTsplayer/TsPlayer.cpp:3197:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/TsPlayer.cpp:3204:    FLOGI(mPlayerInstansNo,"ResumeVideoDecoding finished\n");
AmTsplayer/TsPlayer.cpp:3211:    FLOGI(mPlayerInstansNo,"in\n");
AmTsplayer/TsPlayer.cpp:3230:        FLOGI(mPlayerInstansNo, "video has stopped, don't stop duplicated\n");
AmTsplayer/TsPlayer.cpp:3271:    FLOGI(mPlayerInstansNo,"end response\n");
AmTsplayer/TsPlayer.cpp:3278:    FLOGI(mPlayerInstansNo,"volume:%d\n",volume);
AmTsplayer/TsPlayer.cpp:3280:        FLOGI(mPlayerInstansNo,"it is noaudio");
AmTsplayer/TsPlayer.cpp:3322:    FLOGI(mPlayerInstansNo,"volume:%d\n",volume);
AmTsplayer/TsPlayer.cpp:3331:        FLOGE(mPlayerInstansNo,"volume is null\n");
AmTsplayer/TsPlayer.cpp:3368:int32_t TsPlayer::SetAudioMute(bool_t analog_mute,
AmTsplayer/TsPlayer.cpp:3370:    FLOGI(mPlayerInstansNo,"analog_mute:%d digital_mute:%d\n",analog_mute,digital_mute);
AmTsplayer/TsPlayer.cpp:3371:    mAudioCtrl.analog_mute = analog_mute;
AmTsplayer/TsPlayer.cpp:3374:        FLOGI(mPlayerInstansNo,"it is noaudio");
AmTsplayer/TsPlayer.cpp:3397:int32_t TsPlayer::GetAudioMute(bool_t *analog_mute,
AmTsplayer/TsPlayer.cpp:3399:    UNUSED(analog_mute);
AmTsplayer/TsPlayer.cpp:3417:    FLOGI(mPlayerInstansNo,"analog_mute:%d digital_mute:%d ",(analog_mute != NULL) ? (*analog_mute):false,*digital_mute);
AmTsplayer/TsPlayer.cpp:3424:        FLOGI(mPlayerInstansNo,"DEBUG mNoAudio");
AmTsplayer/TsPlayer.cpp:3427:    FLOGI(mPlayerInstansNo,"(Previous apid:0x%x)",mAudioCfg.apid);
AmTsplayer/TsPlayer.cpp:3435:        FLOGE(mPlayerInstansNo,"error apid:0x%x \n",pAudioParams->pid);
AmTsplayer/TsPlayer.cpp:3441:    FLOGI(mPlayerInstansNo,"pid:0x%x dmxId:%d codetype:%d\n",mAudioCfg.apid,
AmTsplayer/TsPlayer.cpp:3511:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/TsPlayer.cpp:3514:        FLOGI(mPlayerInstansNo,"DEBUG mNoAudio");
AmTsplayer/TsPlayer.cpp:3522:        FLOGI(mPlayerInstansNo, "audio has started, don't start duplicated\n");
AmTsplayer/TsPlayer.cpp:3527:        FLOGI(mPlayerInstansNo," Audio PID invalid, return it\n");
AmTsplayer/TsPlayer.cpp:3538:                FLOGI(mPlayerInstansNo,"msg->post(kAudioInitDelay)");
AmTsplayer/TsPlayer.cpp:3544:                FLOGI(mPlayerInstansNo,"Reset Audio\n");
AmTsplayer/TsPlayer.cpp:3555:            FLOGI(mPlayerInstansNo,"new VideodecNonTunnelWrapper\n");
AmTsplayer/TsPlayer.cpp:3572:            FLOGI(mPlayerInstansNo,"AmAudioHalWrapper setrender success\n");
AmTsplayer/TsPlayer.cpp:3595:                FLOGI(mPlayerInstansNo,"Audio has started,busy\n");
AmTsplayer/TsPlayer.cpp:3609:                FLOGI(mPlayerInstansNo,"new AudioSoftWrapper\n");
AmTsplayer/TsPlayer.cpp:3630:                            FLOGI(mPlayerInstansNo,"mAdSoftWrap->SetVolume:%d ",mAudioCtrl.audio_vol);
AmTsplayer/TsPlayer.cpp:3657:            FLOGI(mPlayerInstansNo,"new AudioAdecWrapper\n");
AmTsplayer/TsPlayer.cpp:3687:                FLOGI(mPlayerInstansNo,"mState:%d need start video firstly ",mState);
AmTsplayer/TsPlayer.cpp:3690:                FLOGI(mPlayerInstansNo,"start audio");
AmTsplayer/TsPlayer.cpp:3695:                FLOGI(mPlayerInstansNo,"Reset Audio\n");
AmTsplayer/TsPlayer.cpp:3715:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/TsPlayer.cpp:3719:    FLOGI(mPlayerInstansNo,"finished\n");
AmTsplayer/TsPlayer.cpp:3724:    FLOGI(mPlayerInstansNo,"in\n");
AmTsplayer/TsPlayer.cpp:3729:    FLOGI(mPlayerInstansNo,"finished\n");
AmTsplayer/TsPlayer.cpp:3738:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/TsPlayer.cpp:3741:        FLOGI(mPlayerInstansNo, "noaudio, stopaudio\n");
AmTsplayer/TsPlayer.cpp:3746:        FLOGI(mPlayerInstansNo, "audio has stopped, don't stop duplicated\n");
AmTsplayer/TsPlayer.cpp:3777:    FLOGI(mPlayerInstansNo,"response\n");
AmTsplayer/TsPlayer.cpp:3783:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/TsPlayer.cpp:3785:        FLOGI(mPlayerInstansNo,"DEBUG mNoAudio");
AmTsplayer/TsPlayer.cpp:3808:    FLOGI(mPlayerInstansNo,"master_vol:%d slave_vol:%d",master_vol,slave_vol);
AmTsplayer/TsPlayer.cpp:3832:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/TsPlayer.cpp:3843:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/TsPlayer.cpp:3936:                FLOGI(mPlayerInstansNo,"mVideoCfg.vsecuLevel:%d \n",mVideoCfg.vsecuLevel);
AmTsplayer/TsPlayer.cpp:3942:                FLOGI(mPlayerInstansNo,"mAudioCfg.asecuLevel:%d \n",mAudioCfg.asecuLevel);
AmTsplayer/TsPlayer.cpp:3948:                FLOGI(mPlayerInstansNo,"mAudioPatchManageMode set to :%d \n",mAudioPatchManageMode);
AmTsplayer/TsPlayer.cpp:3954:                FLOGI(mPlayerInstansNo,"SPDIF status set to :%d \n", *(int32_t*)arg);
AmTsplayer/TsPlayer.cpp:3963:                FLOGI(mPlayerInstansNo,"set wma extra descr:%s \n", (char*)arg);
AmTsplayer/TsPlayer.cpp:3976:                FLOGI(mPlayerInstansNo,"set audio samplerate:%d,channel:%d,channelmask:0x%02x,bittate:%d\n",
AmTsplayer/TsPlayer.cpp:3989:                FLOGI(mPlayerInstansNo,"mVideoRecoveryValue:%d \n", mVideoRecoveryValue);
AmTsplayer/TsPlayer.cpp:3995:                FLOGI(mPlayerInstansNo,"mVFrameCounterEnabled:%d \n", mVFrameCounterEnabled);
AmTsplayer/TsPlayer.cpp:4043:                FLOGI(mPlayerInstansNo,"mAudioCfg.extraDataSize:%u, mAudioCfg.extraData:%p\n",
AmTsplayer/TsPlayer.cpp:4077:               FLOGI(mPlayerInstansNo,"mResumePlayingPts %lld\n", (long long)mResumePlayingPts);
AmTsplayer/TsPlayer.cpp:4084:                FLOGI(mPlayerInstansNo,"outputFirstFrameBeforeAvSyncStage:%d \n", outputFirstFrameBeforeAvSyncStage);
AmTsplayer/TsPlayer.cpp:4094:                FLOGI(mPlayerInstansNo,"set audio patch address:%d \n",mAudioPatchAddress);
AmTsplayer/TsPlayer.cpp:4100:                FLOGI(mPlayerInstansNo,"mFastVideoStateValue:%d \n", mFastVideoStateValue);
AmTsplayer/TsPlayer.cpp:4116:                FLOGI(mPlayerInstansNo,"setting video cache %d ms\n", mSetVideoCache);
AmTsplayer/TsPlayer.cpp:4122:                FLOGI(mPlayerInstansNo,"setting audio cache %d ms\n", mSetAudioCache);
AmTsplayer/TsPlayer.cpp:4135:                FLOGI(mPlayerInstansNo,"mVideoTransform:%d \n", mVideoTransform);
AmTsplayer/TsPlayer.cpp:4139:            FLOGI(mPlayerInstansNo,"error type:%d \n",type);
AmTsplayer/TsPlayer.cpp:4151:            FLOGI(mPlayerInstansNo,"GET_AC4_ACTIVE_PRESENTATIONS_ID \n");
AmTsplayer/TsPlayer.cpp:4158:            //FLOGV(mPlayerInstansNo,"GET_DMX_ES_OUTPUT_STATUS \n");
AmTsplayer/TsPlayer.cpp:4199:            FLOGI(mPlayerInstansNo,"error type:%d \n",type);
AmTsplayer/TsPlayer.cpp:4228:        FLOGI(mPlayerInstansNo,"displayFrameCount:%" PRId64 " videoDuration:%" PRId64 " ms systemTimeDiff:%" PRId64 " ms theoryDropFrameCount:%d.\n",
AmTsplayer/TsPlayer.cpp:4238:        FLOGI(mPlayerInstansNo, "getState ERROR: PARAMS NULL Pointer\n");
AmTsplayer/TsPlayer.cpp:4287:        FLOGI(mPlayerInstansNo, "Am_AudioHalWrapper No Instance\n");
AmTsplayer/TsPlayer.cpp:4292:        FLOGI(mPlayerInstansNo, "GetJsonStat ERROR Return: %d\n", ret);
AmTsplayer/TsPlayer.cpp:4296:            FLOGI(mPlayerInstansNo, "GetJsonStat by exist mJsWrap Instance\n");
AmTsplayer/TsPlayer.cpp:4299:            FLOGI(mPlayerInstansNo, "GetJsonStat by new mJsWrap Instance\n");
AmTsplayer/TsPlayer.cpp:4306:                FLOGI(mPlayerInstansNo, "GetJsonStat Fail [ret:%d, return Size:%d]\n", ret,(int) state->actual_len);
AmTsplayer/TsPlayer.cpp:4310:        FLOGI(mPlayerInstansNo, "GetJsonStat OK [ret:%d, return Size:%d]\n", ret,(int)state->actual_len);
AmTsplayer/TsPlayer.cpp:4361:                    FLOGI(mPlayerInstansNo,"VideoNewPtsUs:%" PRId64 " firstPtsUs:%" PRId64 " RendPtsUs:%" PRId64 " video_delay_time:%" PRId64 " ms, Queue(%d, %d, diff:%d)",
AmTsplayer/TsPlayer.cpp:4395:                    FLOGI(mPlayerInstansNo,"AudioNewPtsUs:%" PRId64 " firstPts:%" PRId64 " RendPtsUs:%" PRId64 " audio_delay_time:%" PRId64 " ms, cacheCount:(%d, %d)\n",
AmTsplayer/TsPlayer.cpp:4444:                    FLOGI(mPlayerInstansNo,"this platform cannot support VVC decoder");
AmTsplayer/TsPlayer.cpp:4449:            FLOGI(mPlayerInstansNo,"kWhatStart\n");
AmTsplayer/TsPlayer.cpp:4458:                    FLOGI(mPlayerInstansNo,"kWhatStart dmx_buf_phy_start:0x%x dmx_total_size:%d\n",
AmTsplayer/TsPlayer.cpp:4468:                FLOGI(mPlayerInstansNo,"kWhatStart mEsDataHandler->StartVideoFilter \n");
AmTsplayer/TsPlayer.cpp:4516:                        FLOGI(mPlayerInstansNo,"kWhatStart hasvideo:%d\n",hasdtvvideo);
AmTsplayer/TsPlayer.cpp:4605:            FLOGI(mPlayerInstansNo,"kWhatStart vtrickMode %d, tmode %d\n",mPlayerCtrl.vtrickMode, tmode);
AmTsplayer/TsPlayer.cpp:4618:                        FLOGI(mPlayerInstansNo,"this platform cannot support VVC decoder");
AmTsplayer/TsPlayer.cpp:4630:                        FLOGI(mPlayerInstansNo,"videoShow process again success\n");
AmTsplayer/TsPlayer.cpp:4638:                    FLOGI(mPlayerInstansNo,"kWhatStartVideo dmx_buf_phy_start:0x%x dmx_total_size:%d\n",
AmTsplayer/TsPlayer.cpp:4643:                    FLOGI(mPlayerInstansNo,"kWhatStartVideo mWriteEs->OnWriteEsStart Video\n");
AmTsplayer/TsPlayer.cpp:4732:                    FLOGI(mPlayerInstansNo,"mVdNonTunnelMode->Initialize has init mVideoCfg.vpid:0x%x \n",mVideoCfg.vpid);
AmTsplayer/TsPlayer.cpp:4784:                        FLOGI(mPlayerInstansNo,"kWhatStartAudio mEsDataHandler->SetAudioParm \n");
AmTsplayer/TsPlayer.cpp:4786:                        FLOGI(mPlayerInstansNo,"kWhatStartAudio mEsDataHandler->StartAudioFilter \n");
AmTsplayer/TsPlayer.cpp:4792:                        FLOGI(mPlayerInstansNo,"mAdSoftWrap start fail:%d,  use vmaster", ret);
AmTsplayer/TsPlayer.cpp:4797:                        FLOGI(mPlayerInstansNo,"kWhatStartAudio mEsDataHandler->SetAudioParmAdec \n");
AmTsplayer/TsPlayer.cpp:4799:                        FLOGI(mPlayerInstansNo,"kWhatStartAudio mEsDataHandler->StartAudioFilter \n");
AmTsplayer/TsPlayer.cpp:4812:                    FLOGI(mPlayerInstansNo,"kWhatStartAudio set hasvideo:%d\n",hasdtvvideo);
AmTsplayer/TsPlayer.cpp:4860:                FLOGE(mPlayerInstansNo," Warning instance was preempted and send message to upper!\n");
AmTsplayer/TsPlayer.cpp:4894:                    ALOGI("kWhatUpdateStatus states %d num %d, pts [%" PRId64 " -> %" PRId64 "], [%d,%d]\n",
AmTsplayer/TsPlayer.cpp:4902:                    FLOGI(mPlayerInstansNo,"report scramble event\n");
AmTsplayer/TsPlayer.cpp:4911:                    FLOGI(mPlayerInstansNo,"report first frame event\n");
AmTsplayer/TsPlayer.cpp:4940:                            FLOGI(mPlayerInstansNo,"kWhatUpdateStatus AUDIO_UNDERRUN  audio_delay_time:%" PRId64 " ms\n", audio_delay_time);
AmTsplayer/TsPlayer.cpp:4942:                                ERRORMONITOR_LOG_TYPE_LOGCAT, AUDIO_ERROR_EVENT_NO_SOUND, "audio underrun");
AmTsplayer/TsPlayer.cpp:4951:            FLOGI(mPlayerInstansNo,"kWhatResetVideo\n");
AmTsplayer/TsPlayer.cpp:4973:            FLOGI(mPlayerInstansNo,"kWhatResetAudio\n");
AmTsplayer/TsPlayer.cpp:4984:                FLOGI(mPlayerInstansNo,"kWhatResetAudio set hasvideo:%d\n",hasdtvvideo);
AmTsplayer/TsPlayer.cpp:5001:                        FLOGI(mPlayerInstansNo,"kWhatResetAudio get mSyncInsId:%d\n",mSyncInsId);
AmTsplayer/TsPlayer.cpp:5044:                    FLOGI(mPlayerInstansNo,"kWhatStopAudio reset (apid:0x%x)\n",audiopid);
AmTsplayer/TsPlayer.cpp:5075:                        FLOGI(mPlayerInstansNo,
AmTsplayer/TsPlayer.cpp:5087:                    FLOGI(mPlayerInstansNo,"kWhatStopAudio mDemuxWrap.AmDemuxWrapperStop(apid:0x%x)\n",mAudioCfg.apid);
AmTsplayer/TsPlayer.cpp:5095:                    FLOGI(mPlayerInstansNo,"kWhatStopAudio mEsDataHandler->StopAudioFilter \n");
AmTsplayer/TsPlayer.cpp:5106:                    FLOGI(mPlayerInstansNo,"kWhatStopAudio mAdSoftWrap->Stop()\n");
AmTsplayer/TsPlayer.cpp:5108:                    FLOGI(mPlayerInstansNo,"kWhatStopAudio mAdSoftWrap->Release()\n");
AmTsplayer/TsPlayer.cpp:5110:                    FLOGI(mPlayerInstansNo,"kWhatStopAudio mAdSoftWrap.clear()\n");
AmTsplayer/TsPlayer.cpp:5112:                    FLOGI(mPlayerInstansNo,"kWhatStopAudio mAdSoftWrap = NULL\n");
AmTsplayer/TsPlayer.cpp:5115:                    FLOGI(mPlayerInstansNo,"kWhatStopAudio mAdAdecWrap->Stop()\n");
AmTsplayer/TsPlayer.cpp:5117:                    FLOGI(mPlayerInstansNo,"kWhatStopAudio mAdAdecWrap->Release()\n");
AmTsplayer/TsPlayer.cpp:5119:                    FLOGI(mPlayerInstansNo,"kWhatStopAudio mAdAdecWrap.clear()\n");
AmTsplayer/TsPlayer.cpp:5121:                    FLOGI(mPlayerInstansNo,"kWhatStopAudio mAdAdecWrap = NULL\n");
AmTsplayer/TsPlayer.cpp:5166:                FLOGI(mPlayerInstansNo,"kWhatStopVideo mDemuxWrap.AmDemuxWrapperStop(vpid:0x%x)",mVideoCfg.vpid);
AmTsplayer/TsPlayer.cpp:5192:                    FLOGI(mPlayerInstansNo,"kWhatUpdateAudioStatus auio_change ch=%u ch_mask=%u samp=%u",
AmTsplayer/TsPlayer.cpp:5228:                        ERRORMONITOR_LOG_TYPE_LOGCAT, AUDIO_ERROR_EVENT_NO_SOUND, "no audio first frame");
AmTsplayer/TsPlayer.cpp:5240:            //FLOGI(mPlayerInstansNo,"kWhatUpdateHandlerStatus mDmxGetEs:%d ",mDmxGetEs);
AmTsplayer/TsPlayer.cpp:5243:            //FLOGI(mPlayerInstansNo,"kWhatUpdateHandlerStatus in ");
AmTsplayer/TsPlayer.cpp:5248:            debugLevel = mDebugServer->getModuleLogLevel(this);
AmTsplayer/TsPlayer.cpp:5277:                    FLOGI(mPlayerInstansNo,"kWhatUpdateHandlerStatus first get CheckinVpts:%" PRId64 " FrameCount:%d\n",mLastCheckinVpts,mLastFrameCount);
AmTsplayer/TsPlayer.cpp:5282:                    FLOGI(mPlayerInstansNo,"kWhatUpdateHandlerStatus  get CheckinVpts:%" PRId64 " FrameCount:%d\n",mLastCheckinVpts,mLastFrameCount);
AmTsplayer/TsPlayer.cpp:5292:                            FLOGI(mPlayerInstansNo,"DATA_LOSS mLastCheckinVpts:%" PRId64 " mDmxGetEs:%d ",
AmTsplayer/TsPlayer.cpp:5304:                            FLOGI(mPlayerInstansNo,"DATA_RESUME");
AmTsplayer/TsPlayer.cpp:5313:                                        FLOGI(mPlayerInstansNo,"DECODER_DATA_LOSS mLastFrameCount:%d dqbufFailCount:%d mVideoEsInvalid:%d \n",
AmTsplayer/TsPlayer.cpp:5328:                                    FLOGI(mPlayerInstansNo,"DECODER_DATA_RESUME");
AmTsplayer/TsPlayer.cpp:5356:                    FLOGI(mPlayerInstansNo,"kWhatUpdateHandlerStatus first get checkinApts:%" PRId64 "",mLastCheckinApts);
AmTsplayer/TsPlayer.cpp:5369:                    FLOGI(mPlayerInstansNo,"kWhatUpdateHandlerStatus get checkinApts:%" PRId64 " PtsDtsFlag:%d",mLastCheckinApts,audioPtsDtsFlag);
AmTsplayer/TsPlayer.cpp:5375:                            FLOGI(mPlayerInstansNo,"DATA_LOSS mLastCheckinApts:%" PRId64 "",
AmTsplayer/TsPlayer.cpp:5384:                            FLOGI(mPlayerInstansNo,"DATA_RESUME");
AmTsplayer/TsPlayer.cpp:5389:                                    FLOGI(mPlayerInstansNo,"DECODER_DATA_LOSS mLastCheckoutApts:%" PRId64 "",
AmTsplayer/TsPlayer.cpp:5401:                                    FLOGI(mPlayerInstansNo,"DECODER_DATA_RESUME");
AmTsplayer/TsPlayer.cpp:5451:                    FLOGI(mPlayerInstansNo,"audio stop ok %" PRId64 " us",TSPLooper::GetNowUs() - nowUs);
AmTsplayer/TsPlayer.cpp:5462:                FLOGI(mPlayerInstansNo,"kWhatResetAudio set hasvideo:%d\n",hasdtvvideo);
AmTsplayer/TsPlayer.cpp:5492:                FLOGI(mPlayerInstansNo,"pause find stream_type : %d \n",stream_type);
AmTsplayer/TsPlayer.cpp:5495:            FLOGI(mPlayerInstansNo,"pause in ,stream_type: %d \n",stream_type);
AmTsplayer/TsPlayer.cpp:5511:                    FLOGI(mPlayerInstansNo,"mVdNonTunnelMode->Pause() finished");
AmTsplayer/TsPlayer.cpp:5523:                            FLOGI(mPlayerInstansNo,"pause finished\n");
AmTsplayer/TsPlayer.cpp:5544:            FLOGI(mPlayerInstansNo,"pause out ,stream_type: %d \n",stream_type);
AmTsplayer/TsPlayer.cpp:5551:                FLOGI(mPlayerInstansNo,"resume find stream_type : %d \n",stream_type);
AmTsplayer/TsPlayer.cpp:5554:            FLOGI(mPlayerInstansNo,"resume in ,stream_type: %d \n",stream_type);
AmTsplayer/TsPlayer.cpp:5566:                    FLOGI(mPlayerInstansNo,"mVdNonTunnelMode->Resume finished\n");
AmTsplayer/TsPlayer.cpp:5584:                            FLOGI(mPlayerInstansNo,"resume finished\n");
AmTsplayer/TsPlayer.cpp:5605:            FLOGI(mPlayerInstansNo,"resume out ,stream_type: %d \n",stream_type);
AmTsplayer/TsPlayer.cpp:5619:                            ERRORMONITOR_LOG_TYPE_LOGCAT, VIDEO_ERROR_EVENT_BLACK_SCREEN, "no video first frame");
AmTsplayer/TsPlayer.cpp:5624:                            ERRORMONITOR_LOG_TYPE_LOGCAT, VIDEO_ERROR_EVENT_FREEZE, "video stuck");
AmTsplayer/TsPlayer.cpp:5629:                            ERRORMONITOR_LOG_TYPE_LOGCAT, AUDIO_ERROR_EVENT_NO_SOUND, "audio discontinue");
AmTsplayer/TsPlayer.cpp:5700:    FLOGI(mPlayerInstansNo,"type %d fmt %d\n",typeinplayer,vfmt);
AmTsplayer/TsPlayer.cpp:5809:    FLOGI(mPlayerInstansNo,"type %d fmt %d\n",typeinplayer,afmt);
AmTsplayer/TsPlayer.cpp:5852:    //FLOGI(mPlayerInstansNo,"type %d fmt %d\n", event, am_type);
AmTsplayer/TsPlayer.cpp:5881:    FLOGI(mPlayerInstansNo,"UnsupportedFormat format: %s", format.c_str());
AmTsplayer/TsPlayer.cpp:5928:    //ALOGV("onEvent %d, mPlayerCallbackFn %p, param %p\n", event, mPlayerCallbackFn, param);
AmTsplayer/TsPlayer.cpp:5946:                    FLOGI(mPlayerInstansNo,"USERDATA param nullptr\n");
AmTsplayer/TsPlayer.cpp:5956:                FLOGI(mPlayerInstansNo,"VIDEO FORMAT CHANGED [%d x %d] @%d aspectratio:%d\n",
AmTsplayer/TsPlayer.cpp:5966:                FLOGI(mPlayerInstansNo,"VIDEO FORMAT param %p, paramsize %d\n",param, paramsize);
AmTsplayer/TsPlayer.cpp:5972:                FLOGI(mPlayerInstansNo,"AUDIO FORMAT CHANGED ch=%u ch_mask=%u samplerate=%u\n",
AmTsplayer/TsPlayer.cpp:5978:                FLOGE(mPlayerInstansNo,"AUDIO FORMAT param %p, paramsize %d\n", param, paramsize);
AmTsplayer/TsPlayer.cpp:5987:                FLOGE(mPlayerInstansNo,"AUDIO FORMAT param %p, paramsize %d\n", param, paramsize);
AmTsplayer/TsPlayer.cpp:6020:                    FLOGI(mPlayerInstansNo,"event type: %s\n",
AmTsplayer/TsPlayer.cpp:6029:            FLOGI(mPlayerInstansNo,"isStopVideo:%d,display first video\n",mStopVideo);
AmTsplayer/TsPlayer.cpp:6039:            FLOGI(mPlayerInstansNo,"isStopVideo:%d,decodec first video\n",mStopVideo);
AmTsplayer/TsPlayer.cpp:6042:                    FLOGI(mPlayerInstansNo,"videoShow process again success\n");
AmTsplayer/TsPlayer.cpp:6052:            FLOGI(mPlayerInstansNo,"mStopAudio:%d,decodec first audio\n",mStopAudio);
AmTsplayer/TsPlayer.cpp:6060:            FLOGI(mPlayerInstansNo,"isStopVideo:%d,mStopAudio:%d,av sync done!\n",mStopVideo,mStopAudio);
AmTsplayer/TsPlayer.cpp:6080:            FLOGI(mPlayerInstansNo,"isStopVideo:%d,frame error count callback \n",mStopVideo);
AmTsplayer/TsPlayer.cpp:6086:            FLOGI(mPlayerInstansNo,"isStopVideo:%d,video unsupport \n",mStopVideo);
AmTsplayer/TsPlayer.cpp:6095:                //FLOGI(mPlayerInstansNo,"video overflow\n");
AmTsplayer/TsPlayer.cpp:6103:                //FLOGI(mPlayerInstansNo,"video underflow\n");
AmTsplayer/TsPlayer.cpp:6111:                //FLOGI(mPlayerInstansNo,"audio overflow\n");
AmTsplayer/TsPlayer.cpp:6119:                //FLOGI(mPlayerInstansNo,"audio underflow\n");
AmTsplayer/TsPlayer.cpp:6126:                //FLOGI(mPlayerInstansNo,"video invalid timestamp!\n");
AmTsplayer/TsPlayer.cpp:6132:                //FLOGI(mPlayerInstansNo,"video invalid data!\n");
AmTsplayer/TsPlayer.cpp:6138:                //FLOGI(mPlayerInstansNo,"audio invalid timestamp!\n");
AmTsplayer/TsPlayer.cpp:6144:                //FLOGI(mPlayerInstansNo,"audio invalid data!\n");
AmTsplayer/TsPlayer.cpp:6149:            FLOGV(mPlayerInstansNo,"instance was preempted!\n");
AmTsplayer/TsPlayer.cpp:6154:                FLOGI(mPlayerInstansNo,"hasdtvvideo:%d mStopVideo:%d mStopAudio:%d. decoder started!\n", hasdtvvideo,mStopVideo,mStopAudio);
AmTsplayer/TsPlayer.cpp:6161:                    FLOGI(mPlayerInstansNo,"FFFB VIDEO TIMESTAMP param %p, paramsize %d\n", param, paramsize);
AmTsplayer/TsPlayer.cpp:6185:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/TsPlayer.cpp:6198:            FLOGI(mPlayerInstansNo,"Reset playback pipeline!\n");
AmTsplayer/TsPlayer.cpp:6240:    FLOGI(mPlayerInstansNo,"dmx:%p\n",mDemuxWrap->get());
AmTsplayer/TsPlayer.cpp:6248:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/TsPlayer.cpp:6269:    FLOGI(mPlayerInstansNo, "audio pid: %#x", pid);
AmTsplayer/TsPlayer.cpp:6276:    ALOGI("EsDataHandler SetVideoLoopEnable:%d\n", mVideoLoop);
AmTsplayer/TsPlayer.cpp:6282:    FLOGI(mPlayerInstansNo,"EsDataHandler\n");
AmTsplayer/TsPlayer.cpp:6287:    FLOGI(mPlayerInstansNo,"EsDataHandler\n");
AmTsplayer/TsPlayer.cpp:6295:    FLOGI(mPlayerInstansNo,"EsDataHandler\n");
AmTsplayer/TsPlayer.cpp:6308:    FLOGI(mPlayerInstansNo,"EsDataHandler\n");
AmTsplayer/TsPlayer.cpp:6313:    FLOGI(mPlayerInstansNo,"EsDataHandler\n");
AmTsplayer/TsPlayer.cpp:6318:    FLOGI(mPlayerInstansNo,"EsDataHandler\n");
AmTsplayer/TsPlayer.cpp:6380:                FLOGI(mPlayerInstansNo, "Not get %s pts info, set cache to %dms", audioNewPts ? "video" : "audio", mVideoCacheDurationUs / 1000);
AmTsplayer/TsPlayer.cpp:6382:            FLOGI(mPlayerInstansNo, "Update video cache duration: %d ms", mVideoCacheDurationUs / 1000);
AmTsplayer/TsPlayer.cpp:6399:            // FLOGD(mPlayerInstansNo, "decoder not ready need retry\n");
AmTsplayer/TsPlayer.cpp:6414:                // FLOGD(mPlayerInstansNo, "%s:%d:mEsData->pts:%" PRId64 ", size:%d\n",__FUNCTION__, __LINE__, mEsdata->pts, mEsdata->size);
AmTsplayer/TsPlayer.cpp:6423:                    // FLOGI(mPlayerInstansNo, "video write error\n");
AmTsplayer/TsPlayer.cpp:6453:         FLOGI(mPlayerInstansNo,"EsDataHandler ReadBuffer Video Stop!!\n");
AmTsplayer/TsPlayer.cpp:6468:            FLOGI(mPlayerInstansNo,"mEsdata->size == 0 \n");
AmTsplayer/TsPlayer.cpp:6480:               //     ALOGI("Audio write VDA_RETRY\n");
AmTsplayer/TsPlayer.cpp:6483:                    FLOGI(mPlayerInstansNo,"Audio write VDA_RETRY\n");
AmTsplayer/TsPlayer.cpp:6487:                    FLOGI(mPlayerInstansNo,"Audio write to amadec VDA_RETRY\n");
AmTsplayer/TsPlayer.cpp:6490:                //FLOGI(mPlayerInstansNo,"-->audio free 0x%x \n",(long)mEsdata->data);
AmTsplayer/TsPlayer.cpp:6502:         FLOGI(mPlayerInstansNo,"EsDataHandler ReadBuffer Audio Stop!!\n");
AmTsplayer/TsPlayer.cpp:6531:        //ALOGE("EsDataHandler TSP_onMessageReceived handler has not started\n");
AmTsplayer/Android.bp:114:        "hardware/amlogic/gralloc" ,
AmTsplayer/Android.bp:127:        "libmediahal_tsplogger_headers",
AmTsplayer/Android.bp:135:        "liblog",
AmTsplayer/Android.bp:226:        "hardware/amlogic/gralloc" ,
AmTsplayer/Android.bp:241:        "libmediahal_tsplogger_headers",
AmTsplayer/Android.bp:249:        "liblog",
AmTsplayer/Android.bp:355:        // "hardware/amlogic/gralloc" ,
AmTsplayer/Android.bp:368:        "libmediahal_tsplogger_headers",
AmTsplayer/Android.bp:376:        "liblog",
AmTsplayer/TsPlayerCallback.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/vdtunnelwrap/VideodecTunnelSurfaceDisplay.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:9:#define LOG_NDEBUG 0
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:10:#define LOG_TAG "VideodecTunnelWrapper"
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:81:  //  ALOGV("%s at # %d type %d fmt %d\n",__FUNCTION__,__LINE__,typeinplayer,vfmt);
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:107:    ALOGI("VideodecWrapper PlayerInstansNo:%d\n",mPlayerInstansNo);
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:123:    ALOGI("~VideodecWrapper\n");
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:161:   // ALOGV("onInputBufferDone this %p bitstreamId %d, mInputDoneCount %d\n",
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:191:    ALOGV("onUpdateDecInfo info %p, size %d\n", info, isize);
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:205:    ALOGV("onEvent event %d, param %p, paramsize %d\n", event, param, paramsize);
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:218:    ALOGI("VideodecWrapper::initialize, vpid %d, fmt %d, pcrid %d, apid %d, drmmode %d, sidebandtype:%d, sideband_id:%d\n",
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:232:       ALOGE("Exception: %s initialize FAILED.\n", __func__);
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:238:        ALOGI("%s at %d pure audio files or MHEG need another chance to do vdec initialize\n",__func__,__LINE__);
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:254:    ALOGI("VideodecWrapper::initialize, vpid %d, fmt %d, pcrid %d, apid %d, drmmode %d, sidebandtype:%d, sideband_id:%d\n",
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:282:       ALOGE("Exception: %s initialize FAILED.\n", __func__);
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:288:        ALOGI("%s at %d pure audio files or MHEG need another chance to do vdec initialize\n",__func__,__LINE__);
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:310:        ALOGV("queueInputBuffer %d, done %d, laststatus %d\n", mInputQueueCount, mInputDoneCount, mLastWriteStatus);
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:337:        ALOGI("VideodecTunnelWrapper is release now, can not sendcommand!");
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:348:        ALOGV("VideodecWrapper::sendCommand index %d, param %p, size %d\n",
AmTsplayer/vdtunnelwrap/VideodecTunnelWrapper.cpp:369:    ALOGV("VideodecWrapper::registerCallback \n");
AmTsplayer/vdtunnelwrap/VideodecTunnelSurfaceDisplay.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/vdtunnelwrap/VideodecTunnelSurfaceDisplay.cpp:9://#define LOG_NDEBUG 0
AmTsplayer/vdtunnelwrap/VideodecTunnelSurfaceDisplay.cpp:10:#define LOG_TAG "VideodecTunnelSurfaceDisplay"
AmTsplayer/vdtunnelwrap/VideodecTunnelSurfaceDisplay.cpp:14:#include <utils/Log.h>
AmTsplayer/vdtunnelwrap/VideodecTunnelSurfaceDisplay.cpp:15:#include <amlogic/am_gralloc_ext.h>
AmTsplayer/vdtunnelwrap/VideodecTunnelSurfaceDisplay.cpp:37:    ALOGI("TunnelSurfaceDisplay (%p)\n",this);
AmTsplayer/vdtunnelwrap/VideodecTunnelSurfaceDisplay.cpp:43:    ALOGI("~TunnelSurfaceDisplay (%p)\n",this);
AmTsplayer/vdtunnelwrap/VideodecTunnelSurfaceDisplay.cpp:59:        ALOGI("SurfaceDisplay::SetSurface %p\n", mSurface.get());
AmTsplayer/vdtunnelwrap/VideodecTunnelSurfaceDisplay.cpp:67:                ALOGE("%s at L%d err %d \n",__func__,__LINE__,err);
AmTsplayer/vdtunnelwrap/VideoDecSpace.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/vdtunnelwrap/VideodecWrapperBase.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/tspSystemCheck.go:64:        sharedlib = append(sharedlib, "libaudioclient", "libmedia", "libgui", "//hardware/amlogic:libamgralloc_ext")
AmTsplayer/AmTsPlayerProperty.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/AmTsPlayerProperty.h:31:#define PROPERTY_AMTSPLAYER_DEMUXPTS                  "vendor.amtsplayer.demuxpts"     /* demux pts log print */
AmTsplayer/AmTsPlayerProperty.h:50:#define PROPERTY_TSPLAYER_DEMUXPTS             "vendor.media.mediahal.tsplayer.demuxpts"      /* demux pts log print */
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:12:#define LOG_TAG "AmSoftDemux"
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:13:#include <utils/Log.h>
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:38:    ALOGI(" [%s %d]", __FUNCTION__, __LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:57:        ALOGI(" [%s %d]", __FUNCTION__, __LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:60:    ALOGI(" [%s %d]", __FUNCTION__, __LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:89:    int  logLevel = 0;
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:91:    if (property_get("vendor.media.ffmpegextractor.loglevel", value, "16") > 0) {
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:92:        if ((sscanf(value, "%d", &logLevel)) > 0) {
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:93:            ALOGI("media.ffmpegextractor.loglevel %d\n", logLevel);
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:96:    av_log_set_level(logLevel);
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:112:            ALOGE("Failed to initialize AVIOContext.");
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:115:        ALOGE("Failed to allocate %u bytes for ByteIOAdapter.", targetSize);
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:121:        ALOGE("Failed to allocate AVFormatContext.");
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:137:      //  ALOGI("///////////////start dump format ");
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:157:        ALOGI("add mIndex : %d \n",i);
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:166:        ALOGI("mAlreadyInitialized--->WriteTs");
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:169:       // ALOGI("init() ok !\n");
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:190:       // ALOGI("mAlreadyInitialized--->WriteTs");
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:193:        ALOGI("init() ok !\n");
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:206:            ALOGI("first read pid:0x%x \n",pid);
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:274:    //ALOGI("ReadTs amt:%d \n",amt);
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:300:    ALOGI("mEsdata");
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.cpp:304:    ALOGI("~mEsdata");
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:13:#define LOG_NDEBUG 0
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:14:#define LOG_TAG "AmSwDemuxWrapper"
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:31:    ALOGI("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:48:    ALOGI("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:56:    ALOGV("%s at # %d device_type %d\n",__FUNCTION__,__LINE__,para->device_type);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:62:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:71:    ALOGI("-->FetchEsDataThread\n");
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:104:        //ALOGI("-->FetchEsDataThread mVideoBufferCount:%d mAudioBufferCount:%d\n",mVideoBufferCount,mAudioBufferCount);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:114:        ALOGE("pthread_create failed : %s\n", strerror(ret));
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:117:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:129:    //ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:138:        //ALOGE("ret  : %d size:%d buf:%s\n",ret,size,buf != NULL ? "!=NULL":"NULL");
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:153:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:160:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:166:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:173:   ALOGI("%s at #line %d vid:0x%x\n",__func__,__LINE__,vid);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:182:    ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:191:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:201:    ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:207:    ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.cpp:215:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
AmTsplayer/dmxwrap/SoftDemux/AmSoftDemux.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/SoftDemux/AmSwDemuxWrapper.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/test/AmDemuxWrappertest.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:10:#define LOG_NDEBUG 0
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:11:#define LOG_TAG "AmHwDemuxWrapper"
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:35:    ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:45:        ALOGV("cannot open \"%s\" (%d:%s)", DSC_DEV_NAME, errno, strerror(errno));
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:54:    ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:86:        ALOGE("do not support demux source %d", src);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:97:    ALOGV("%s at #line %d src %d\n",__func__,__LINE__,src);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:110:            ALOGV("illegal ts source %d", src);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:123:    ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:166:		    ALOGV("cannot open device \"%s\"", STREAM_TS_FILE);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:170:            ALOGV("open device \"%s\" ok 0x%x \n", STREAM_TS_FILE,vfd);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:178:		    ALOGV("cannot open device \"%s\" \n", STREAM_TS_SCHED_FILE);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:182:            ALOGV("open device \"%s\" ok \n", STREAM_TS_SCHED_FILE);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:190:	          ALOGV("set drm_mode with secure buffer failed\n");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:194:            ALOGV("ioctl 0x%x ok", AMSTREAM_IOC_SET_DRMMODE);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:200:		    ALOGV("set drm_mode with normal buffer failed\n");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:204:            ALOGV("ioctl 0x%x ok", AMSTREAM_IOC_SET_DRMMODE);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:209:		ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:213:			ALOGV("set video format failed");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:218:			ALOGV("set video PID failed");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:250:			ALOGV("set AMSTREAM_IOC_SYSINFO");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:253:		ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:257:		ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:261:			ALOGV("set audio format failed");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:266:			ALOGV("set audio PID failed");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:277:		ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:281:		ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:285:			ALOGV("set subtitle PID failed");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:291:			ALOGV("set subtitle type failed");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:300:			ALOGV("amport init failed");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:307:			ALOGV("cannot open \"%s\"", AMVIDEO_FILE);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:311:			ALOGV("open \"%s\" ok", AMVIDEO_FILE);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:331:  ALOGV("inject data send %d para->vid_fd 0x%x\n", send,para->vid_fd);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:337:            ALOGV("inject data failed errno:%d msg:%s \n", errno, strerror(errno));
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:370:			ALOGV("pause inject");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:381:			ALOGV("resume inject");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:384:			ALOGV("illegal media player command");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:397:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:402:    ALOGE("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:439:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:447:    ALOGV("%s at # %d device_type %d\n",__FUNCTION__,__LINE__,para->device_type);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:459:            ALOGV("%s at #line %d ret 0x%x\n",__func__,__LINE__,ret);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:468:            ALOGV("%s at #line %d ret 0x%x\n",__func__,__LINE__,ret);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:476:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:483:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:487:		ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:499:    ALOGV("%s at # %d return %d\n",__FUNCTION__,__LINE__,ret);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:506:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:518:    ALOGV("%s at # %d send %d\n",__FUNCTION__,__LINE__,send);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:528:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:538:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:548:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:556:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:564:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:573:    ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:587:    ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:599:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:608:    ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:619:    ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:629:    ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:637:    ALOGV("%s at #line %d\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:645:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:668:                    ALOGV("%s at # %d states %d\n",__func__,__LINE__,*states);
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.cpp:672:            ALOGV("illegal command");
AmTsplayer/dmxwrap/HwDemux/AmHwDemuxWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:12:#define LOG_NDEBUG 0
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:13:#define LOG_TAG "TsAmDmxDevice"
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:14:#include <utils/Log.h>
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:26:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:27:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:28:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:34:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:49:    FLOGI(mPlayerInstansNo,"end");
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:62:        FLOGE(mPlayerInstansNo,"invalid filter id, must in %d~%d", 0, AMDMX_FILTER_COUNT-1);
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:69:        FLOGE(mPlayerInstansNo,"filter %d has not been allocated", filter_id);
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:95:   // ALOGI("dmx_non_sec_es_data in \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:110:                   // ALOGE("dmx_non_sec_es_data read head error! sec_len:%d \n",sec_len);
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:129:                ALOGI("[No-%d](%p) dvb_read retry sec_len:%d ReadDmxNonSecEsSize:%d esHeader->len:%d ",
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:145:                    ALOGI("[No-%d](%p) mReadDmxNonSecEsSize:%d esHeader->len:%d\n",
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:175:    // ALOGI("dmx_non_sec_es_data out \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:230:    ALOGI("[No-%d](%p) dmx_data_thread start ",dev->mPlayerInstansNo,dev);
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:304:    ALOGI("[No-%d](%p) dmx_data_thread end ",dev->mPlayerInstansNo,dev);
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:364:        FLOGI(mPlayerInstansNo,"demux device %d has already been openned", dev_no);
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:371:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:433:        FLOGI(mPlayerInstansNo,"no free section filter");
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:471:        FLOGI(mPlayerInstansNo,"set sec filter %d PID: %d filter: %02x:%02x %02x:%02x %02x:%02x %02x:%02x %02x:%02x %02x:%02x %02x:%02x %02x:%02x",
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:512:        FLOGI(mPlayerInstansNo,"set pes filter %d PID %d", fhandle, params->pid);
AmTsplayer/dmxwrap/MultiHwDemux/AmDmx.cpp:534:    FLOGI(mPlayerInstansNo,"end");
AmTsplayer/dmxwrap/MultiHwDemux/am_mem.h:2: * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/MultiHwDemux/am_mem.h:12: * \author Gong Ke <ke.gong@amlogic.com>
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:16:#define LOG_NDEBUG 0
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:17:#define LOG_TAG "TsAmLinuxDvb"
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:19:#include <utils/Log.h>
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:42:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:43:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:44:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:47:    ALOGI("AmLinuxDvb (%p)\n",this);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:60:    FLOGI(mPlayerInstansNo,"end");
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:69:        FLOGE(mPlayerInstansNo,"not enough memory");
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:79:        ALOGI("eventfd error");
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:100:        FLOGE(mPlayerInstansNo,"cannot open \"%s\" (%s)", dmx->dev_name, strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:106:    FLOGI(mPlayerInstansNo,"open (%s) ok! fd:%d \n",dmx->dev_name,fd);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:116:       FLOGE(mPlayerInstansNo,"dvb_free_filter error close fd:%d (%s)\n",fd,strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:118:       FLOGI(mPlayerInstansNo,"dvb_free_filter close fd:%d\n",fd);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:134:            FLOGE(mPlayerInstansNo,"num %d: base:0x%0x, stc:0x%llx\n", stc.num, stc.base, stc.stc);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:136:            FLOGI(mPlayerInstansNo," %d, fail\n", i);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:156:        FLOGE(mPlayerInstansNo,"set section filter failed (%s)", strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:169:        FLOGE(mPlayerInstansNo,"fcntl(fd,F_SETFL,O_NONBLOCK) == -1!");
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:174:        FLOGE(mPlayerInstansNo,"set section filter failed (%s)", strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:177:    FLOGI(mPlayerInstansNo,"%s success\n", __FUNCTION__);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:192:        FLOGE(mPlayerInstansNo,"start filter failed (%s)", strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:205:        FLOGE(mPlayerInstansNo,"ioctl DMX_GET_MEM_INFO failed (%s)", strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:220:            FLOGE(mPlayerInstansNo,"cannot open \"%s\" (%s)", dev_name, strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:228:        FLOGE(mPlayerInstansNo,"ioctl DMX_GET_FILTER_MEM_INFO failed (%s)", strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:243:        FLOGE(mPlayerInstansNo,"ioctl DMX_SET_DECODE_INFO failed (%s)", strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:261:        FLOGE(mPlayerInstansNo,"ioctl DMX_SET_DECODE_INFO failed (%s)", strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:273:        FLOGE(mPlayerInstansNo,"ioctl DMX_SET_BUFFER_SIZE failed (%s)", strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:283:    ALOGV("dvb_poll_exit");
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:318:            FLOGE(mPlayerInstansNo,"Can't get es data from demux. cnt:%d pollFailCount:%d (%s)",
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:329:            //ALOGI("dvb_poll  i:%d cnt:%d fd:%d\n",i,cnt,fds[i].fd);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:346:        FLOGI(mPlayerInstansNo,"dvb_read fd:%d \n", fd);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:365:            FLOGE(mPlayerInstansNo,"read demux failed (%s) %d", strerror(errno), errno);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:379:        FLOGE(mPlayerInstansNo,"cannot open \"%s\" (%s)", name, strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:382:    FLOGI(mPlayerInstansNo,"open %s  ok \n", name);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:387:        FLOGE(mPlayerInstansNo,"cannot open \"%s\" (%s)", name, strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:392:        FLOGI(mPlayerInstansNo,"set INPUT_LOCAL \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:396:            FLOGI(mPlayerInstansNo,"set hw souece :%d\n",dev->dev_no);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:398:                FLOGE(mPlayerInstansNo, "AMDMX_SET_HW_SOURCE ioctl failed %s\n", strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:404:        FLOGI(mPlayerInstansNo,"set INPUT_DEMOD \n" );
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:409:        FLOGI(mPlayerInstansNo,"set INPUT_LOCAL_SEC \n" );
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:413:        FLOGI(mPlayerInstansNo,"set INPUT_USB_CAMCARD \n" );
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:417:    FLOGI(mPlayerInstansNo,"DMX_SET_INPUT ret:%d\n", ret);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:419:        FLOGE(mPlayerInstansNo,"dvr_open ioctl failed %s\n", strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:436:        FLOGI(mPlayerInstansNo,"buf_start 0x%lx buf_end 0x%lx left %d size %d\n",
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:452:                //FLOGE(mPlayerInstansNo,"Write DVR data failed:%d(%s)",ret,strerror(errno));
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:461:            FLOGE(mPlayerInstansNo,"timeout(%" PRId64 ") \n",timeout);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:467:            FLOGE(mPlayerInstansNo,"INPUT_LOCAL_SEC left  0x%x\n",left);
AmTsplayer/dmxwrap/MultiHwDemux/AmLinuxDvb.cpp:516:            ALOGE("do not support demux source %d", src);
AmTsplayer/dmxwrap/MultiHwDemux/am_util.h:2: * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/MultiHwDemux/am_util.h:12: * \author Gong Ke <ke.gong@amlogic.com>
AmTsplayer/dmxwrap/MultiHwDemux/am_types.h:2: * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/MultiHwDemux/am_types.h:11: * \author Gong Ke <ke.gong@amlogic.com>
AmTsplayer/dmxwrap/MultiHwDemux/AmDmxDrive.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:12:#define LOG_NDEBUG 0
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:13:#define LOG_TAG "TsAmHwMultiDemuxWrapper"
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:33:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:34:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:35:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:43:        ALOGI("[No-%d](%p) getVideoEsData mStopGetVideoEsData\n",mDemuxWrapper->mPlayerInstansNo,mDemuxWrapper);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:62:        ALOGI("[No-%d]split length:%d, dmxSecEsDataCount %d, dmxSecEsNextDataSize:%d lastNeedSize:%d\n",
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:108:            ALOGI("[No-%d](%p) dicontinue PtsBefore:%" PRId64 " PtsAfter:%" PRId64 " diff:%" PRId64 "  \n",
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:118:            ALOGI("[No-%d](%p) buf_start:0x%x buf_end:0x%x  data_start:0x%x data_end:0x%x pts:%" PRId64 "(%" PRId64 ") size:%d flag:0x%x\n",
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:131:                ALOGI("[No-%d](%p) buf_start:0x%x buf_end:0x%x  data_start:0x%x data_end:0x%x pts:%" PRId64 "(%" PRId64 ") size:%d flag:0x%x\n",
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:151:                ALOGI("[No-%d](%p) time-consuming:%" PRId64 "us frame_rate:%" PRId32 "fps dmxEsDataCount:%" PRId32 " \n",
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:175:            //ALOGI("[No-%d](%p) pts_dts_flag：0x%x --> 0x%x\n",mDemuxWrapper->mPlayerInstansNo,mDemuxWrapper,dmxEsdata->pts_dts_flag,dmxEsdata->pts_dts_flag & 0x8);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:179:                ALOGI("[No-%d](%p) PostVideoEsinvalid \n",mDemuxWrapper->mPlayerInstansNo,mDemuxWrapper);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:190:            ALOGI("[No-%d](%p) PostVideoEsvalid \n",mDemuxWrapper->mPlayerInstansNo,mDemuxWrapper);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:228:    //ALOGI("AmHwMultiDemuxWrapper getAudioEsData ---> len:%d \n",len);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:250:        //ALOGI("AmHwMultiDemuxWrapper mStopGetAudioEsData\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:251:        ALOGI("[No-%d](%p) getAudioEsData mStopGetAudioEsData\n",mDemuxWrapper->mPlayerInstansNo,mDemuxWrapper);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:260:        //ALOGI("---->audio es error! AudioEsHead->len:%d len:%d flag:%d \n",AudioEsHead->len,len,AudioEsHead->pts_dts_flag);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:261:        ALOGI("[No-%d](%p)audio es error! AudioEsHead->len:%d len:%d flag:%d\n",
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:275:        ALOGI("[No-%d](%p) audio pts:%" PRId64 " len:%d\n",mDemuxWrapper->mPlayerInstansNo,
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:300:        ALOGI("TsAmHwMultiDemuxWrapper enable splice es mode as default");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:301:        if (FileSystem_writeFile("/sys/module/amlogic_dvb_demux/parameters/video_es_splice","1") != 0) {
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:303:                ALOGI("TsAmHwMultiDemuxWrapper set video_es_splic disable \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:310:        ALOGI("TsAmHwMultiDemuxWrapper ptsserver dev_open [%s] ,ret=%d %d(%s)\n",
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:322:        ALOGI("TsAmHwMultiDemuxWrapper ptsserver ioctl cmd [%s],ret:%d %d(%s)\n",
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:328:            if (FileSystem_writeFile("/sys/module/amlogic_dvb_demux/parameters/video_es_splice","1") != 0) {
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:329:                ALOGI("TsAmHwMultiDemuxWrapper set video_es_splic disable \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:342:    ALOGI("AmHwMultiDemuxWrapper %p\n",this);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:371:    ALOGI("[%s/%d] isSupport4K:%d video_buf_size=%zu, audio_buf_size=%zu\n",
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:378:        if (FileSystem_writeFile("/sys/module/amlogic_dvb_demux/parameters/video_buf_size",strVideoSize) != 0) {
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:379:            ALOGE("set video_buf_size erro %p\n",this);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:384:        if (FileSystem_writeFile("/sys/module/amlogic_dvb_demux/parameters/audio_buf_size",strAudioSize) != 0) {
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:385:            ALOGE("set audio_buf_size erro %p\n",this);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:438:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:460:    FLOGI(mPlayerInstansNo,"end");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:485:    FLOGI(mPlayerInstansNo,"dev_no:%d device_type:%d drm_mode:%d tf_passthrough:%d\n",
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:522:        FLOGI(mPlayerInstansNo, "[mediahal_kpi] first write data to demux\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:577:        FLOGI(mPlayerInstansNo,"mCycleEsVideoQueue.size : %d \n",size);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:590:    FLOGI(mPlayerInstansNo,"aid : %d \n",aid);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:621:    FLOGI(mPlayerInstansNo,"aparam.flags:0x%x\n",aparam.flags );
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:623:    FLOGI(mPlayerInstansNo,"AM_DMX_AllocateFilter\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:625:        FLOGE(mPlayerInstansNo,"Audio AM_DMX_AllocateFilter error\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:629:    FLOGI(mPlayerInstansNo,"(fid:%d) AM_DMX_SetCallback \n",fid_audio);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:631:        FLOGE(mPlayerInstansNo,"Audio AM_DMX_SetCallback error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:635:    FLOGI(mPlayerInstansNo,"AM_DMX_SetBufferSize\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:637:        FLOGE(mPlayerInstansNo,"Audio AM_DMX_SetBufferSize error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:643:        FLOGI(mPlayerInstansNo,"AM_DMX_SetEsbufferSize\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:645:            FLOGE(mPlayerInstansNo,"audio AM_DMX_SetEsbufferSize error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:649:    FLOGI(mPlayerInstansNo,"AM_DMX_SetPesFilter \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:651:        FLOGE(mPlayerInstansNo,"Audio AM_DMX_SetPesFilter error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:655:    FLOGI(mPlayerInstansNo," AM_DMX_StartFilter \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:657:        FLOGE(mPlayerInstansNo,"Audio AM_DMX_StartFilter error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:661:    FLOGI(mPlayerInstansNo,"ok\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:681:    FLOGI(mPlayerInstansNo,"vpid:0x%x seculevel %d\n",vid,seculevel);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:712:    FLOGI(mPlayerInstansNo,"vparam.flags:0x%x  seculevel:%d\n",vparam.flags,seculevel);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:714:    FLOGI(mPlayerInstansNo,"AM_DMX_AllocateFilter\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:716:        FLOGE(mPlayerInstansNo,"video AM_DMX_AllocateFilter error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:721:    FLOGI(mPlayerInstansNo,"(fid:%d) AM_DMX_SetCallback\n",fid_video);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:723:        FLOGE(mPlayerInstansNo,"video AM_DMX_SetCallback error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:728:    FLOGI(mPlayerInstansNo,"AM_DMX_SetBufferSize\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:730:        FLOGE(mPlayerInstansNo,"video AM_DMX_SetBufferSize error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:737:        FLOGI(mPlayerInstansNo,"AM_DMX_SetEsbufferSize\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:739:            FLOGE(mPlayerInstansNo,"video AM_DMX_SetEsbufferSize error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:743:    FLOGI(mPlayerInstansNo,"AM_DMX_SetPesFilter\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:745:        FLOGE(mPlayerInstansNo,"video AM_DMX_SetPesFilter error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:750:    FLOGI(mPlayerInstansNo,"AM_DMX_StartFilter\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:752:        FLOGE(mPlayerInstansNo,"video AmDemuxWrapperSetVideoParam error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:756:    FLOGI(mPlayerInstansNo,"ok\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:764:    FLOGI(mPlayerInstansNo,"pcr pid:0x%x \n",Pcrpid);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:766:        FLOGE(mPlayerInstansNo,"set mDemuxPara.pcr_id == pcr pid:0x%x \n",Pcrpid);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:799:    FLOGI(mPlayerInstansNo,"PcrParam.flags : 0x%x  \n",PcrParam.flags );
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:801:    FLOGI(mPlayerInstansNo,"AM_DMX_AllocateFilter\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:803:        FLOGE(mPlayerInstansNo,"video AM_DMX_AllocateFilter error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:808:    FLOGI(mPlayerInstansNo,"(fid:%d) AM_DMX_SetCallback\n",fid_pcr);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:810:        FLOGE(mPlayerInstansNo,"video AM_DMX_SetCallback error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:817:    FLOGI(mPlayerInstansNo,"AM_DMX_SetBufferSize bufferSize:%d\n",bufferSize);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:819:        FLOGE(mPlayerInstansNo,"video AM_DMX_SetBufferSize error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:824:    FLOGI(mPlayerInstansNo,"AM_DMX_SetPesFilter\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:826:        FLOGE(mPlayerInstansNo,"video AM_DMX_SetPesFilter error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:831:    FLOGI(mPlayerInstansNo,"AM_DMX_StartFilter\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:833:        FLOGE(mPlayerInstansNo,"video AmDemuxWrapperSetVideoParam error \n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:837:    FLOGI(mPlayerInstansNo,"ok\n");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:912:    FLOGI(mPlayerInstansNo,"AmDemuxWrapperVideoLoopDisable:%d\n", enable);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:919:    FLOGI(mPlayerInstansNo,"AmDemuxWrapperAudioLoopDisable:%d\n", enable);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:933:        FLOGI(mPlayerInstansNo,"video 0x%x\n",mDemuxPara.vid_id);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:949:        FLOGI(mPlayerInstansNo,"audio 0x%x\n",mDemuxPara.aud_id);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:958:        FLOGI(mPlayerInstansNo,"pcr 0x%x\n",mDemuxPara.pcr_id);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:970:            FLOGI(mPlayerInstansNo,"mEsDataQueue.size(%d) > 200\n",(int)mEsDataQueue.size());
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:1057:            ALOGE("reach max size!");
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:1067:                ALOGI("[%s/%d] mallocESBuffer failed, NULL return\n", __FUNCTION__, __LINE__);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:1122:        ALOGI("[%s/%d] mIdleQueue is empty", __FUNCTION__, __LINE__);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:1130:        ALOGI("[%s/%d] esData is NULL", __FUNCTION__, __LINE__);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:1137:        ALOGI("[%s/%d] esData->data is NULL", __FUNCTION__, __LINE__);
AmTsplayer/dmxwrap/MultiHwDemux/AmHwMultiDemuxWrapper.cpp:1209:        FLOGI(mPlayerInstansNo,"frameRate:%d\n", frame_rate);
AmTsplayer/dmxwrap/AmDemuxWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/tsputil/Threads.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/tsputil/Threads.cpp:10:#define LOG_NDEBUG 0
AmTsplayer/tsputil/Threads.cpp:11:#define LOG_TAG "libutils.threads"
AmTsplayer/tsputil/Threads.cpp:42:        /*ALOGE("androidCreateRawThreadEtc failed (entry=%p, res=%d, %s)\n",
AmTsplayer/tsputil/Threads.cpp:82:    //LOG_ALWAYS_FATAL_IF(name == nullptr, "thread name not provided to Thread::run");
AmTsplayer/tsputil/Threads.cpp:196:        /*ALOGW(
AmTsplayer/tsputil/Threads.cpp:220:        /*ALOGW(
AmTsplayer/tsputil/SharedBuffer.cpp:17:#define LOG_TAG "sharedbuffer"
AmTsplayer/tsputil/SharedBuffer.cpp:30:    LOG_ALWAYS_FATAL_IF((size >= (SIZE_MAX - sizeof(SharedBuffer))),
AmTsplayer/tsputil/SharedBuffer.cpp:70:        LOG_ALWAYS_FATAL_IF((newSize >= (SIZE_MAX - sizeof(SharedBuffer))),
AmTsplayer/tsputil/tsp_utils.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/tsputil/tsp_utils.h:20:#define DRMPTRACE ALOGE
AmTsplayer/tsputil/Unicode.cpp:17:#define LOG_TAG "unicode"
AmTsplayer/tsputil/Unicode.cpp:194:            android_errorWriteLog(0x534e4554, "37723026");
AmTsplayer/tsputil/Unicode.cpp:215:        LOG_ALWAYS_FATAL_IF(dst_len < len, "%zu < %zu", dst_len, len);
AmTsplayer/tsputil/Unicode.cpp:222:    LOG_ALWAYS_FATAL_IF(dst_len < 1, "dst_len < 1: %zu < 1", dst_len);
AmTsplayer/tsputil/Unicode.cpp:397:        LOG_ALWAYS_FATAL_IF(dst_len < len, "%zu < %zu", dst_len, len);
AmTsplayer/tsputil/Unicode.cpp:404:    LOG_ALWAYS_FATAL_IF(dst_len < 1, "%zu < 1", dst_len);
AmTsplayer/tsputil/Unicode.cpp:479:            android_errorWriteLog(0x534e4554, "37723026");
AmTsplayer/tsputil/Unicode.cpp:600:                LOG_ALWAYS_FATAL("Attempt to overread computing length of utf8 string");
AmTsplayer/tsputil/Unicode.cpp:627:    LOG_ALWAYS_FATAL_IF(u16len == 0 || u16len > SSIZE_MAX, "u16len is %zu", u16len);
AmTsplayer/tsputil/Unicode.cpp:641:    LOG_ALWAYS_FATAL_IF(dstLen > SSIZE_MAX, "dstLen is %zu", dstLen);
AmTsplayer/tsputil/audio_if_client.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/tsputil/TSPLooperRoster.cpp:17://#define LOG_NDEBUG 0
AmTsplayer/tsputil/TSPLooperRoster.cpp:18:#define LOG_TAG "TSPLooperRoster"
AmTsplayer/tsputil/TSPLooperRoster.cpp:84:                ALOGV("Unregistering stale handler %d", mHandlers.keyAt(i));
AmTsplayer/tsputil/String16.cpp:82:        android_errorWriteLog(0x534e4554, "73826242");
AmTsplayer/tsputil/String16.cpp:87:    ALOG_ASSERT(buf, "Unable to allocate shared buffer");
AmTsplayer/tsputil/String16.cpp:180:        LOG_ALWAYS_FATAL("Not implemented");
AmTsplayer/tsputil/String16.cpp:194:        android_errorWriteLog(0x534e4554, "73826242");
AmTsplayer/tsputil/String16.cpp:222:        android_errorWriteLog(0x534e4554, "73826242");
AmTsplayer/tsputil/String16.cpp:248:        android_errorWriteLog(0x534e4554, "73826242");
AmTsplayer/tsputil/FileSystemIo.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/tsputil/FileSystemIo.cpp:12:#define LOG_TAG "AmTsSystemControl"
AmTsplayer/tsputil/FileSystemIo.cpp:13:// #include <utils/Log.h>
AmTsplayer/tsputil/FileSystemIo.cpp:14:#include <TspLogger.h>
AmTsplayer/tsputil/FileSystemIo.cpp:30:    ALOGI("FileSystem_create FileSystemCreateCount:%d\n",aMFileSystemCreateCount);
AmTsplayer/tsputil/FileSystemIo.cpp:119:        ALOGI("FileSystem_release mSystemControl == NULL FileSystemCreateCount:%d\n",aMFileSystemCreateCount);
AmTsplayer/tsputil/FileSystemIo.cpp:123:    ALOGI("FileSystem_release FileSystemCreateCount:%d\n",aMFileSystemCreateCount);
AmTsplayer/tsputil/FileSystemIo.cpp:187:    ALOGI("in");
AmTsplayer/tsputil/FileSystemIo.cpp:189:        ALOGI("%s have load",AUDIO_CLIENT_LIB_NAME);
AmTsplayer/tsputil/FileSystemIo.cpp:196:            ALOGI("load %s failed",AUDIO_CLIENT_LIB_NAME);
AmTsplayer/tsputil/FileSystemIo.cpp:206:        ALOGI("dlsym dvb_audio_get_latencyms failed, err=%s \n", dlerror());
AmTsplayer/tsputil/FileSystemIo.cpp:214:        ALOGI("dlsym dvb_audio_get_latencyms failed, err=%s \n", dlerror());
AmTsplayer/tsputil/FileSystemIo.cpp:218:    ALOGI("out");
AmTsplayer/tsputil/FileSystemIo.cpp:222:    ALOGI("in");
AmTsplayer/tsputil/FileSystemIo.cpp:226:        ALOGI("dclose success ");
AmTsplayer/tsputil/FileSystemIo.cpp:228:    ALOGI("out");
AmTsplayer/tsputil/FileSystemIo.cpp:240:    ALOGI("device %s createCount %d  DecodeType %d\n", (device == NULL) ? "= NULL" : "!=NULL", createAudioPatchCount ,DecodeType);
AmTsplayer/tsputil/FileSystemIo.cpp:245:            ALOGI("new gaudioClient_ops:%p \n",gaudioClient_ops);
AmTsplayer/tsputil/FileSystemIo.cpp:248:            ALOGE("audioClient_Ops is not valid");
AmTsplayer/tsputil/FileSystemIo.cpp:252:            ALOGI("Device loaded successfully device:%p",device);
AmTsplayer/tsputil/FileSystemIo.cpp:254:            ALOGE("Failed to load audio device");
AmTsplayer/tsputil/FileSystemIo.cpp:283:            ALOGI("create audio patch in");
AmTsplayer/tsputil/FileSystemIo.cpp:287:            ALOGI("create audio patch end");
AmTsplayer/tsputil/FileSystemIo.cpp:291:            ALOGI("mDtvDemuxIdBase:%d",mDtvDemuxIdBase);
AmTsplayer/tsputil/FileSystemIo.cpp:303:    //ALOGV("open file \"%s\"\n", name);
AmTsplayer/tsputil/FileSystemIo.cpp:305:        ALOGE("invalid args");
AmTsplayer/tsputil/FileSystemIo.cpp:312:        ALOGE("cannot open file \"%s\"", name);
AmTsplayer/tsputil/FileSystemIo.cpp:315:   // ALOGV("open file \"%s\" fd:%d ok\n", name,fd);
AmTsplayer/tsputil/FileSystemIo.cpp:319:        ALOGE("read failed file:\"%s\" value:\"%s\" error:\"%s\"\n", name, value, strerror(errno));
AmTsplayer/tsputil/FileSystemIo.cpp:324:    //    ALOGV("read file:\"%s\" value:\"%s\" ok \n", name, value);
AmTsplayer/tsputil/FileSystemIo.cpp:332:    //ALOGV("open file \"%s\"\n", name);
AmTsplayer/tsputil/FileSystemIo.cpp:337:        ALOGV("cannot open file \"%s\"", name);
AmTsplayer/tsputil/FileSystemIo.cpp:346:        ALOGV("write failed file:\"%s\" value:\"%s\" error:\"%s\"\n", name, value, strerror(errno));
AmTsplayer/tsputil/FileSystemIo.cpp:350:        //ALOGV("write file:\"%s\" value:\"%s\" ok \n", name, value);
AmTsplayer/tsputil/FileSystemIo.cpp:368:   // ALOGI("-->FileSystem_setAudioParam param1:%d param2:%d param3:%d param4:%d \n",param1,param2,param3,param4);
AmTsplayer/tsputil/FileSystemIo.cpp:373:        ALOGI("please check the audio patch handle for FileSystem_setAudioParam\n");
AmTsplayer/tsputil/FileSystemIo.cpp:420:            ALOGI("AudioHalWrapper_SET_VOLUME volume:%d setparam1:%d",param2,setparam1);
AmTsplayer/tsputil/FileSystemIo.cpp:425:            ALOGI("AudioHalWrapper_SET_MUTE mute:%d \n",setparam1);
AmTsplayer/tsputil/FileSystemIo.cpp:430:            ALOGI("AudioHalWrapper_SET_OUTPUT_MODE mode:%d \n",param2);
AmTsplayer/tsputil/FileSystemIo.cpp:443:            ALOGI("AudioHalWrapper_GET_STATUS\n");
AmTsplayer/tsputil/FileSystemIo.cpp:455:            ALOGI("AudioHalWrapper_CLOSE_DECODER in\n");
AmTsplayer/tsputil/FileSystemIo.cpp:458:            ALOGI("AudioHalWrapper_CLOSE_DECODER end\n");
AmTsplayer/tsputil/FileSystemIo.cpp:467:            ALOGI("AudioHalWrapper_SET_SECURITY_MEM_LEVEL = %d \n",param2);
AmTsplayer/tsputil/FileSystemIo.cpp:472:            ALOGI("AudioHalWrapper_SET_HAS_VIDEO = %d \n",param2);
AmTsplayer/tsputil/FileSystemIo.cpp:477:            ALOGI("AudioHalWrapper_SET_MEDIA_SYCN_ID need to add[to do] \n");
AmTsplayer/tsputil/FileSystemIo.cpp:482:            ALOGI("AudioHalWrapper_SET_AD_VOLUME setparam1:%d param2:%d \n",setparam1,param2);
AmTsplayer/tsputil/FileSystemIo.cpp:487:            ALOGI("AudioHalWrapper_AD_DUAL_SUPPORT setparam1:%d param2:%d \n",setparam1,param2);
AmTsplayer/tsputil/FileSystemIo.cpp:492:            ALOGI("AudioHalWrapper_AD_MIX_ENABLE setparam1:%d param2:%d \n",setparam1,param2);
AmTsplayer/tsputil/FileSystemIo.cpp:501:            ALOGI("AudioHalWrapper_SET_MEDIA_PRESENTATION_ID id:%d \n",param2);
AmTsplayer/tsputil/FileSystemIo.cpp:506:            ALOGI("AudioHalWrapper_SET_SPDIF_PROTECTION_STATUS mode:%d \n",param2);
AmTsplayer/tsputil/FileSystemIo.cpp:511:            ALOGI("AudioHalWrapper_SET_MEDIA_FIRST_LANG value:%d setparam1:%d \n",param2,setparam1);
AmTsplayer/tsputil/FileSystemIo.cpp:516:            ALOGI("AudioHalWrapper_SET_MEDIA_SECOND_LANG value:%d \n",param2);
AmTsplayer/tsputil/FileSystemIo.cpp:521:            ALOGI("AudioHalWrapper_SET_AC4_PAT value:%d \n",param2);
AmTsplayer/tsputil/FileSystemIo.cpp:527:                ALOGI("gstream pause\n");
AmTsplayer/tsputil/FileSystemIo.cpp:533:                ALOGI("gstream resume\n");
AmTsplayer/tsputil/FileSystemIo.cpp:539:                ALOGI("gstream flush\n");
AmTsplayer/tsputil/FileSystemIo.cpp:547:            // ALOGI("AudioHalWrapper_OPEN_OUTPUT_STREAM param2:%d \n",param2);
AmTsplayer/tsputil/FileSystemIo.cpp:558:            ALOGI("open_output_stream success gStream:%p format:0x%x sample_rate:%d channelmask:0x%02x \n",
AmTsplayer/tsputil/FileSystemIo.cpp:564:                ALOGI("close_output_stream gStream:%p in \n",gStream);
AmTsplayer/tsputil/FileSystemIo.cpp:566:                ALOGI("close_output_stream gStream:%p out \n",gStream);
AmTsplayer/tsputil/FileSystemIo.cpp:581:                ALOGI("AudioHalWrapper_ESMODE_SET_VOLUME volume:%d fvolume:%f \n",setparam1,(float) setparam1 / 100);
AmTsplayer/tsputil/FileSystemIo.cpp:586:            ALOGI("AudioHalWrapper_ESMODE_SET_MUTE mute:%d \n",(bool)setparam1);
AmTsplayer/tsputil/FileSystemIo.cpp:592:                // ALOGI("AudioHalWrapper_ESMODE_SET_DESCRIBE:%s\n", (char *)param2);
AmTsplayer/tsputil/FileSystemIo.cpp:598:                ALOGI("set hw_av_sync_type = %d \n",param2);
AmTsplayer/tsputil/FileSystemIo.cpp:605:                ALOGI("set hw_sync_id = %d \n",param2);
AmTsplayer/tsputil/FileSystemIo.cpp:612:                ALOGI("set has_video = %d \n",param2);
AmTsplayer/tsputil/FileSystemIo.cpp:618:            ALOGI("unknown audio cmd! \n");
AmTsplayer/tsputil/FileSystemIo.cpp:632:        //ALOGI("-->FileSystem_setAudioParam %p",gStream);
AmTsplayer/tsputil/FileSystemIo.cpp:659:        ALOGI("please check the audio patch handle for FileSystem_getAudioParam\n");
AmTsplayer/tsputil/FileSystemIo.cpp:670:                ALOGI("AudioHalWrapper_GET_DEMUX_ID_BASE pTemp:%p(%s) value:%d ret:%d",
AmTsplayer/tsputil/FileSystemIo.cpp:681:                ALOGI("AudioHalWrapper_GET_AC4_ACTIVE_PRES_ID pTemp:%p(%s) value:%d ret:%d",
AmTsplayer/tsputil/FileSystemIo.cpp:692:                //ALOGI("AudioHalWrapper_GET_ES_PTS_DTS_FLAG pTemp:%p(%s) value:%d ret:%d",
AmTsplayer/tsputil/FileSystemIo.cpp:704:                    //ALOGI("AudioHalWrapper_GET_ES_DECODE_FRAME pTemp:%p(%s) value:%d ret:%d",
AmTsplayer/tsputil/FileSystemIo.cpp:718:                    //ALOGI("AudioHalWrapper_GET_ES_DECODE_ERROR pTemp:%p(%s) value:%d ret:%d",
AmTsplayer/tsputil/FileSystemIo.cpp:732:                    //ALOGI("AudioHalWrapper_GET_ES_DECODE_DROP pTemp:%p(%s) value:%d ret:%d",
AmTsplayer/tsputil/FileSystemIo.cpp:739:            ALOGI("unknown audio cmd! \n");
AmTsplayer/tsputil/FileSystemIo.cpp:743:        //ALOGI("free pTemp:%p \n",pTemp);
AmTsplayer/tsputil/FileSystemIo.cpp:773:        ALOGI("FileSystem_release device == NULL\n");
AmTsplayer/tsputil/FileSystemIo.cpp:779:    ALOGI("device %s createCount %d  DecodeType %d in", (device == NULL) ? "= NULL" : "!=NULL", createAudioPatchCount ,DecodeType);
AmTsplayer/tsputil/FileSystemIo.cpp:782:            ALOGI("release audio patch in");
AmTsplayer/tsputil/FileSystemIo.cpp:784:            ALOGI("release audio patch out");
AmTsplayer/tsputil/FileSystemIo.cpp:789:    ALOGI("out");
AmTsplayer/tsputil/FileSystemIo.cpp:802:    ALOGV("open file \"%s\"\n", name);
AmTsplayer/tsputil/FileSystemIo.cpp:807:        ALOGV("cannot open file \"%s\"", name);
AmTsplayer/tsputil/FileSystemIo.cpp:816:        ALOGV("read failed file:\"%s\" cmd:\"%s\" error:\"%s\"\n", name, cmd, strerror(errno));
AmTsplayer/tsputil/FileSystemIo.cpp:821:        ALOGV("read file:\"%s\" cmd:\"%s\" ok \n", name, cmd);
AmTsplayer/tsputil/FileSystemIo.cpp:830:    ALOGV("open file \"%s\"\n", name);
AmTsplayer/tsputil/FileSystemIo.cpp:835:        ALOGV(fmt,...)("cannot open file \"%s\"", name);
AmTsplayer/tsputil/FileSystemIo.cpp:844:        ALOGV("write failed file:\"%s\" cmd:\"%s\" error:\"%s\"\n", name, cmd, strerror(errno));
AmTsplayer/tsputil/FileSystemIo.cpp:849:        ALOGV("write file:\"%s\" cmd:\"%s\" ok \n", name, cmd);
AmTsplayer/tsputil/SortedVector.h:197:    LOG_FATAL_IF(index>=size(),
AmTsplayer/tsputil/TSPMessage.cpp:17:#define LOG_TAG "TSPMessage"
AmTsplayer/tsputil/TSPMessage.cpp:18://#define LOG_NDEBUG 0
AmTsplayer/tsputil/TSPMessage.cpp:37:        ALOGE("trying to post a duplicate reply");
AmTsplayer/tsputil/TSPMessage.cpp:41:        ALOGE("setReply return no memory");
AmTsplayer/tsputil/TSPMessage.cpp:135:        ALOGI("called findItemIx %zu times (for len=%.1f i=%.1f/%.1f mem) dup %zu times (for len=%.1f)",
AmTsplayer/tsputil/TSPMessage.cpp:379:        ALOGW("failed to deliver message as target handler %d is gone.", mTarget);
AmTsplayer/tsputil/TSPMessage.cpp:389:        ALOGW("failed to post message as target looper for handler %d is gone.", mTarget);
AmTsplayer/tsputil/TSPMessage.cpp:400:        ALOGW("failed to post message as target looper for handler %d is gone.", mTarget);
AmTsplayer/tsputil/TSPMessage.cpp:406:        ALOGE("failed to create reply token");
AmTsplayer/tsputil/TSPMessage.cpp:416:        ALOGW("failed to post reply to a NULL token");
AmTsplayer/tsputil/TSPMessage.cpp:421:        ALOGW("failed to post reply as target looper is gone.");
AmTsplayer/tsputil/TSPMessage.cpp:592:                ALOGE("Unknown type %d", item.mType);
AmTsplayer/tsputil/KeyedVector.h:134:    LOG_ALWAYS_FATAL_IF(i<0, "%s: key not found", __PRETTY_FUNCTION__);
AmTsplayer/tsputil/KeyedVector.h:156:    LOG_ALWAYS_FATAL_IF(i<0, "%s: key not found", __PRETTY_FUNCTION__);
AmTsplayer/tsputil/TSPRefBase.cpp:17:#define LOG_TAG "TSP_RefBase"
AmTsplayer/tsputil/TSPRefBase.cpp:18:// #define LOG_NDEBUG 0
AmTsplayer/tsputil/TSPRefBase.cpp:42:// log all reference counting operations
AmTsplayer/tsputil/TSPRefBase.cpp:178:            ALOGE("Strong references remain:");
AmTsplayer/tsputil/TSPRefBase.cpp:182:                ALOGD("\t%c ID %p (ref %d):", inc, refs->id, refs->ref);
AmTsplayer/tsputil/TSPRefBase.cpp:184:                refs->stack.log(LOG_TAG);
AmTsplayer/tsputil/TSPRefBase.cpp:192:            ALOGE("Weak references remain!");
AmTsplayer/tsputil/TSPRefBase.cpp:196:                ALOGD("\t%c ID %p (ref %d):", inc, refs->id, refs->ref);
AmTsplayer/tsputil/TSPRefBase.cpp:198:                refs->stack.log(LOG_TAG);
AmTsplayer/tsputil/TSPRefBase.cpp:204:            ALOGE("above errors at:");
AmTsplayer/tsputil/TSPRefBase.cpp:205:            CallStack stack(LOG_TAG);
AmTsplayer/tsputil/TSPRefBase.cpp:210:        //ALOGD_IF(mTrackEnabled,
AmTsplayer/tsputil/TSPRefBase.cpp:216:        //ALOGD_IF(mTrackEnabled,
AmTsplayer/tsputil/TSPRefBase.cpp:226:        //ALOGD_IF(mTrackEnabled,
AmTsplayer/tsputil/TSPRefBase.cpp:281:                ALOGD("STACK TRACE for %p saved in %s", this, name);
AmTsplayer/tsputil/TSPRefBase.cpp:283:            else ALOGE("FAILED TO PRINT STACK TRACE for %p in %s: %s", this,
AmTsplayer/tsputil/TSPRefBase.cpp:335:            ALOGE("RefBase: removing id %p on RefBase %p"
AmTsplayer/tsputil/TSPRefBase.cpp:342:                ALOGD("\t%c ID %p (ref %d):", inc, ref->id, ref->ref);
AmTsplayer/tsputil/TSPRefBase.cpp:346:            CallStack stack(LOG_TAG);
AmTsplayer/tsputil/TSPRefBase.cpp:402:    ALOGD("incStrong of %p from %p: cnt=%d\n", this, id, c);
AmTsplayer/tsputil/TSPRefBase.cpp:419:    ALOGD("decStrong of %p from %p: cnt=%d\n", this, id, c);
AmTsplayer/tsputil/TSPRefBase.cpp:454:    ALOGD("forceIncStrong of %p from %p: cnt=%d\n", this, id, c);
AmTsplayer/tsputil/TSPRefBase.cpp:509:            // Thus we no longer do anything here.  We log this case, since it
AmTsplayer/tsputil/TSPRefBase.cpp:513:            // ALOGV("Freeing refs %p of old TSP_RefBase %p\n", this, impl->mBase);
AmTsplayer/tsputil/TSPRefBase.cpp:602:    ALOGD("attemptIncStrong of %p from %p: cnt=%d\n", this, id, curCount);
AmTsplayer/tsputil/Looper.cpp:6:#define LOG_TAG "Looper"
AmTsplayer/tsputil/Looper.cpp:8://#define LOG_NDEBUG 0
AmTsplayer/tsputil/Looper.cpp:67:    LOG_ALWAYS_FATAL_IF(mWakeEventFd < 0, "Could not make wake event fd: %s",
AmTsplayer/tsputil/Looper.cpp:84:    LOG_ALWAYS_FATAL_IF(result != 0, "Could not allocate TLS key.");
AmTsplayer/tsputil/Looper.cpp:110:    LOG_ALWAYS_FATAL_IF(result != 0, "pthread_once failed");
AmTsplayer/tsputil/Looper.cpp:123:        ALOGW("Looper already prepared for this thread with a different value for the "
AmTsplayer/tsputil/Looper.cpp:137:        ALOGD("%p ~ rebuildEpollLocked - rebuilding epoll set", this);
AmTsplayer/tsputil/Looper.cpp:144:    LOG_ALWAYS_FATAL_IF(mEpollFd < 0, "Could not create epoll instance: %s", strerror(errno));
AmTsplayer/tsputil/Looper.cpp:151:    LOG_ALWAYS_FATAL_IF(result != 0, "Could not add wake event fd to epoll instance: %s",
AmTsplayer/tsputil/Looper.cpp:161:            ALOGE("Error adding epoll events for fd %d while rebuilding epoll set: %s",
AmTsplayer/tsputil/Looper.cpp:170:        ALOGD("%p ~ scheduleEpollRebuildLocked - scheduling epoll set rebuild", this);
AmTsplayer/tsputil/Looper.cpp:188:                ALOGD("%p ~ pollOnce - returning signalled identifier %d: "
AmTsplayer/tsputil/Looper.cpp:201:            ALOGD("%p ~ pollOnce - returning result %d", this, result);
AmTsplayer/tsputil/Looper.cpp:215:    ALOGD("%p ~ pollOnce - waiting: timeoutMillis=%d", this, timeoutMillis);
AmTsplayer/tsputil/Looper.cpp:227:        ALOGD("%p ~ pollOnce - next message in %" PRId64 "ns, adjusted timeout: timeoutMillis=%d",
AmTsplayer/tsputil/Looper.cpp:261:        ALOGW("Poll failed with an unexpected error: %s", strerror(errno));
AmTsplayer/tsputil/Looper.cpp:269:        ALOGD("%p ~ pollOnce - timeout", this);
AmTsplayer/tsputil/Looper.cpp:277:    ALOGD("%p ~ pollOnce - handling events from %d fds", this, eventCount);
AmTsplayer/tsputil/Looper.cpp:287:                ALOGW("Ignoring unexpected epoll events 0x%x on wake event fd.", epollEvents);
AmTsplayer/tsputil/Looper.cpp:299:                ALOGW("Ignoring unexpected epoll events 0x%x on fd %d that is "
AmTsplayer/tsputil/Looper.cpp:324:                ALOGD("%p ~ pollOnce - sending message: handler=%p, what=%d",
AmTsplayer/tsputil/Looper.cpp:351:            ALOGD("%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p",
AmTsplayer/tsputil/Looper.cpp:399:    ALOGD("%p ~ wake", this);
AmTsplayer/tsputil/Looper.cpp:406:            LOG_ALWAYS_FATAL("Could not write wake signal to fd %d: %s",
AmTsplayer/tsputil/Looper.cpp:414:    ALOGD("%p ~ awoken", this);
AmTsplayer/tsputil/Looper.cpp:434:    ALOGD("%p ~ addFd - fd=%d, ident=%d, events=0x%x, callback=%p, data=%p", this, fd, ident,
AmTsplayer/tsputil/Looper.cpp:440:            ALOGE("Invalid attempt to set NULL callback but not allowed for this looper.");
AmTsplayer/tsputil/Looper.cpp:445:            ALOGE("Invalid attempt to set NULL callback with ident < 0.");
AmTsplayer/tsputil/Looper.cpp:471:                ALOGE("Error adding epoll events for fd %d: %s", fd, strerror(errno));
AmTsplayer/tsputil/Looper.cpp:493:                    ALOGD("%p ~ addFd - EPOLL_CTL_MOD failed due to file descriptor "
AmTsplayer/tsputil/Looper.cpp:499:                        ALOGE("Error modifying or adding epoll events for fd %d: %s",
AmTsplayer/tsputil/Looper.cpp:505:                    ALOGE("Error modifying epoll events for fd %d: %s", fd, strerror(errno));
AmTsplayer/tsputil/Looper.cpp:521:    ALOGD("%p ~ removeFd - fd=%d, seq=%d", this, fd, seq);
AmTsplayer/tsputil/Looper.cpp:534:            ALOGD("%p ~ removeFd - sequence number mismatch, oldSeq=%d",
AmTsplayer/tsputil/Looper.cpp:559:                ALOGD("%p ~ removeFd - EPOLL_CTL_DEL failed due to file descriptor "
AmTsplayer/tsputil/Looper.cpp:568:                ALOGE("Error removing epoll events for fd %d: %s", fd, strerror(errno));
AmTsplayer/tsputil/Looper.cpp:591:    ALOGD("%p ~ sendMessageAtTime - uptime=%" PRId64 ", handler=%p, what=%d",
AmTsplayer/tsputil/Looper.cpp:624:    ALOGD("%p ~ removeMessages - handler=%p", this, handler.get());
AmTsplayer/tsputil/Looper.cpp:641:    ALOGD("%p ~ removeMessages - handler=%p, what=%d", this, handler.get(), what);
AmTsplayer/tsputil/TSPHandler.cpp:17://#define LOG_NDEBUG 0
AmTsplayer/tsputil/TSPHandler.cpp:18:#define LOG_TAG "TSPHandler"
AmTsplayer/tsputil/tsplinux.c:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/tsputil/tsplinux.c:18:void linux_log_assert(const char* cond, const char* tag,
AmTsplayer/tsputil/tsplinux.c:20:    char buf[LOG_BUF_SIZE];
AmTsplayer/tsputil/tsplinux.c:25:      vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);
AmTsplayer/tsputil/tsplinux.c:28:      /* Msg not provided, log condition.  N.B. Do not use cond directly as
AmTsplayer/tsputil/tsplinux.c:33:        snprintf(buf, LOG_BUF_SIZE, "%s Assertion failed: %s",tag,cond);
AmTsplayer/tsputil/tsplinux.c:80:int android_errorWriteLog(int tag, const char* info)
AmTsplayer/tsputil/VectorImpl.cpp:17:#define LOG_TAG "Vector"
AmTsplayer/tsputil/VectorImpl.cpp:57:    ALOGW_IF(mCount,
AmTsplayer/tsputil/VectorImpl.cpp:66:    LOG_ALWAYS_FATAL_IF(mItemSize != rhs.mItemSize,
AmTsplayer/tsputil/VectorImpl.cpp:94:            LOG_ALWAYS_FATAL_IF(editable == NULL);
AmTsplayer/tsputil/VectorImpl.cpp:256:    ALOG_ASSERT(index<size(),
AmTsplayer/tsputil/VectorImpl.cpp:279:    ALOG_ASSERT((index+count)<=size(),
AmTsplayer/tsputil/VectorImpl.cpp:303:    ALOG_ASSERT(index<capacity(),
AmTsplayer/tsputil/VectorImpl.cpp:318:    ALOG_ASSERT(index<capacity(),
AmTsplayer/tsputil/VectorImpl.cpp:340:    LOG_ALWAYS_FATAL_IF(!safe_mul(&new_allocation_size, new_capacity, mItemSize));
AmTsplayer/tsputil/VectorImpl.cpp:376://    ALOGV("_grow(this=%p, where=%d, amount=%d) count=%d, capacity=%d",
AmTsplayer/tsputil/VectorImpl.cpp:379:    ALOG_ASSERT(where <= mCount,
AmTsplayer/tsputil/VectorImpl.cpp:384:    LOG_ALWAYS_FATAL_IF(!safe_add(&new_size, mCount, amount), "new_size overflow");
AmTsplayer/tsputil/VectorImpl.cpp:395:        LOG_ALWAYS_FATAL_IF(!safe_add(&new_capacity, new_size, (new_size / 2)),
AmTsplayer/tsputil/VectorImpl.cpp:397:        LOG_ALWAYS_FATAL_IF(!safe_add(&new_capacity, new_capacity, static_cast<size_t>(1u)),
AmTsplayer/tsputil/VectorImpl.cpp:402:        LOG_ALWAYS_FATAL_IF(!safe_mul(&new_alloc_size, new_capacity, mItemSize),
AmTsplayer/tsputil/VectorImpl.cpp:405://        ALOGV("grow vector %p, new_capacity=%d", this, (int)new_capacity);
AmTsplayer/tsputil/VectorImpl.cpp:454://    ALOGV("_shrink(this=%p, where=%d, amount=%d) count=%d, capacity=%d",
AmTsplayer/tsputil/VectorImpl.cpp:457:    ALOG_ASSERT(where + amount <= mCount,
AmTsplayer/tsputil/VectorImpl.cpp:462:    LOG_ALWAYS_FATAL_IF(!safe_sub(&new_size, mCount, amount));
AmTsplayer/tsputil/tsp_utils.c:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/tsputil/tsp_utils.c:10:#define LOG_NDEBUG 0
AmTsplayer/tsputil/tsp_utils.c:11:#define LOG_TAG "tsp"
AmTsplayer/tsputil/TSPLooper.cpp:17://#define LOG_NDEBUG 0
AmTsplayer/tsputil/TSPLooper.cpp:18:#define LOG_TAG "TSPLooper"
AmTsplayer/tsputil/TSPLooper.cpp:236:            ALOGE("awaitResponse mLock");
AmTsplayer/tsputil/Vector.h:288:    LOG_FATAL_IF(index>=size(),
AmTsplayer/tsputil/Unicode.h:150: * can ask to log a message and fail in case the invalid utf8 could have caused an override if no
AmTsplayer/tsputil/tsplinux.h:28:#define LOG_BUF_SIZE 1024
AmTsplayer/tsputil/tsplinux.h:33:#define ALOGW(fmt,...)            printf(fmt,##__VA_ARGS__)
AmTsplayer/tsputil/tsplinux.h:34:#define ALOGE(fmt,...)            printf(fmt,##__VA_ARGS__)
AmTsplayer/tsputil/tsplinux.h:35:#define ALOGV(fmt,...)            printf(fmt,##__VA_ARGS__)
AmTsplayer/tsputil/tsplinux.h:41:void linux_log_assert(const char* cond, const char* tag, const char* fmt, ...);
AmTsplayer/tsputil/tsplinux.h:43:int android_errorWriteLog(int tag, const char* info);
AmTsplayer/tsputil/tsplinux.h:49: * Normally we strip ALOGV (VERBOSE messages) from release builds.
AmTsplayer/tsputil/tsplinux.h:50: * You can modify this (for example with "#define LOG_NDEBUG 0"
AmTsplayer/tsputil/tsplinux.h:53:#ifndef LOG_NDEBUG
AmTsplayer/tsputil/tsplinux.h:55:#define LOG_NDEBUG 1
AmTsplayer/tsputil/tsplinux.h:57:#define LOG_NDEBUG 0
AmTsplayer/tsputil/tsplinux.h:63: * logging macros.  You can change this preprocessor definition
AmTsplayer/tsputil/tsplinux.h:66:#ifndef LOG_TAG
AmTsplayer/tsputil/tsplinux.h:67:#define LOG_TAG "RasterMill"
AmTsplayer/tsputil/tsplinux.h:73: * Simplified macro to send a verbose log message using the current LOG_TAG.
AmTsplayer/tsputil/tsplinux.h:75:#ifndef ALOGV
AmTsplayer/tsputil/tsplinux.h:76:#if LOG_NDEBUG
AmTsplayer/tsputil/tsplinux.h:77:#define ALOGV(...)   ((void)0)
AmTsplayer/tsputil/tsplinux.h:79:#define ALOGV(...) ((void)ALOG(LOG_VERBOSE, LOG_TAG, __VA_ARGS__))
AmTsplayer/tsputil/tsplinux.h:85:#ifndef ALOGV_IF
AmTsplayer/tsputil/tsplinux.h:86:#if LOG_NDEBUG
AmTsplayer/tsputil/tsplinux.h:87:#define ALOGV_IF(cond, ...)   ((void)0)
AmTsplayer/tsputil/tsplinux.h:89:#define ALOGV_IF(cond, ...) \
AmTsplayer/tsputil/tsplinux.h:91:    ? ((void)ALOG(LOG_VERBOSE, LOG_TAG, __VA_ARGS__)) \
AmTsplayer/tsputil/tsplinux.h:97: * Simplified macro to send a debug log message using the current LOG_TAG.
AmTsplayer/tsputil/tsplinux.h:99:#ifndef ALOGD
AmTsplayer/tsputil/tsplinux.h:100:#define ALOGD(...) ((void)ALOG(LOG_DEBUG, LOG_TAG, __VA_ARGS__))
AmTsplayer/tsputil/tsplinux.h:103:#ifndef ALOGD_IF
AmTsplayer/tsputil/tsplinux.h:104:#define ALOGD_IF(cond, ...) \
AmTsplayer/tsputil/tsplinux.h:106:    ? ((void)ALOG(LOG_DEBUG, LOG_TAG, __VA_ARGS__)) \
AmTsplayer/tsputil/tsplinux.h:111: * Simplified macro to send an info log message using the current LOG_TAG.
AmTsplayer/tsputil/tsplinux.h:113:#ifndef ALOGI
AmTsplayer/tsputil/tsplinux.h:114:#define ALOGI(...) ((void)ALOG(LOG_INFO, LOG_TAG, __VA_ARGS__))
AmTsplayer/tsputil/tsplinux.h:117:#ifndef ALOGI_IF
AmTsplayer/tsputil/tsplinux.h:118:#define ALOGI_IF(cond, ...) \
AmTsplayer/tsputil/tsplinux.h:120:    ? ((void)ALOG(LOG_INFO, LOG_TAG, __VA_ARGS__)) \
AmTsplayer/tsputil/tsplinux.h:125: * Simplified macro to send a warning log message using the current LOG_TAG.
AmTsplayer/tsputil/tsplinux.h:127:#ifndef ALOGW
AmTsplayer/tsputil/tsplinux.h:128:#define ALOGW(...) ((void)ALOG(LOG_WARN, LOG_TAG, __VA_ARGS__))
AmTsplayer/tsputil/tsplinux.h:131:#ifndef ALOGW_IF
AmTsplayer/tsputil/tsplinux.h:132:#define ALOGW_IF(cond, ...) \
AmTsplayer/tsputil/tsplinux.h:134:    ? ((void)ALOG(LOG_WARN, LOG_TAG, __VA_ARGS__)) \
AmTsplayer/tsputil/tsplinux.h:139: * Simplified macro to send an error log message using the current LOG_TAG.
AmTsplayer/tsputil/tsplinux.h:141:#ifndef ALOGE
AmTsplayer/tsputil/tsplinux.h:142:#define ALOGE(...) ((void)ALOG(LOG_ERROR, LOG_TAG, __VA_ARGS__))
AmTsplayer/tsputil/tsplinux.h:145:#ifndef ALOGE_IF
AmTsplayer/tsputil/tsplinux.h:146:#define ALOGE_IF(cond, ...) \
AmTsplayer/tsputil/tsplinux.h:148:    ? ((void)ALOG(LOG_ERROR, LOG_TAG, __VA_ARGS__)) \
AmTsplayer/tsputil/tsplinux.h:155: * Conditional based on whether the current LOG_TAG is enabled at
AmTsplayer/tsputil/tsplinux.h:158:#ifndef IF_ALOGV
AmTsplayer/tsputil/tsplinux.h:159:#if LOG_NDEBUG
AmTsplayer/tsputil/tsplinux.h:160:#define IF_ALOGV() if (false)
AmTsplayer/tsputil/tsplinux.h:162:#define IF_ALOGV() IF_ALOG(LOG_VERBOSE, LOG_TAG)
AmTsplayer/tsputil/tsplinux.h:167: * Conditional based on whether the current LOG_TAG is enabled at
AmTsplayer/tsputil/tsplinux.h:170:#ifndef IF_ALOGD
AmTsplayer/tsputil/tsplinux.h:171:#define IF_ALOGD() IF_ALOG(LOG_DEBUG, LOG_TAG)
AmTsplayer/tsputil/tsplinux.h:175: * Conditional based on whether the current LOG_TAG is enabled at
AmTsplayer/tsputil/tsplinux.h:178:#ifndef IF_ALOGI
AmTsplayer/tsputil/tsplinux.h:179:#define IF_ALOGI() IF_ALOG(LOG_INFO, LOG_TAG)
AmTsplayer/tsputil/tsplinux.h:183: * Conditional based on whether the current LOG_TAG is enabled at
AmTsplayer/tsputil/tsplinux.h:186:#ifndef IF_ALOGW
AmTsplayer/tsputil/tsplinux.h:187:#define IF_ALOGW() IF_ALOG(LOG_WARN, LOG_TAG)
AmTsplayer/tsputil/tsplinux.h:191: * Conditional based on whether the current LOG_TAG is enabled at
AmTsplayer/tsputil/tsplinux.h:194:#ifndef IF_ALOGE
AmTsplayer/tsputil/tsplinux.h:195:#define IF_ALOGE() IF_ALOG(LOG_ERROR, LOG_TAG)
AmTsplayer/tsputil/tsplinux.h:201: * Log a fatal error.  If the given condition fails, this stops program
AmTsplayer/tsputil/tsplinux.h:206:#ifndef LOG_ALWAYS_FATAL_IF
AmTsplayer/tsputil/tsplinux.h:207:#define LOG_ALWAYS_FATAL_IF(cond, ...) \
AmTsplayer/tsputil/tsplinux.h:209:    ? ((void)android_printAssert(#cond, LOG_TAG, ## __VA_ARGS__)) \
AmTsplayer/tsputil/tsplinux.h:213:#ifndef LOG_ALWAYS_FATAL
AmTsplayer/tsputil/tsplinux.h:214:#define LOG_ALWAYS_FATAL(...) \
AmTsplayer/tsputil/tsplinux.h:215:    ( (void)(android_printAssert(NULL, LOG_TAG, ## __VA_ARGS__)) )
AmTsplayer/tsputil/tsplinux.h:219: * Versions of LOG_ALWAYS_FATAL_IF and LOG_ALWAYS_FATAL that
AmTsplayer/tsputil/tsplinux.h:222:#if LOG_NDEBUG
AmTsplayer/tsputil/tsplinux.h:224:#ifndef LOG_FATAL_IF
AmTsplayer/tsputil/tsplinux.h:225:#define LOG_FATAL_IF(cond, ...) ((void)0)
AmTsplayer/tsputil/tsplinux.h:227:#ifndef LOG_FATAL
AmTsplayer/tsputil/tsplinux.h:228:#define LOG_FATAL(...) ((void)0)
AmTsplayer/tsputil/tsplinux.h:233:#ifndef LOG_FATAL_IF
AmTsplayer/tsputil/tsplinux.h:234:#define LOG_FATAL_IF(cond, ...) LOG_ALWAYS_FATAL_IF(cond, ## __VA_ARGS__)
AmTsplayer/tsputil/tsplinux.h:236:#ifndef LOG_FATAL
AmTsplayer/tsputil/tsplinux.h:237:#define LOG_FATAL(...) LOG_ALWAYS_FATAL(__VA_ARGS__)
AmTsplayer/tsputil/tsplinux.h:243: * Assertion that generates a log message when the assertion fails.
AmTsplayer/tsputil/tsplinux.h:244: * Stripped out of release builds.  Uses the current LOG_TAG.
AmTsplayer/tsputil/tsplinux.h:246:#ifndef ALOG_ASSERT
AmTsplayer/tsputil/tsplinux.h:247:#define ALOG_ASSERT(cond, ...) LOG_FATAL_IF(!(cond), ## __VA_ARGS__)
AmTsplayer/tsputil/tsplinux.h:248://#define ALOG_ASSERT(cond) LOG_FATAL_IF(!(cond), "Assertion failed: " #cond)
AmTsplayer/tsputil/tsplinux.h:254: * Basic log message macro.
AmTsplayer/tsputil/tsplinux.h:257: *  ALOG(LOG_WARN, NULL, "Failed with error %d", errno);
AmTsplayer/tsputil/tsplinux.h:261:#ifndef ALOG
AmTsplayer/tsputil/tsplinux.h:262:#define ALOG(priority, tag, ...) \
AmTsplayer/tsputil/tsplinux.h:263:    LOG_PRI(ANDROID_##priority, tag, __VA_ARGS__)
AmTsplayer/tsputil/tsplinux.h:267: * Log macro that allows you to specify a number for the priority.
AmTsplayer/tsputil/tsplinux.h:269:#ifndef LOG_PRI
AmTsplayer/tsputil/tsplinux.h:270:#define LOG_PRI(priority, tag, ...) \
AmTsplayer/tsputil/tsplinux.h:275: * Log macro that allows you to pass in a varargs ("args" is a va_list).
AmTsplayer/tsputil/tsplinux.h:277:#ifndef LOG_PRI_VA
AmTsplayer/tsputil/tsplinux.h:278:#define LOG_PRI_VA(priority, tag, fmt, args) \
AmTsplayer/tsputil/tsplinux.h:283: * Conditional given a desired logging priority and tag.
AmTsplayer/tsputil/tsplinux.h:285:#ifndef IF_ALOG
AmTsplayer/tsputil/tsplinux.h:286:#define IF_ALOG(priority, tag) \
AmTsplayer/tsputil/tsplinux.h:287:    if (__android_log_assert(ANDROID_##priority, tag))
AmTsplayer/tsputil/tsplinux.h:301:        linux_log_assert(cond, tag, \
AmTsplayer/tsputil/tsplinux.h:308:#endif /* LOG_H_ */
AmTsplayer/tsputil/FileSystemIo.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/tsputil/tsp_platform.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/tsputil/tsp_platform.h:14:#include "log/log.h"
AmTsplayer/tsputil/SysFs.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/tsputil/SysFs.h:10:#define LOG_NDEBUG 0
AmTsplayer/tsputil/SysFs.h:11://#define LOG_TAG "dvbfs"
AmTsplayer/tsputil/SysFs.h:42:        ALOGE("amsysfs_get_sysfs_str open failed\n");
AmTsplayer/tsputil/StrongPointer.cpp:17:#define LOG_TAG "TSP_sp"
AmTsplayer/tsputil/StrongPointer.cpp:21:void sp_report_race() { LOG_ALWAYS_FATAL("TSP_sp<> assignment detected data race"); }
AmTsplayer/tsputil/Thread.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/VideoDisplayBase.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/AudioOutBase.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/stbtrace.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/stbtrace.cpp:10:#define LOG_TAG "TIME_TRACE"
AmTsplayer/stbtrace.cpp:12:// #include <utils/Log.h>
AmTsplayer/stbtrace.cpp:13:#include <TspLogger.h>
AmTsplayer/stbtrace.cpp:18:    // ALOGI("init_stb_trace\n");
AmTsplayer/stbtrace.cpp:20:        ALOGE("input parameter was NULL, init_stb_trace failed!\n");
AmTsplayer/stbtrace.cpp:29:        ALOGE("input parameter was NULL, stb_trace_dbg failed!");
AmTsplayer/stbtrace.cpp:34:    ALOGI("[%s][%d] step: No-%d %s, time: %u, consume: %u \n", trace_info->module_name, key_step, trace_info->player_instansNo, step_str, cur_step_time, interval);
AmTsplayer/include/AmTsPlayer.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/include/AmTsPlayer.h:74:    AM_TSPLAYER_KEY_SET_LOGGER_LEVEL,
AmTsplayer/include/AmTsPlayer.h:970: *@param:        analog_mute    If analog mute or unmute .
AmTsplayer/include/AmTsPlayer.h:974:am_tsplayer_result  AmTsPlayer_setAudioMute(am_tsplayer_handle Handle, bool_t analog_mute, bool_t digital_mute);
AmTsplayer/include/AmTsPlayer.h:980: *@param:        *analog_unmute    If analog mute or unmute .
AmTsplayer/include/AmTsPlayer.h:984:am_tsplayer_result  AmTsPlayer_getAudioMute(am_tsplayer_handle Handle, bool_t *analog_unmute, bool_t *digital_unmute);
AmTsplayer/adsoftwrap/AudioHalUtil.cpp:3:#define LOG_TAG "audiohalutil"
AmTsplayer/adsoftwrap/AudioHalUtil.cpp:11:#define adec_print(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:11://#define LOG_NDEBUG 0
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:12:#define LOG_TAG "AudioSoftWrapper"
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:13:#include <utils/Log.h>
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:75:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s-%d " fmt, number,this, __FUNCTION__, __LINE__, ##__VA_ARGS__)
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:76:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s-%d " fmt, number,this, __FUNCTION__, __LINE__, ##__VA_ARGS__)
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:77:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s-%d " fmt, number,this, __FUNCTION__, __LINE__, ##__VA_ARGS__)
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:143:        FLOGI(mPlayerInstanceNo,"prop vendor.media.omx.ffmpeg.checkframe, mCheckframeProp:%s", mCheckframeProp.c_str());
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:146:    FLOGI(mPlayerInstanceNo,"mAudioDelayTime:%d, mSpliceEsCount:%d\n",mAudioDelayTime, mSpliceEsCount);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:153:    FLOGI(mPlayerInstanceNo,"mState:%s", debugPrintState(mState));
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:157:    FLOGI(mPlayerInstanceNo,"in\n");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:167:            FLOGI(mPlayerInstanceNo,"set prop vendor.media.omx.ffmpeg.checkframe false");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:175:        FLOGI(mPlayerInstanceNo,"release mAudioSoftLooper.clear\n");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:177:    FLOGI(mPlayerInstanceNo," out \n");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:192:    FLOGV(mPlayerInstanceNo,"AudioSoftWrapper::registerCallback \n");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:246:            FLOGI(mPlayerInstanceNo,"can not find bitstreamId %d,mInputBuffers.size:%d\n", index,(int)mInputBuffers.size());
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:252:            FLOGI(mPlayerInstanceNo,"pbuf == NULL\n");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:257:              FLOGI(mPlayerInstanceNo,"pbuf == iter->second\n");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:262:            FLOGI(mPlayerInstanceNo, "EVENT_TYPE_INPUT_AUDIO_BUFFER_DONE");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:285:        FLOGI(mPlayerInstanceNo,"saw EOS");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:289:        FLOGI(mPlayerInstanceNo,"AsyncOutputAvailable offset:%d index:%d size:%d time:%" PRId64 "\n",bufferInfo->offset,
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:321:    FLOGI(mPlayerInstanceNo,"mime:%s, sample:%d(pre:%d), channelCount:%d(pre:%d), mIsPassthroughEnable:%d\n",
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:365:        FLOGE(mPlayerInstanceNo,"%d actionCode:%d\n", error, actionCode);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:367:        FLOGE(mPlayerInstanceNo,"%d actionCode:%d detail:%s\n", error, actionCode, detail);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:505:    FLOGI(mPlayerInstanceNo,"mPid:0x%x afmt:%d, nChannels:%d, nSampleRate:%d\n",aid,afmt, nChannels, nSampleRate);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:520:    FLOGI(mPlayerInstanceNo, "mCodecid 0x%x, mChannels:%u, mMime:%s\n", mCodecid, mChannels, mMime);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:524:    FLOGI(mPlayerInstanceNo,"nExtraDataSize:%u pExtraData:%p\n", nExtraDataSize, pExtraData);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:553:    FLOGI(mPlayerInstanceNo,"mState:%s", debugPrintState(mState));
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:560:    FLOGI(mPlayerInstanceNo,"mState:%s", debugPrintState(mState));
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:567:    FLOGI(mPlayerInstanceNo,"mState:%s", debugPrintState(mState));
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:574:    FLOGI(mPlayerInstanceNo,"mState:%s", debugPrintState(mState));
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:595:        FLOGI(mPlayerInstanceNo,"release mAudioSoftLooper.clear\n");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:616:        FLOGI(mPlayerInstanceNo,"SetVolume :%d \n",volume);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:619:        FLOGI(mPlayerInstanceNo,"mAudioTrackOut== NULL SetVolume :%d \n",volume);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:656:        FLOGI(mPlayerInstanceNo,"SetSpeed :%f\n", speed);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:659:        FLOGI(mPlayerInstanceNo," mAudioTrackOut== NULL SetSpeed :%f\n", speed);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:666:    FLOGV(mPlayerInstanceNo,"format %d, time %d, flush %d",
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:681:    FLOGE(mPlayerInstanceNo,"notifyComplete is %d\n",notifyComplete);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:790:        FLOGI(mPlayerInstanceNo, "is_passthrough_active:%d", is_passthrough_active);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:811:        FLOGI(mPlayerInstanceNo, "digital_format:%d", digital_format);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:820:    FLOGI(mPlayerInstanceNo, "isPassthroughSupported() audioFormat %0x", audioFormat);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:845:             FLOGE(mPlayerInstanceNo, "PRIMARY_AUDIO_DEVICE NULL");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:863:                ALOGE("getReportedSurroundFormats error");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:866:            ALOGV("numReportSurroundFormats %d", numReportSurroundFormats);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:869:                ALOGE("getSurroundFormats error");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:872:            ALOGV("numSurroundFormats %d", numSurroundFormats);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:875:                ALOGV("reportSurroundFormats[%zu] %0x ", i, reportSurroundFormats[i]);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:879:                        ALOGV("surroundFormats[%zu] %0x ", j, surroundFormats[j]);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:889:                ALOGV("numSurroundFormats %d",numSurroundFormats);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:891:                    ALOGV("surroundFormats[%zu] %0x surroundFormatsEnabled[%zu] %d",
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:912:        FLOGI(mPlayerInstanceNo, "dolby_ms12_enable:%d ", dolby_ms12_enable);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:939:        ALOGI("%s   streamType=%d,  audioDevices=0x%x", __func__, streamType, audioDevices);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:948:    //ALOGI("streamType=%d, audioDevices=0x%x", streamType, audioDevices);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:965:        FLOGI(mPlayerInstanceNo, "sampleRate:%d ", sampleRate);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:973:                 FLOGI(mPlayerInstanceNo, "set audio_type dts");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:978:                FLOGI(mPlayerInstanceNo, "set audio_type ac3");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:983:                FLOGI(mPlayerInstanceNo, "set audio_type eac3");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1008:                    FLOGI(mPlayerInstanceNo, "%s return digital_raw:%d",
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1012:                        FLOGI(mPlayerInstanceNo, "INVALID digital_raw0), passthrough(0)");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1018:                                FLOGI(mPlayerInstanceNo, "INVALID digital_raw(1), passthrough(1) ac3/eac3");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1021:                                FLOGI(mPlayerInstanceNo, "INVALID digital_raw(1), passthrough(0) ac3/eac3");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1027:                               FLOGI(mPlayerInstanceNo, "INVALID digital_raw(1), passthrough(1) dts/dtshd");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1030:                               FLOGI(mPlayerInstanceNo, "INVALID digital_raw(1), passthrough(0) dts/dtshd");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1039:                                FLOGI(mPlayerInstanceNo, "INVALID digital_raw(2), passthrough(2) eac3");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1042:                                FLOGI(mPlayerInstanceNo, "INVALID digital_raw(2), passthrough(1) ac3");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1045:                                FLOGI(mPlayerInstanceNo, "INVALID digital_raw(2), passthrough(0) ac3/eac3");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1051:                                FLOGI(mPlayerInstanceNo, "INVALID digital_raw(2), passthroug(2) dtshd");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1054:                               FLOGI(mPlayerInstanceNo, "INVALID digital_raw(2), passthrough(1) dts");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1057:                               FLOGI(mPlayerInstanceNo, "INVALID digital_raw(2), passthrough(1) dts/dtshd");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1061:                        FLOGE(mPlayerInstanceNo, "INVALID digital_raw value !!!");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1066:                    FLOGI(mPlayerInstanceNo, "PCM passthrough(0)");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1089:                         FLOGI(mPlayerInstanceNo, "RAW is_passthrough_enable 2");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1099:                                FLOGI(mPlayerInstanceNo, "BYPASS passthrough(2) ac3");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1102:                                FLOGI(mPlayerInstanceNo, "BYPASS passthrough(0) ac3");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1107:                                FLOGI(mPlayerInstanceNo, "BYPASS passthrough(2) eac3");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1110:                                FLOGI(mPlayerInstanceNo, "BYPASS passthrough(1) eac3");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1113:                                FLOGI(mPlayerInstanceNo, "BYPASS passthrough(0) eac3");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1119:                                FLOGI(mPlayerInstanceNo, "BYPASS passthrough(2) dts");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1122:                                FLOGI(mPlayerInstanceNo, "BYPASS passthrough(1) dts");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1125:                                FLOGI(mPlayerInstanceNo, "BYPASS passthrough(0) dts");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1131:                            FLOGI(mPlayerInstanceNo, "BYPASS passthrough(1) eacs");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1158:    FLOGI(mPlayerInstanceNo,"mime:%s, sampleRate:%d, channels:%d\n",
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1200:    FLOGI(mPlayerInstanceNo, "sampleRate:%d, channelCount:%d, aformat:0x%x, channelMask:0x%x, "
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1208:            FLOGE(mPlayerInstanceNo, "init failed, retry:%d", (i + 1));
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1218:    FLOGI(mPlayerInstanceNo,"mState:%s", debugPrintState(mState));
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1233:            FLOGI(mPlayerInstanceNo, "mIsPassthroughEnable:%d ", mIsPassthroughEnable);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1251:            FLOGE(mPlayerInstanceNo,"new ABuffer failed!");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1257:            FLOGI(mPlayerInstanceNo,"set prop vendor.media.omx.ffmpeg.checkframe success");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1262:        FLOGE(mPlayerInstanceNo,"failed to createDecoder, mMime:%s", mMime);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1267:        FLOGE(mPlayerInstanceNo,"failed to configure decoder");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1282:    FLOGI(mPlayerInstanceNo, "mState:%s, mIsPassthroughEnable:%d, mSpeed:%f",
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1315:            FLOGI(mPlayerInstanceNo,"pthread_create ok mAudioThread:%ld\n",mAudioThread);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1317:            FLOGI(mPlayerInstanceNo,"pthread_create errno:%d (%s) \n",errno,strerror(errno));
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1325:    FLOGI(mPlayerInstanceNo,"mState:%s", debugPrintState(mState));
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1332:        FLOGI(mPlayerInstanceNo,"resume called when renderer is gone or not set");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1338:        FLOGI(mPlayerInstanceNo,"resume time:%" PRId64 ", mResumePosition:%d", audioouttimestamp, mResumePosition);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1349:    FLOGI(mPlayerInstanceNo,"mState:%s", debugPrintState(mState));
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1361:        FLOGI(mPlayerInstanceNo,"pause called when renderer is gone or not set");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1367:    FLOGI(mPlayerInstanceNo,"mState:%s", debugPrintState(mState));
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1396:            FLOGE(mPlayerInstanceNo,"failed to stop decoder");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1438:        FLOGE(mPlayerInstanceNo,"mState != STARTED\n");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1442:       FLOGE(mPlayerInstanceNo,"aMCodec == nullptr\n");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1446:        FLOGE(mPlayerInstanceNo,"mPid == 0x1FFF\n");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1454:        FLOGI(mPlayerInstanceNo,"queueInputBuffer size:%d mediatime:%" PRId64 "(%" PRId64 ")\n",
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1464:                FLOGE(mPlayerInstanceNo,"time out\n");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1470:           FLOGE(mPlayerInstanceNo,"index < 0\n");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1478:                   // FLOGI(mPlayerInstansNo,"mState != STARTED in line %d\n",__LINE__);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1488:        //ALOGI("AudioSoftWrapper::write buf %s bufsize:%d AMediaCodec_getInputBuffer\n",
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1533:        FLOGI(mPlayerInstanceNo,"queueInputBuffer mediatime%" PRId64 "\n", timestamp * 100 / 9);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1545:    ALOGI("[No-%d](%p)----->Audio_Write_Es_thread start<------\n", mAudioDec->mPlayerInstanceNo, mAudioDec);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1574:                    ALOGI("[No-%d](%p)first writer es getMediaCodeInBufferSize:%d ",
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1591:                        ALOGI("[No-%d](%p)Splicing  es getMediaCodeInBufferSize:%d mMediaCodeInBufferSize:%d",
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1625:    ALOGI("[No-%d](%p)----->Audio_Write_Es_thread end<-----\n", mAudioDec->mPlayerInstanceNo, mAudioDec);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1638:        FLOGI(mPlayerInstanceNo,"mState:%s", debugPrintState(mState));
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1647:        FLOGE(mPlayerInstanceNo,"msg->findInt32 index err");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1650:        FLOGE(mPlayerInstanceNo,"msg->findInt64 timestampUs err");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1653:        FLOGE(mPlayerInstanceNo,"msg->findInt32 Render err");
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1662:        FLOGE(mPlayerInstanceNo,"return index:%d timestampUs:%" PRId64 " info.mTimeUs:%" PRId64 " \n",index,timestampUs,info.mTimeUs);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1667:        FLOGI(mPlayerInstanceNo,"------------->onRenderAudioBuffer drop, pts:%" PRId64 " \n", timestampUs);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1700:                FLOGI(mPlayerInstanceNo,"mBytesWritten:%" PRId64 ", position:%d, cache_samples:%" PRId64 ", audioouttimestamp:%" PRId64 ", mResumePosition:%d",
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1707:                FLOGI(mPlayerInstanceNo,"pts jumb back, nowmediaTimeUs:%" PRId64 ", mediaTimeUs:%" PRId64 ", mRendNowMediaTimeUs:%" PRId64 "",
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1715:                    FLOGI(mPlayerInstanceNo,"---------->mBytesWritten:%" PRId64 " position %d  \n",mBytesWritten,position);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1716:                    FLOGI(mPlayerInstanceNo,"---------->Time difference from the first frame : %" PRId64 " ",(timestampUs - mFirstUpDataTime));
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1724:                    FLOGI(mPlayerInstanceNo,"update PTS:%" PRId64 " (%" PRId64 ") NowRenderPts:%" PRId64 " (%" PRId64 ") \tNowUs:%" PRId64 " (%" PRId64 ") \tdelayTimeUs:%" PRId64 "\n",
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1736:        //ALOGI("--->onRenderAudioBuffer mediatimeus:%" PRId64 "(%" PRId64 ") \n",mediaTimeUs,mediaTimeUs-mRendMediaTimeUs);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1741:        FLOGI(mPlayerInstanceNo,"---------->mFirstUpDataTime : %" PRId64 " index:%d mTimeUs:%" PRId64 " \n",mFirstUpDataTime,index,info.mTimeUs);
AmTsplayer/adsoftwrap/AudioSoftWrapper.cpp:1758:                FLOGI(mPlayerInstanceNo,"---->timestampUs:%" PRId64 " mBytesWritten:%" PRId64 " written:%d position:%d audioouttimestamp:%" PRId64 " \n",
AmTsplayer/adsoftwrap/PtsServer.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/adsoftwrap/amacodec.h:2: * Copyright (C) 2018 Amlogic Corporation.
AmTsplayer/adsoftwrap/amacodec.cpp:2: * Copyright (C) 2018 Amlogic Corporation.
AmTsplayer/adsoftwrap/amacodec.cpp:18:#define LOG_TAG "amacodec"
AmTsplayer/adsoftwrap/amacodec.cpp:28:#include <utils/Log.h>
AmTsplayer/adsoftwrap/amacodec.cpp:34:#define adec_print(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
AmTsplayer/adsoftwrap/amacodec.cpp:121:    ALOGV("ctor alsa_ops\n");
AmTsplayer/adsoftwrap/amacodec.cpp:126:    ALOGV("alsa_ops leave\n");
AmTsplayer/adsoftwrap/amacodec.cpp:133:        ALOGE("alsaInit has inited\n");
AmTsplayer/adsoftwrap/amacodec.cpp:145:            ALOGE( "unable to dlopen libvideotunnel.so: %s", dlerror());
AmTsplayer/adsoftwrap/amacodec.cpp:154:        ALOGE(" dlsym alsa_pcm_open failed, err=%s \n", dlerror());
AmTsplayer/adsoftwrap/amacodec.cpp:162:        ALOGE(" dlsym alsa_vt_close failed, err=%s \n", dlerror());
AmTsplayer/adsoftwrap/amacodec.cpp:170:        ALOGE("dlsym alsa_pcm_ioctl failed, err=%s \n", dlerror());
AmTsplayer/adsoftwrap/amacodec.cpp:178:        ALOGE("dlsym alsa_pcm_write failed, err=%s \n", dlerror());
AmTsplayer/adsoftwrap/amacodec.cpp:186:        ALOGE("dlsym alsa_pcm_is_ready failed, err=%s \n", dlerror());
AmTsplayer/adsoftwrap/amacodec.cpp:190:    ALOGI( "alsaInit ok %p\n",this);
AmTsplayer/adsoftwrap/amacodec.cpp:204:    ALOGI("alsaRelease\n");
AmTsplayer/adsoftwrap/amacodec.cpp:363:        ALOGD("card open success");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:12:#define LOG_NDEBUG 0
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:13:#define LOG_TAG "AudioTrackOut"
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:14:#include <utils/Log.h>
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:43:    ALOGI("AudioTrackOut(%p)\n",this);
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:52:    ALOGI("~AudioTrackOut(%p)\n",this);
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:75:    ALOGI("initialize \n");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:77:        ALOGE("initialize mAudioTrack == null return\n");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:82:        ALOGE("initialize mAudioTrack initcheck fail return\n");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:85:    ALOGI("initialize ok\n");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:101:    ALOGI("initializeForPassthrough \n");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:103:        ALOGE("initializeForPassthrough mAudioTrack == null return\n");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:108:        ALOGE("initializeForPassthrough mAudioTrack initcheck fail return\n");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:111:    ALOGI("initializeForPassthrough ok\n");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:118:    ALOGI("uninitialize \n");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:133:        ALOGE("AudioTrackOut write mAudioTrack \n");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:138:        ALOGE("AudioTrackOut write mAudioTrack stopped return\n");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:145:        ALOGE("AudioTrackOut write Size < framesize return\n");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:151:        ALOGE("write to audiotrack with error size\n");
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:216:        ALOGI("(%p) mAudioTrack -----> SetVolume :%d \n",this,volume);
AmTsplayer/adsoftwrap/AudioTrackOut.cpp:261:        ALOGI("(%p) mAudioTrack -----> SetSpeed :%f \n", this, speed);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:11://#define LOG_NDEBUG 0
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:12:#define LOG_TAG "AudioAdecWrapper"
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:13:#include <utils/Log.h>
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:59:        //ALOGI("%s buffer %p size %d flen %d\n", __FUNCTION__, buffer, size,flen);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:99:    ALOGI("AudioAdecWrapper : (%p) mAudioDelayTime:%d\n",this,mAudioDelayTime);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:119:    ALOGI("AudioAdecWrapper : (%p)\n",this);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:124:    ALOGI("~AudioAdecWrapper in \n");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:146:        ALOGV("release mAudioSoftLooper.clear\n");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:148:    ALOGI("~AudioAdecWrapper out (%p)\n",this);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:163:    ALOGV("AudioAdecWrapper::registerCallback \n");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:253:    ALOGI("SetAudioParam mPid:0x%x afmt:%d\n",aid,afmt);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:261:    ALOGI("SetAudioParam mCodecid 0x%x\n",mCodecid);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:328:        ALOGV("release mAudioSoftLooper.clear\n");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:353:    ALOGI("(%p) mAudioTrackOut== NULL SetVolume :%d \n",this,volume);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:374:    ALOGV("finishHandleDiscontinuity: format %d, time %d, flush %d",
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:389:    ALOGE("notifyComplete is %d\n",notifyComplete);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:492:        ALOGE("acodec_init failed");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:501:        ALOGE("audio_pcmopen failed");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:525:            ALOGI("uio init error! \n");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:530:            ALOGI("pthread_create ok mAudioReadThread:%ld\n",mAudioReadThread);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:532:            ALOGE("pthread_create errno:%d (%s) \n",errno,strerror(errno));
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:540:            ALOGI("pthread_create ok mAudioWriteThread:%ld\n",mAudioWriteThread);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:542:            ALOGE("pthread_create errno:%d (%s) \n",errno,strerror(errno));
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:559:        ALOGW("resume called when renderer is gone or not set");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:576:        ALOGW("pause called when renderer is gone or not set");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:654:        ALOGI("mFirstPtsUs %" PRId64 " us" , mFirstPtsUs);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:671:        ALOGE("AudioAdecWrapper::Write mState != STARTED\n");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:676:        ALOGE("AudioAdecWrapper::Write mPid == 0x1FFF\n");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:680:        ALOGE("AudioAdecWrapper::Write bytesUsed < 0\n");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:874:                //ALOGI("wait %d ms buffer_size %d left %d", 5 * trycount, buffer_size, nNextReadSize);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:877:                //ALOGI("wait %d ms buffer_size %d left %d", 5 * trycount, buffer_size, nNextReadSize);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:888:         ALOGI("rlen %d buffer_size %d",rlen,buffer_size);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:906:                ALOGE("inbuf malloc failed");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:920:        ALOGV("uio_read_buffer nRet:%d nNextReadSize %d \n",nRet, nNextReadSize);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:929:                ALOGE("mEsData malloc failed ");
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:1000:                ALOGI("---------->mBytesWritten:%" PRId64 "\n",mBytesWritten);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:1001:                ALOGI("---------->Time difference from the first frame : %" PRId64 " ",timestampUs - mFirstUpDataTime);
AmTsplayer/adsoftwrap/AudioAdecWrapper.cpp:1003:            ALOGI("onOutputBufferDone update mediatimeus:%" PRId64 "(%" PRId64 ") nowmediaTimeUs:%" PRId64 "(%" PRId64 ")  nowTimeUs:%" PRId64 "\n",
AmTsplayer/adsoftwrap/AudioAdecWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/adsoftwrap/AudioAdecWrapper.h:231:                ALOGI("%s ---> state: UNINITIALIZED \n",s);
AmTsplayer/adsoftwrap/AudioAdecWrapper.h:234:                ALOGI("%s ---> state: UNPREPARED \n",s);
AmTsplayer/adsoftwrap/AudioAdecWrapper.h:237:                ALOGI("%s ---> state: PREPARED \n",s);
AmTsplayer/adsoftwrap/AudioAdecWrapper.h:240:                ALOGI("%s ---> state: PAUSED \n",s);
AmTsplayer/adsoftwrap/AudioAdecWrapper.h:243:                ALOGI("%s ---> state: STARTED \n",s);
AmTsplayer/adsoftwrap/AudioAdecWrapper.h:246:                ALOGI("%s ---> state: STOPPING \n",s);
AmTsplayer/adsoftwrap/AudioAdecWrapper.h:249:                ALOGI("%s ---> state: STOPPED \n",s);
AmTsplayer/adsoftwrap/AudioSoftWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
AmTsplayer/adsoftwrap/UioAudioRead.cpp:2: * Copyright (C) 2018 Amlogic Corporation.
AmTsplayer/adsoftwrap/UioAudioRead.cpp:18:#define LOG_TAG "UioAudioRead"
AmTsplayer/adsoftwrap/UioAudioRead.cpp:25:#include <cutils/log.h>
AmTsplayer/adsoftwrap/UioAudioRead.cpp:74:            ALOGE("%s:read failed! \n", __func__);
AmTsplayer/adsoftwrap/UioAudioRead.cpp:79:        ALOGE("%s: open %s node failed! return 0, err: %s\n", __func__, path, strerror(errno));
AmTsplayer/adsoftwrap/UioAudioRead.cpp:111:        ALOGI("error open UIO 0\n");
AmTsplayer/adsoftwrap/UioAudioRead.cpp:117:    ALOGI("phys_start %0x", phys_start);
AmTsplayer/adsoftwrap/UioAudioRead.cpp:119:    ALOGI("phys_size %0x", phys_size);
AmTsplayer/adsoftwrap/UioAudioRead.cpp:121:    ALOGI("phys_offset %0x", phys_offset);
AmTsplayer/adsoftwrap/UioAudioRead.cpp:124:    ALOGI("add=%08x, size=%08x, phy_offset=%08x, addr_offset=%d\n",
AmTsplayer/adsoftwrap/UioAudioRead.cpp:132:        ALOGI("map /dev/uio0 failed\n");
AmTsplayer/adsoftwrap/UioAudioRead.cpp:158:    ALOGI("audio_dec_release done \n");
AmTsplayer/adsoftwrap/UioAudioRead.cpp:194:            ALOGI("read_buffer while AIU_MEM_AIFIFO_BYTES_AVAIL = %d!!\n", bytes);
AmTsplayer/adsoftwrap/UioAudioRead.cpp:197:                ALOGI("goto out!!\n");
AmTsplayer/adsoftwrap/UioAudioRead.cpp:208:                    ALOGI("FATAL err,AIFIFO is not ready,check!!\n");
AmTsplayer/adsoftwrap/UioAudioRead.h:2: * Copyright (C) 2018 Amlogic Corporation.
AmTsplayer/adsoftwrap/PtsServer.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/adsoftwrap/PtsServer.cpp:10:#define LOG_TAG "PtsServer"
AmTsplayer/adsoftwrap/PtsServer.cpp:16:#include <cutils/log.h>
AmTsplayer/adsoftwrap/PtsServer.cpp:61:        ALOGE("PtsServ_open [%s] failed,ret=%d error=%d(%s) used_times=%d*10(ms)\n",
AmTsplayer/adsoftwrap/PtsServer.cpp:79:        ALOGE("PtsServ_ioctl cmd [%d] faided,ret:%d error:%d(%s)\n",
AmTsplayer/adsoftwrap/PtsServer.cpp:118:        ALOGI("Use dynamic alloc driver ptsserver,mPServerId:%d ret:%d\n",mPServerId,ret);
AmTsplayer/adsoftwrap/PtsServer.cpp:126:        ALOGI("Use static alloc driver ptsserver,mPServerId:%d ret:%d\n",mPServerId,ret);
AmTsplayer/adsoftwrap/PtsServer.cpp:133:    ALOGI("~PtsServerDriver in");
AmTsplayer/adsoftwrap/PtsServer.cpp:135:    ALOGI("driver ptsserver close dev\n");
AmTsplayer/adsoftwrap/PtsServer.cpp:139:    ALOGI("~PtsServerDriver ok");
AmTsplayer/AmTsPlayerProperty.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/AmTsPlayerProperty.cpp:14:#include <log/log.h>
AmTsplayer/AmTsPlayerProperty.cpp:26:        ALOGE("input parameter was NULL, AmTsPlayer_getPropertyInt failed!");
AmTsplayer/AmTsPlayerProperty.cpp:48:        ALOGE("input parameter was NULL, AmTsPlayer_propertyGet failed!");
AmTsplayer/gitInfo.go:57:        dir = string(ctx.Config().Getenv("PWD")) + "/vendor/amlogic/common/" + "media_hal"
AmTsplayer/gitInfo.go:109:    commitNumsCmd := "cd "+ getMediaHalRoot(ctx, sdkVersionInt) + " && git log | grep \"Change-Id: \" | grep -n " + strings.Replace(string(baseChangeIdout),"\n","",-1) + " | awk -F \":\" '{printf \"%d\", $1-1}'"
AmTsplayer/gitInfo.go:137:    gitLastChangCmd := "cd " + getMediaHalRoot(ctx, sdkVersionInt) + "&& git log | grep Date -m 1 | awk '$1=$1'"
AmTsplayer/gitInfo.go:159:    gitComitPdCmd := "cd " + getMediaHalRoot(ctx, sdkVersionInt) + "&& git log | grep PD# -m 1 | awk '$1=$1'"
AmTsplayer/gitInfo.go:165:    gitComitChandIdCmd := "cd " + getMediaHalRoot(ctx, sdkVersionInt) + "" + "&& git log | grep Change-Id -m 1 | awk '$1=$1'"
AmTsplayer/gitInfo.go:174:    buildName := string(ctx.Config().Getenv("LOGNAME"))
AmTsplayer/A.mk:69:    $(TOP)/vendor/amlogic/common/frameworks/services/systemcontrol \
AmTsplayer/A.mk:70:    $(TOP)/vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include \
AmTsplayer/A.mk:74:    $(TOP)/hardware/amlogic/gralloc \
AmTsplayer/A.mk:86:        liblog \
AmTsplayer/A.mk:89:        vendor.amlogic.hardware.systemcontrol@1.0 \
AmTsplayer/A.mk:90:        vendor.amlogic.hardware.systemcontrol@1.1 \
AmTsplayer/A.mk:101:GIT_VERSION="$(shell cd $(LOCAL_PATH);git log | grep commit -m 1 | cut -d' ' -f 2)"
AmTsplayer/A.mk:103:LAST_CHANGED="$(shell cd $(LOCAL_PATH);git log | grep Date -m 1)"
AmTsplayer/A.mk:105:BUILD_NAME=" $(shell echo ${LOGNAME})"
AmTsplayer/A.mk:109:COMMIT_PD="$(shell cd $(LOCAL_PATH);git log | grep PD# -m 1)"
AmTsplayer/A.mk:110:COMMIT_CHANGEID="$(shell cd $(LOCAL_PATH);git log | grep Change-Id -m 1)"
AmTsplayer/jsonwrap/JsonWrapper.cpp:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
AmTsplayer/jsonwrap/JsonWrapper.cpp:10:#define LOG_NDEBUG 0
AmTsplayer/jsonwrap/JsonWrapper.cpp:11:#define LOG_TAG "AmJsonWrapper"
AmTsplayer/jsonwrap/JsonWrapper.cpp:22:#include <TspLogger.h>
AmTsplayer/jsonwrap/JsonWrapper.cpp:23:#define JLOGI(number,fmt,...) ALOGI("[No-%d] " fmt, number, ##__VA_ARGS__)
AmTsplayer/jsonwrap/JsonWrapper.cpp:24:#define JLOGV(number,fmt,...) ALOGV("[No-%d] " fmt, number, ##__VA_ARGS__)
AmTsplayer/jsonwrap/JsonWrapper.cpp:25:#define JLOGD(number,fmt,...) ALOGD("[No-%d] " fmt, number, ##__VA_ARGS__)
AmTsplayer/jsonwrap/JsonWrapper.cpp:32:    JLOGI(mJsonInstansNo, "*JsonWrapper():%d", mJsonInstansNo);
AmTsplayer/jsonwrap/JsonWrapper.cpp:38:    JLOGI(mJsonInstansNo, "~JsonWrapper()");
AmTsplayer/jsonwrap/JsonWrapper.cpp:42:    JLOGI(mJsonInstansNo, "Start()");
AmTsplayer/jsonwrap/JsonWrapper.cpp:55:        JLOGI(mJsonInstansNo, "ERROR: Invalid parameters.");
AmTsplayer/jsonwrap/JsonWrapper.cpp:122:        JLOGI(mJsonInstansNo, "Error: JSON too large (%zu >= %zu)", JsonSendSize, JsonBufferSize);
AmTsplayer/jsonwrap/JsonWrapper.h:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
AmTsplayer/render/TsPlayerRender.cpp:17:#define LOG_NDEBUG 0
AmTsplayer/render/TsPlayerRender.cpp:18:#define LOG_TAG "TsRenderer"
AmTsplayer/render/TsPlayerRender.cpp:20:// #include <utils/Log.h>
AmTsplayer/render/TsPlayerRender.cpp:21:#include <TspLogger.h>
AmTsplayer/render/TsPlayerRender.cpp:32:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/render/TsPlayerRender.cpp:33:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/render/TsPlayerRender.cpp:34:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
AmTsplayer/render/TsPlayerRender.cpp:47:    FLOGI(mPlayerInstansNo,"mIsRecoveryMode:%d\n",mIsRecoveryMode);
AmTsplayer/render/TsPlayerRender.cpp:83:        FLOGI(mPlayerInstansNo,"bootplayer use update anchor mode to render\n");
AmTsplayer/render/TsPlayerRender.cpp:91:    mDebugServer->addModuleLogLevel(this, PROPERTY_TSPLAYER_RENDERDEBUG, debuglevel);
AmTsplayer/render/TsPlayerRender.cpp:94:        FLOGI(mPlayerInstansNo,"UpdateAnchorMode\n");
AmTsplayer/render/TsPlayerRender.cpp:96:        FLOGI(mPlayerInstansNo,"QueryPolicyMode");
AmTsplayer/render/TsPlayerRender.cpp:116:        FLOGI(mPlayerInstansNo,"mMultiVideoSyncId:%d \n",mMultiVideoSyncId);
AmTsplayer/render/TsPlayerRender.cpp:126:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/render/TsPlayerRender.cpp:129:        FLOGI(mPlayerInstansNo,"delete mVideoSync in");
AmTsplayer/render/TsPlayerRender.cpp:131:        FLOGI(mPlayerInstansNo,"delete mVideoSync ok");
AmTsplayer/render/TsPlayerRender.cpp:134:        FLOGI(mPlayerInstansNo,"delete mAudioSync in");
AmTsplayer/render/TsPlayerRender.cpp:136:        FLOGI(mPlayerInstansNo,"delete mAudioSync ok");
AmTsplayer/render/TsPlayerRender.cpp:144:    FLOGI(mPlayerInstansNo,"end");
AmTsplayer/render/TsPlayerRender.cpp:164:        FLOGI(mPlayerInstansNo,"scale:%f\n",scale);
AmTsplayer/render/TsPlayerRender.cpp:166:            FLOGI(mPlayerInstansNo,"MEDIA_SYNC_VMASTER\n");
AmTsplayer/render/TsPlayerRender.cpp:174:                FLOGI(mPlayerInstansNo,"MEDIA_SYNC_AMASTER\n");
AmTsplayer/render/TsPlayerRender.cpp:182:                FLOGI(mPlayerInstansNo,"MEDIA_SYNC_VMASTER updateMediaTime\n");
AmTsplayer/render/TsPlayerRender.cpp:185:                FLOGI(mPlayerInstansNo,"MEDIA_SYNC_AMASTER updateMediaTime\n");
AmTsplayer/render/TsPlayerRender.cpp:216:    FLOGI(mPlayerInstansNo,"mVideoSync cBFunc:%p disPlayHandle:%p\n",cBFunc,disPlayHandle);
AmTsplayer/render/TsPlayerRender.cpp:227:    FLOGI(mPlayerInstansNo,"mSyncmode:%d mSyncInsId:%d mAudioStarted:%d,mAudioMute=%d, mIsMutilVideoSync:%d\n",
AmTsplayer/render/TsPlayerRender.cpp:248:            FLOGI(mPlayerInstansNo,
AmTsplayer/render/TsPlayerRender.cpp:256:        FLOGI(mPlayerInstansNo,"SetWorkMode WorkMode:%d \n",mWorkMode);
AmTsplayer/render/TsPlayerRender.cpp:278:                    FLOGI(mPlayerInstansNo,"AudioNoStarted MEDIA_SYNC_PCRMASTER\n");
AmTsplayer/render/TsPlayerRender.cpp:281:                    FLOGI(mPlayerInstansNo,"AudioNoStarted MEDIA_SYNC_VMASTER\n");
AmTsplayer/render/TsPlayerRender.cpp:287:                    FLOGI(mPlayerInstansNo,"AudioStarted MEDIA_SYNC_VMASTER\n");
AmTsplayer/render/TsPlayerRender.cpp:306:    FLOGI(mPlayerInstansNo,"mSyncmode:%d mSyncInsId:%d mVideoStarted:%d mAudioStarted:%d\n",
AmTsplayer/render/TsPlayerRender.cpp:340:            FLOGI(mPlayerInstansNo,"VideoNoStarted MEDIA_SYNC_PCRMASTER\n");
AmTsplayer/render/TsPlayerRender.cpp:343:            FLOGI(mPlayerInstansNo,"VideoNoStarted MEDIA_SYNC_AMASTER\n");
AmTsplayer/render/TsPlayerRender.cpp:355:            FLOGI(mPlayerInstansNo,"VideoStarted MEDIA_SYNC_AMASTER\n");
AmTsplayer/render/TsPlayerRender.cpp:384:    FLOGI(mPlayerInstansNo,"mSyncInsId : %d mVideoStarted:%d \n",mSyncInsId,mVideoStarted);
AmTsplayer/render/TsPlayerRender.cpp:392:                FLOGI(mPlayerInstansNo,"VideoNoStarted MEDIA_SYNC_PCRMASTER\n");
AmTsplayer/render/TsPlayerRender.cpp:395:                FLOGI(mPlayerInstansNo,"VideoNoStarted MEDIA_SYNC_AMASTER\n");
AmTsplayer/render/TsPlayerRender.cpp:407:                FLOGI(mPlayerInstansNo,"VideoStarted MEDIA_SYNC_AMASTER\n");
AmTsplayer/render/TsPlayerRender.cpp:419:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/render/TsPlayerRender.cpp:438:            FLOGI(mPlayerInstansNo,"delete mVideoSync in");
AmTsplayer/render/TsPlayerRender.cpp:440:            FLOGI(mPlayerInstansNo,"delete mVideoSync ok");
AmTsplayer/render/TsPlayerRender.cpp:467:    FLOGI(mPlayerInstansNo,"ok");
AmTsplayer/render/TsPlayerRender.cpp:472:    FLOGI(mPlayerInstansNo,"");
AmTsplayer/render/TsPlayerRender.cpp:484:        FLOGI(mPlayerInstansNo,"flushQueue\n");
AmTsplayer/render/TsPlayerRender.cpp:494:    FLOGI(mPlayerInstansNo,"in");
AmTsplayer/render/TsPlayerRender.cpp:503:                FLOGI(mPlayerInstansNo,"delete mVideoSync in");
AmTsplayer/render/TsPlayerRender.cpp:505:                FLOGI(mPlayerInstansNo,"delete mVideoSync ok");
AmTsplayer/render/TsPlayerRender.cpp:514:    FLOGI(mPlayerInstansNo,"out");
AmTsplayer/render/TsPlayerRender.cpp:524:            FLOGI(mPlayerInstansNo,"GetAudioPatchAudioCache error \n");
AmTsplayer/render/TsPlayerRender.cpp:555:        //FLOGI(mPlayerInstansNo,"getFirstAudioFrameInfo :%lld \n",audioinfo.framePts);
AmTsplayer/render/TsPlayerRender.cpp:566:            FLOGI(mPlayerInstansNo,"getCurAudioFrameInfo error \n");
AmTsplayer/render/TsPlayerRender.cpp:571:        //FLOGI(mPlayerInstansNo,"getCurAudioFrameInfo :%lld \n",audioinfo.framePts);
AmTsplayer/render/TsPlayerRender.cpp:582:            FLOGI(mPlayerInstansNo,"getQueueAudioInfo error \n");
AmTsplayer/render/TsPlayerRender.cpp:597:            FLOGI(mPlayerInstansNo,"GetAudioPatchAudioCache error \n");
AmTsplayer/render/TsPlayerRender.cpp:602:        //FLOGI(mPlayerInstansNo,"getCurAudioFrameInfo :%lld \n",audioinfo.framePts);
AmTsplayer/render/TsPlayerRender.cpp:610:    FLOGI(mPlayerInstansNo,"mWorkMode:%d mLastWorkMode:%d in\n",mWorkMode,mLastWorkMode);
AmTsplayer/render/TsPlayerRender.cpp:623:            FLOGI(mPlayerInstansNo,"mVideoQueue.size:%d\n",(int)mVideoQueue.size());
AmTsplayer/render/TsPlayerRender.cpp:633:    FLOGI(mPlayerInstansNo,"mWorkMode:%d mLastWorkMode:%d out\n",mWorkMode,mLastWorkMode);
AmTsplayer/render/TsPlayerRender.cpp:641:        FLOGI(mPlayerInstansNo,"set freerun ,mVideoStarted:%d mAudioStarted:%d mSyncmode:%d \n",
AmTsplayer/render/TsPlayerRender.cpp:657:    FLOGI(mPlayerInstansNo,"mVideoStarted:%d mAudioStarted:%d mSyncmode:%d \n",
AmTsplayer/render/TsPlayerRender.cpp:672:    FLOGI(mPlayerInstansNo,"vtrickMode:%d\n",vtrickMode);
AmTsplayer/render/TsPlayerRender.cpp:680:        FLOGI(mPlayerInstansNo,"cacheSize:%d\n",cacheSize);
AmTsplayer/render/TsPlayerRender.cpp:689:        FLOGI(mPlayerInstansNo,"strategy:%d\n",mMediaSyncStartStrategy);
AmTsplayer/render/TsPlayerRender.cpp:696:    FLOGI(mPlayerInstansNo,"SetAudioMute:%d\n", mAudioMute);
AmTsplayer/render/TsPlayerRender.cpp:701:    FLOGI(mPlayerInstansNo,"mDemuxId:%d mPcrPid:%d\n", mDemuxId, mPcrPid);
AmTsplayer/render/TsPlayerRender.cpp:708:    FLOGI(mPlayerInstansNo,"mResumePlayingPts:%lld\n", (long long)mResumePlayingPts);
AmTsplayer/render/TsPlayerRender.cpp:714:    FLOGI(mPlayerInstansNo,"frmRate:%d\n", frmRate);
AmTsplayer/render/TsPlayerRender.cpp:764:        //ALOGI("updateMediaTime is audio\n");
AmTsplayer/render/TsPlayerRender.cpp:766:            //ALOGE("updateMediaTime is not null\n");
AmTsplayer/render/TsPlayerRender.cpp:778:        FLOGE(mPlayerInstansNo,"finalResult != 0 err");
AmTsplayer/render/TsPlayerRender.cpp:809:            //FLOGI(mPlayerInstansNo,"1--->FirstPostDrainVideoQueue\n");
AmTsplayer/render/TsPlayerRender.cpp:814:            FLOGI(mPlayerInstansNo,"--->FirstPostDrainVideoQueue\n");
AmTsplayer/render/TsPlayerRender.cpp:822://        ALOGE("postDrainAudioQueue mAudioQueue empty return\n");
AmTsplayer/render/TsPlayerRender.cpp:827: //   ALOGE("postDrainAudioQueue mAudioQueue\n");
AmTsplayer/render/TsPlayerRender.cpp:833:        //ALOGE("postDrainVideoQueue output video mVideoQueue empty return\n");
AmTsplayer/render/TsPlayerRender.cpp:845://    ALOGE("postDrainVideoQueue mVideoQueue\n");
AmTsplayer/render/TsPlayerRender.cpp:853:        //ALOGW("entry->index is null onDrainVideoQueue output return\n");
AmTsplayer/render/TsPlayerRender.cpp:860:        FLOGI(mPlayerInstansNo,"audio had not set update anchor");
AmTsplayer/render/TsPlayerRender.cpp:866:            FLOGI(mPlayerInstansNo,"audio had not set update anchor timeout");
AmTsplayer/render/TsPlayerRender.cpp:878:        FLOGI(mPlayerInstansNo,"mediaTimeUs %" PRId64 "(%" PRId64 ") mLastDrainVideoMediaTimeUs %" PRId64 "\tskip back, add avg delta %" PRId64 "\n",
AmTsplayer/render/TsPlayerRender.cpp:889:        FLOGI(mPlayerInstansNo,"realTimeUs:%" PRId64 " nowUs + kDiscontinueThresholdUs=%" PRId64 "\n",
AmTsplayer/render/TsPlayerRender.cpp:914:                FLOGE(mPlayerInstansNo,"MEDIA_SYNC_AMASTER--->mDropVideoCount:%d\n",mDropVideoCount);
AmTsplayer/render/TsPlayerRender.cpp:927:            FLOGE(mPlayerInstansNo,"--->render_drop_frame mDropVideoCount:%d\n",mDropVideoCount);
AmTsplayer/render/TsPlayerRender.cpp:933:                FLOGE(mPlayerInstansNo,"MEDIA_SYNC_AMASTER--->render_drop_frame mDropVideoCount:%d\n",mDropVideoCount);
AmTsplayer/render/TsPlayerRender.cpp:941:    FLOGI(mPlayerInstansNo,"%s, mediaTimeUs:%" PRId64 "(%" PRId64 ") realTimeUs:%" PRId64 "(%" PRId64 ") nowUs:%" PRId64 "(%" PRId64 ")  delaytimeUs:%" PRId64 "\n",
AmTsplayer/render/TsPlayerRender.cpp:981:        //ALOGW("entry->index is null onDrainVideoQueue output return\n");
AmTsplayer/render/TsPlayerRender.cpp:1003:            //FLOGI(mPlayerInstansNo,"onDrainTunnelVideoQueue MEDIASYNC_VIDEO_HOLD mediaTimeUs:%lld \n",mediaTimeUs);
AmTsplayer/render/TsPlayerRender.cpp:1017:                    FLOGI(mPlayerInstansNo,"MEDIASYNC_VIDEO_HOLD mVideoHoldCount:%d mediaTimeUs:%" PRId64 " \n",mVideoHoldCount,mediaTimeUs);
AmTsplayer/render/TsPlayerRender.cpp:1022:            //ALOGI("onDrainTunnelVideoQueue MEDIASYNC_VIDEO_DROP\n");
AmTsplayer/render/TsPlayerRender.cpp:1028:            FLOGI(mPlayerInstansNo,"MEDIASYNC_VIDEO_EXIT return\n");
AmTsplayer/render/TsPlayerRender.cpp:1045:    debuglevel = mDebugServer->getModuleLogLevel(this);
AmTsplayer/render/TsPlayerRender.cpp:1047:        FLOGI(mPlayerInstansNo,"(%s) ptsUs:%" PRId64 "(%" PRId64 ") timestampNs:%" PRId64 " us realdiff:%" PRId64 " (%" PRId64 ") NowTDiff:%" PRId64 " us queueSize:%d\n",
AmTsplayer/render/TsPlayerRender.cpp:1063:            FLOGI(mPlayerInstansNo,"%s (%s) ptsUs:%" PRId64 "(%" PRId64 ") realdiff:%" PRId64 " (%" PRId64 ") NowTDiff:%" PRId64 " us queueSize:%d\n",
AmTsplayer/render/TsPlayerRender.cpp:1076:        FLOGI(mPlayerInstansNo,"it droped %d frames per 1000 frames!", mDropVideoCount);
AmTsplayer/render/TsPlayerRender.cpp:1108:        //ALOGW("mVideoQueue video is empty onDrainVideoQueue return\n");
AmTsplayer/render/TsPlayerRender.cpp:1127:            FLOGI(mPlayerInstansNo,"-----> init mDrainVideoNumber:%" PRId64 " AudioPtsUs:%" PRId64 " mLastDrainVideoPtsUs:%" PRId64 " AvCurDisplayDiff:%" PRId64 "\n",
AmTsplayer/render/TsPlayerRender.cpp:1135:            //ALOGI("----->onDrainAudioQueue wait !\n");
AmTsplayer/render/TsPlayerRender.cpp:1145:                FLOGI(mPlayerInstansNo,"-----> done mDrainVideoNumber:%" PRId64 " AudioPtsUs:%" PRId64 " mLastDrainVideoPtsUs:%" PRId64 " AvCurDisplayDiff:%" PRId64 "\n",
AmTsplayer/render/TsPlayerRender.cpp:1168:        FLOGI(mPlayerInstansNo,"firstVideoPtsUs:%" PRId64 " firstAudioPtsUs:%" PRId64 " diff:%" PRId64 " us",
AmTsplayer/render/TsPlayerRender.cpp:1186:        //ALOGE("mAudioQueue is empty onDrainAudioQueue return\n");
AmTsplayer/render/TsPlayerRender.cpp:1190:   // ALOGE("kWhatDrainAudioQueuequeuesize:%d\n", mAudioQueue.size());
AmTsplayer/render/TsPlayerRender.cpp:1205:                        FLOGI(mPlayerInstansNo,"audio waits video timeout");
AmTsplayer/render/TsPlayerRender.cpp:1236:        //ALOGE("kWhatQueueBuffer pictureId\n");
AmTsplayer/render/TsPlayerRender.cpp:1238:        //ALOGE("kWhatQueueBuffer pictureId return\n");
AmTsplayer/render/TsPlayerRender.cpp:1251:                FLOGI(mPlayerInstansNo,"kWhatDrainVideoQueue isVideoMediaSyncExit");
AmTsplayer/render/TsPlayerRender.cpp:1260:   //     ALOGE("kWhatDrainAudioQueue pictureId\n");
AmTsplayer/render/TsPlayerRender.cpp:1265:   //     ALOGE("kWhatDrainAudioQueue pictureId return delayUs\n");
AmTsplayer/render/TsPlayerRender.cpp:1297:        FLOGE(mPlayerInstansNo,"msg->findInt32 audio err");
AmTsplayer/render/TsPlayerRender.cpp:1300:        FLOGE(mPlayerInstansNo,"msg->findInt32 TimestampUs err");
AmTsplayer/render/TsPlayerRender.cpp:1303:        FLOGE(mPlayerInstansNo,"msg->findMessage notifyConsumed err");
AmTsplayer/render/TsPlayerRender.cpp:1306:        FLOGE(mPlayerInstansNo,"msg->findInt32 index err");
AmTsplayer/render/TsPlayerRender.cpp:1322:        //ALOGE("onQueueBuffer audio queue output %lld\n", TimestampUs);
AmTsplayer/render/TsPlayerRender.cpp:1326:            FLOGE(mPlayerInstansNo,"mAudioStarted == false audio drop TimestampUs %" PRId64 "\n", TimestampUs);
AmTsplayer/render/TsPlayerRender.cpp:1335:        //ALOGI("onQueueBuffer video queue output %lld pictureId:%d\n",TimestampUs, index);
AmTsplayer/render/TsPlayerRender.cpp:1339:        FLOGI(mPlayerInstansNo,"vtrickMode == AV_VIDEO_TRICK_MODE_PAUSE_NEXT mFirstPostDrainVideoQueue:%d\n",mFirstPostDrainVideoQueue);
AmTsplayer/render/TsPlayerRender.cpp:1355:            FLOGI(mPlayerInstansNo,"[mediahal_kpi] firstVideoPtsUs:%" PRId64 " us\n",firstVideoEntry->TimestampUs);
AmTsplayer/render/TsPlayerRender.cpp:1372:        FLOGE(mPlayerInstansNo,"msg->findInt32 audio err");
AmTsplayer/render/TsPlayerRender.cpp:1381:        FLOGE(mPlayerInstansNo,"msg->findInt32 finalResult err");
AmTsplayer/render/TsPlayerRender.cpp:1416:    FLOGI(mPlayerInstansNo,"in mPaused:%d\n",mPaused);
AmTsplayer/render/TsPlayerRender.cpp:1430:    FLOGI(mPlayerInstansNo,"ok \n");
AmTsplayer/render/TsPlayerRender.cpp:1434:    FLOGI(mPlayerInstansNo,"in mPaused:%d\n",mPaused);
AmTsplayer/render/TsPlayerRender.cpp:1448:    FLOGI(mPlayerInstansNo,"ok\n");
AmTsplayer/render/TsPlayerRender.cpp:1465:        FLOGI(mPlayerInstansNo,"input parameter was NULL, SetTraceInfo failed! \n");
AmTsplayer/render/TsPlayerRender.cpp:1476:    FLOGI(mPlayerInstansNo,"mMultiVideoSyncId:%d \n",mMultiVideoSyncId);
AmTsplayer/render/TsPlayerRender.cpp:1491:        //FLOGI(mPlayerInstansNo,"getFirstQueueVideoPts :%lld \n",info.framePts);
AmTsplayer/render/TsPlayerRender.cpp:1508:        //FLOGI(mPlayerInstansNo,"getQueueVideoPts :%lld \n",info.framePts);
AmTsplayer/render/TsPlayerRender.cpp:1523:        FLOGE(mPlayerInstansNo,"pfunc:%s handle:%s ",
AmTsplayer/render/TsPlayerRender.cpp:1527:    FLOGI(mPlayerInstansNo,"pFunc:%p mVdecWrapperHandle:%p\n",pfunc,handle);
AmTsplayer/render/TsPlayerRender.cpp:1535:        FLOGE(mPlayerInstansNo,"pfunc:%s Handle:%s ",
AmTsplayer/render/TsPlayerRender.cpp:1539:    FLOGI(mPlayerInstansNo,"pFunc:%p disPlayHandle:%p\n",pfunc,Handle);
AmTsplayer/render/TsPlayerRender.cpp:1548:        FLOGI(mPlayerInstansNo,"setOutputFirstFrameBeforeAvSyncStage ok \n");
AmTsplayer/render/TsPlayerRender.cpp:1553:    FLOGI(mPlayerInstansNo,"dropVideoCount:%d, drainVideoNumber:%" PRId64 ", holdCount:%d, cacheSize:%d \n",
AmTsplayer/render/TsPlayerRender.cpp:1580:    FLOGI(mPlayerInstansNo,"mMediaSyncVfmDevId:%d \n",mMediaSyncVfmDevId);
AmTsplayer/stbtrace.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/TsPlayer.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
AmTsplayer/TsPlayer.h:93:    uint8_t analog_mute;
AmTsplayer/TsPlayer.h:281:    int32_t SetAudioMute(bool_t analog_mute,
AmTsplayer/TsPlayer.h:283:    int32_t GetAudioMute(bool_t *analog_mute,
AmTsplayer/TsPlayer.h:614:                    ALOGV("Unregistering stale handler %d", mPlayers.keyAt(i));
Logger/TspLogger.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
Logger/TspLogger.h:10:#ifndef __TSPLOGGER_H__
Logger/TspLogger.h:11:#define __TSPLOGGER_H__
Logger/TspLogger.h:13:#ifndef LOG_TAG
Logger/TspLogger.h:14:#define LOG_TAG "mediahal"
Logger/TspLogger.h:17:#include <utils/Log.h>
Logger/TspLogger.h:26://same to logcat -v time
Logger/TspLogger.h:43:#define TSPLOG_LEVEL_NONE    0
Logger/TspLogger.h:44:#define TSPLOG_LEVEL_VERBOSE 1
Logger/TspLogger.h:45:#define TSPLOG_LEVEL_DEBUG   2
Logger/TspLogger.h:46:#define TSPLOG_LEVEL_INFO    3
Logger/TspLogger.h:47:#define TSPLOG_LEVEL_WANNING 4
Logger/TspLogger.h:48:#define TSPLOG_LEVEL_ERROR   5
Logger/TspLogger.h:50:#define LOG_LEVEL TSPLOG_LEVEL_VERBOSE
Logger/TspLogger.h:51:#ifdef ALOGE
Logger/TspLogger.h:52:#undef ALOGE
Logger/TspLogger.h:54:#ifdef ALOGW
Logger/TspLogger.h:55:#undef ALOGW
Logger/TspLogger.h:57:#ifdef ALOGI
Logger/TspLogger.h:58:#undef ALOGI
Logger/TspLogger.h:60:#ifdef ALOGD
Logger/TspLogger.h:61:#undef ALOGD
Logger/TspLogger.h:63:#ifdef ALOGV
Logger/TspLogger.h:64:#undef ALOGV
Logger/TspLogger.h:67:#define ALOGE(fmt, ...) \
Logger/TspLogger.h:68:    if (LOG_LEVEL <= TSPLOG_LEVEL_ERROR) { \
Logger/TspLogger.h:71:        fprintf(stderr, "%s E/%s(%d): " fmt "\n", ts, LOG_TAG, __LINE__, ##__VA_ARGS__); \
Logger/TspLogger.h:74:#define ALOGW(fmt, ...) \
Logger/TspLogger.h:75:    if (LOG_LEVEL <= TSPLOG_LEVEL_INFO) { \
Logger/TspLogger.h:78:        fprintf(stderr, "%s W/%s(%d): " fmt "\n", ts, LOG_TAG, __LINE__, ##__VA_ARGS__); \
Logger/TspLogger.h:81:#define ALOGI(fmt, ...) \
Logger/TspLogger.h:82:    if (LOG_LEVEL <= TSPLOG_LEVEL_INFO) { \
Logger/TspLogger.h:85:        fprintf(stderr, "%s I/%s(%d): " fmt "\n", ts, LOG_TAG, __LINE__, ##__VA_ARGS__); \
Logger/TspLogger.h:88:#define ALOGD(fmt, ...) \
Logger/TspLogger.h:89:    if (LOG_LEVEL <= TSPLOG_LEVEL_DEBUG) { \
Logger/TspLogger.h:92:        fprintf(stderr, "%s D/%s(%d): " fmt "\n", ts, LOG_TAG, __LINE__, ##__VA_ARGS__); \
Logger/TspLogger.h:95:#define ALOGV(fmt, ...) \
Logger/TspLogger.h:96:    if (LOG_LEVEL <= TSPLOG_LEVEL_VERBOSE) { \
Logger/TspLogger.h:99:        fprintf(stderr, "%s V/%s(%d): " fmt "\n", ts, LOG_TAG, __LINE__, ##__VA_ARGS__); \
Logger/TspLogger.h:104:#endif /*__TOOLS_LOGGER_H__*/
Logger/Android.bp:18:    default_applicable_licenses: ["vendor_amlogic_mediahal_tsplogger_license"],
Logger/Android.bp:23:    name: "libmediahal_tsplogger_headers",
resmanage/platform.h:4: * Copyright (C) 2020 Amlogic, Inc. All rights reserved.
resmanage/platform.h:12:#define  LOG_TAG    "resman"
resmanage/platform.h:13:#include <log/log.h>
resmanage/platform.h:16:#define ALOGE(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)
resmanage/platform.h:17:#define ALOGI(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)
resmanage/platform.h:18:#define ALOGD(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)
resmanage/amjson.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
resmanage/amresmanage.c:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
resmanage/amresmanage.c:48:        ALOGE("%s res name error", __FUNCTION__);
resmanage/amresmanage.c:68:            ALOGE("%s error, ret=%d errno=%d", __FUNCTION__, r, errno);
resmanage/amresmanage.c:84:        ALOGD("Don't Support Resource Manage!");
resmanage/amresmanage.c:110:    ALOGI("%s at #%d fd %d\n",__func__,__LINE__,fd);
resmanage/amresmanage.c:147:        ALOGD("release all resource, fd = %d", handle);
resmanage/amresmanage.c:164:            ALOGE("%s error, ret=%d errno=%d", __FUNCTION__, r, errno);
resmanage/amresmanage.c:188:            ALOGD("acquire resid %d always return success", restype);
resmanage/amresmanage.c:200:        ALOGI("acquire fd:%d, resid:%d, preempt:%d, time_out:%d, arg:%s",
resmanage/amresmanage.c:207:            ALOGE("%s error, ret=%d errno=%d", __FUNCTION__, r, errno);
resmanage/amresmanage.c:211:        ALOGE("invalid handle");
resmanage/amresmanage.c:233:        ALOGE("waring resource name need more than 4 character\n");
resmanage/amresmanage.c:252:        ALOGD("release resid:%d, fd:%d", restype, handle);
resmanage/amresmanage.c:256:            ALOGE("%s error, ret=%d errno=%d", __FUNCTION__, r, errno);
resmanage/amresmanage.c:269:        ALOGD("release all, fd:%d", handle);
resmanage/amresmanage.c:273:            ALOGE("%s error, ret=%d errno=%d", __FUNCTION__, r, errno);
resmanage/amresmanage.c:291:        ALOGE("waring resource name need more than 4 character\n");
resmanage/amresmanage.c:301:        ALOGD("release resid:%d, fd:%d name %s\n", resid, handle,resname);
resmanage/amresmanage.c:305:            ALOGE("%s error, ret=%d errno=%d", __FUNCTION__, r, errno);
resmanage/amresmanage.c:323:            ALOGE("%s ret=%d no=%d", __FUNCTION__, r, errno);
resmanage/amresmanage.c:343:        ALOGE("waring resource name need more than 4 character\n");
resmanage/amresmanage.c:358:            ALOGE("%s ret=%d no=%d", __FUNCTION__, r, errno);
resmanage/amresmanage.c:440:    ALOGD("%s handle = %d,info=%s", __FUNCTION__, handle, info);
resmanage/amresmanage.c:447:        ALOGE("%s no=%d", __FUNCTION__,errno);
resmanage/resourcemanage.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
resmanage/Android.bp:28:    //    "system/core/liblog/include",
resmanage/Android.bp:32:        "liblog",
resmanage/Android.bp:54:    //    "system/core/liblog/include",
resmanage/Android.bp:58:       "liblog",
resmanage/Android.bp:81:    //    "system/core/liblog/include",
resmanage/Android.bp:85:        "liblog",
resmanage/amjson.c:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
resmanage/amresevent.c:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
resmanage/amresevent.c:105:            ALOGI("fd %d preempted", fdset[i].fd);
resmanage/amresevent.c:174:    ALOGI("%s at %d\n",__func__,__LINE__);
resmanage/amresevent.c:176:    ALOGI("start resman event thread");
resmanage/amresevent.c:185:                    ALOGE("error %d %x", fdset[i].fd, fdset[i].revents );
resmanage/amresevent.c:194:            ALOGE("poll no=%d", errno);
resmanage/amresevent.c:209:    ALOGI("resman event thread quit");
resmanage/amresevent.c:218:    ALOGI("resman_start_thread start");
resmanage/amresevent.c:235:    ALOGI("resman_start_thread end");
resmanage/amresevent.c:372:    ALOGI("stop resman event thread");
LICENSE:1:// Copyright (C) 2020 Amlogic, Inc. All rights reserved.
LICENSE:3:// All information contained herein is Amlogic confidential.
LICENSE:6:// Agreement (SLA) with Amlogic Inc ("Amlogic"). This software may be
LICENSE:11:// from Amlogic.
mediasync/MediaSync.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
mediasync/MediaSync.cpp:10:#define LOG_NDEBUG 0
mediasync/MediaSync.cpp:11:#define LOG_TAG "AmMediaSync"
mediasync/MediaSync.cpp:24:#include <utils/Log.h>
mediasync/MediaSync.cpp:27:#include <TspLogger.h>
mediasync/MediaSync.cpp:35:int gLogFatHead = 0;
mediasync/MediaSync.cpp:36:#define MS_LOGE(head,fmt,...)\
mediasync/MediaSync.cpp:38:    ALOGE("%s(%s:%d) " fmt, head, __FUNCTION__, __LINE__, ##__VA_ARGS__);\
mediasync/MediaSync.cpp:42:#define MS_LOGV(level,head,fmt,...) \
mediasync/MediaSync.cpp:45:        ALOGV("%s(%s:%d) " fmt, head, __FUNCTION__, __LINE__, ##__VA_ARGS__);\
mediasync/MediaSync.cpp:49:#define MS_LOGI(level,head,fmt,...) \
mediasync/MediaSync.cpp:52:        ALOGI("%s(%s:%d) " fmt, head, __FUNCTION__, __LINE__, ##__VA_ARGS__);\
mediasync/MediaSync.cpp:317:        ALOGE("mediasync_open [%s] failed,ret=%d error=%d(%s) used_times=%d*10(ms)\n",
mediasync/MediaSync.cpp:327:static int32_t mediasync_ioctl(char*log_head,
mediasync/MediaSync.cpp:333:        MS_LOGE(log_head,"mediasync_ioctl(%d) cmd %s invalid SyncDevId %d\n",
mediasync/MediaSync.cpp:339:        MS_LOGE(log_head,"mediasync_ioctl(%d) cmd %s ret:%d %d(%s)\n",
mediasync/MediaSync.cpp:378:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:382:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "(slowsyncSpeed,slowsyncThreshold): start:(%f, %d), during:(%f, %d)",
mediasync/MediaSync.cpp:398:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"~Mediasync destroyed in.");
mediasync/MediaSync.cpp:439:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"~MediaSync close dev\n");
mediasync/MediaSync.cpp:449:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"~Mediasync destroyed ok");
mediasync/MediaSync.cpp:498:    mLogPrintInterval = 1000;
mediasync/MediaSync.cpp:499:    mStateStartLogTime = -1;
mediasync/MediaSync.cpp:500:    mAudioQueueLogTime = -1;
mediasync/MediaSync.cpp:501:    mAudioInfoLogTime = -1;
mediasync/MediaSync.cpp:502:    mAudioPolicyLogTime = -1;
mediasync/MediaSync.cpp:503:    mAudioFreerunLogTime = -1;
mediasync/MediaSync.cpp:504:    mVideoQueueLogTime = -1;
mediasync/MediaSync.cpp:505:    mVideoInfoLogTime = -1;
mediasync/MediaSync.cpp:506:    mVideoPolicyLogTime = -1;
mediasync/MediaSync.cpp:507:    mVideoFreerunLogTime = -1;
mediasync/MediaSync.cpp:508:    mMediaListLogTime = -1;
mediasync/MediaSync.cpp:540:    updateLogHead();
mediasync/MediaSync.cpp:590:    propGetInt(PROPERTY_DEBUG_LOGT_FAT, &gLogFatHead, "0");
mediasync/MediaSync.cpp:690:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"adjustPcrslopeByVcache:%d,vcacheBaseTime:%d s",mAdjustPcrByVcacheWhenNormalPlaybackRate,tmp);
mediasync/MediaSync.cpp:723:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"pcr slope threshold for resample:[%f , %f]",mSlopeDownThresholdForResample,mSlopeUpThresholdForResample);
mediasync/MediaSync.cpp:740:void MediaSync::updateLogHead(int optional) {
mediasync/MediaSync.cpp:744:    if (gLogFatHead) {
mediasync/MediaSync.cpp:745:        memset(mLogHead,0,LOG_HEAD_LENGTH);
mediasync/MediaSync.cpp:746:        snprintf(mLogHead,LOG_HEAD_LENGTH,"(%p)[%s_%d][No-%d]%s/%04d/%04d/%04d",this,streamType2Str(mStreamtype),mSyncInsId,mPlayerInstanceNo,\
mediasync/MediaSync.cpp:748:        mVideoClock.setLogHead(mLogHead);
mediasync/MediaSync.cpp:749:        mAudioClock.setLogHead(mLogHead);
mediasync/MediaSync.cpp:750:        mPCRClock.setLogHead(mLogHead);
mediasync/MediaSync.cpp:751:        mRefClock.setLogHead(mLogHead);
mediasync/MediaSync.cpp:754:            memset(mLogHead,0,LOG_HEAD_LENGTH);
mediasync/MediaSync.cpp:755:            snprintf(mLogHead,LOG_HEAD_LENGTH,"(%p)[%s_%d][No-%d]",this,streamType2Str(mStreamtype),mSyncInsId,mPlayerInstanceNo);
mediasync/MediaSync.cpp:756:            mVideoClock.setLogHead(mLogHead);
mediasync/MediaSync.cpp:757:            mAudioClock.setLogHead(mLogHead);
mediasync/MediaSync.cpp:758:            mPCRClock.setLogHead(mLogHead);
mediasync/MediaSync.cpp:759:            mRefClock.setLogHead(mLogHead);
mediasync/MediaSync.cpp:785:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"allocInstance demuxid:%d pcrpid:0x%x\n",DemuxId, PcrPid);
mediasync/MediaSync.cpp:790:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:796:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:808:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"allocInstance InsId:%d\n",InsId);
mediasync/MediaSync.cpp:810:    mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:813:    updateLogHead();
mediasync/MediaSync.cpp:817:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:835:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"SyncInsId:%d mStreamtype:%s, mSyncInsId:%d, mOmxTunnelMode:%d.\n",syncID,
mediasync/MediaSync.cpp:840:            int ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:844:                MS_LOGE(mLogHead,"binder err ret:%d\n",ret);
mediasync/MediaSync.cpp:849:            MS_LOGE(mLogHead,"invalid SyncInsId:%d\n",syncID);
mediasync/MediaSync.cpp:856:    updateLogHead();
mediasync/MediaSync.cpp:876:                int ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:880:                    MS_LOGE(mLogHead,"set vf erro:%d\n",ret);
mediasync/MediaSync.cpp:890:        MS_LOGI(MSYNC_DEBUG_LEVEL_0, mLogHead,"[AUT_PRINT] bindinstance SyncInsId:%d success.\n",syncID);
mediasync/MediaSync.cpp:899:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Dynamic ID is not supported for non audio and video types.\n");
mediasync/MediaSync.cpp:903:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"SyncInsId:%d mStreamtype:%s, mSyncInsId:%d, mOmxTunnelMode:%d.\n",syncID,
mediasync/MediaSync.cpp:909:        int ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:913:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"binder err ret:%d\n",ret);
mediasync/MediaSync.cpp:923:    updateLogHead();
mediasync/MediaSync.cpp:941:                int ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:945:                    MS_LOGE(mLogHead,"set vf erro:%d\n",ret);
mediasync/MediaSync.cpp:955:    int ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:967:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Player id:%d\n",number);
mediasync/MediaSync.cpp:973:    updateLogHead();
mediasync/MediaSync.cpp:979:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"setSyncMode mode:%d\n",mode);
mediasync/MediaSync.cpp:983:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:987:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"setSyncMode error:%s\n",strerror(errno));
mediasync/MediaSync.cpp:998:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1026:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"do not pause in DEMOD mode pause value:%d\n", pause);
mediasync/MediaSync.cpp:1048:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"need_pause:%d\n",need_pause);
mediasync/MediaSync.cpp:1049:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1068:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1092:        ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1104:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1119:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1133:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1145:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1158:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1173:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1187:        ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1199:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1214:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1229:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1241:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1252:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"set starttime:%" PRId64 "\n",startingTimeMediaUs);
mediasync/MediaSync.cpp:1257:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1261:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"error:%s\n",strerror(errno));
mediasync/MediaSync.cpp:1271:    mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1299:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1303:        //ALOGI("updateAnchor GET_SYNCMODE error:%s! mStreamtype:%d \n",strerror(errno),mStreamtype);
mediasync/MediaSync.cpp:1307:    //ALOGI("updateAnchor (%s) syncmode:%d media:%" PRId64 " real:%" PRId64 " max:%" PRId64 "\n",
mediasync/MediaSync.cpp:1312:    //ALOGE("updateAnchor get syncmode:%d\n", syncmode);
mediasync/MediaSync.cpp:1315:       ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1319:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "updateAnchor(%p) update mediatime video:%" PRId64 "\n",this,updatetime.mMediaTimeUs);
mediasync/MediaSync.cpp:1324:       ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1328:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "updateAnchor(%p) update mediatime audio:%" PRId64 "\n",this,updatetime.mMediaTimeUs);
mediasync/MediaSync.cpp:1331:            mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1338:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "setrate:%.4f, realrate:%.4f", mPlaybackRate, realrate);
mediasync/MediaSync.cpp:1341:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "apts-systime-diff=%lld, systimediff:%lld(%lld,%lld), mediatimediff:%lld(%lld,%lld), rate:%.2f",
mediasync/MediaSync.cpp:1348:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "overthreshold %lld(rate:%.2f) systimediff:%lld(%lld,%lld), mediatimediff:%lld(%lld,%lld)",
mediasync/MediaSync.cpp:1355:        ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1360:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "updateAnchor(%p) update mediatime forceUpdate:%" PRId64 "\n",this,updatetime.mMediaTimeUs);
mediasync/MediaSync.cpp:1364:        MS_LOGE(mLogHead,"updateAnchor update mediatime error!\n");
mediasync/MediaSync.cpp:1385:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1406:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"updateSpeedAnchor speed rate from %.2f to %.2f", mPlaybackRate, rate);
mediasync/MediaSync.cpp:1419:        ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1424:        //MS_LOGV(MSYNC_DEBUG_LEVEL_0,mLogHead,"updateSpeedAnchor update mediatime error!\n");
mediasync/MediaSync.cpp:1427:            ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1431:                MS_LOGE(mLogHead,"updateSpeedAnchor set speed error!\n");
mediasync/MediaSync.cpp:1438:        ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1446:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "updateAnchor(%p) update mediatime video:%" PRId64 "\n",this,updatetime.mMediaTimeUs);
mediasync/MediaSync.cpp:1452:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "updateAnchor(%p) update mediatime audio:%" PRId64 "\n",this,updatetime.mMediaTimeUs);
mediasync/MediaSync.cpp:1455:            mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1462:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "setrate:%.4f, realrate:%.4f", mPlaybackRate, realrate);
mediasync/MediaSync.cpp:1465:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "apts-systime-diff=%lld, systimediff:%lld(%lld,%lld), mediatimediff:%lld(%lld,%lld), rate:%.2f",
mediasync/MediaSync.cpp:1471:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "overthreshold %lld(rate:%.2f) systimediff:%lld(%lld,%lld), mediatimediff:%lld(%lld,%lld)",
mediasync/MediaSync.cpp:1479:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "updateAnchor(%p) update mediatime forceUpdate:%" PRId64 "\n",this,updatetime.mMediaTimeUs);
mediasync/MediaSync.cpp:1484:        MS_LOGE(mLogHead,"updateSpeedAnchor update mediatime error!\n");
mediasync/MediaSync.cpp:1500:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"audiotrack set rewind playback\n");
mediasync/MediaSync.cpp:1521:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"framePts: %" PRIx64 ", system: %" PRIx64 ".",
mediasync/MediaSync.cpp:1526:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"playbackrate:%f.\n", rate);
mediasync/MediaSync.cpp:1527:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1563:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1582:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"slope:%f from %s_%d.\n", slope,from,line);
mediasync/MediaSync.cpp:1587:        ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1602:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1625:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"getMediaTime allow past maxtime\n");
mediasync/MediaSync.cpp:1631:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1637:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1645:       // ALOGI("getMediaTime mediatime:%" PRId64 " realUs:%" PRId64 " systime:%" PRId64 "\n", mediatime,
mediasync/MediaSync.cpp:1655:       // ALOGI("getMediaTime mediatime:%" PRId64 " realUs:%" PRId64 " systime:%" PRId64 "\n", mediatime,
mediasync/MediaSync.cpp:1681:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1687:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1694:    MS_LOGI(MSYNC_DEBUG_LEVEL_OTHER,mLogHead,"time.mStcUs:%" PRId64 " time.mSystemTimeUs:%" PRId64 "",
mediasync/MediaSync.cpp:1696:    MS_LOGI(MSYNC_DEBUG_LEVEL_OTHER,mLogHead,"arthortime.mStcTimeUs:%" PRId64 " arthortime.mSystemTimeUs:%" PRId64 ", arthortime.mMediaTimeUs:%" PRId64 "",
mediasync/MediaSync.cpp:1708:        MS_LOGI(MSYNC_DEBUG_LEVEL_VIDEO_QUEUE, mLogHead, "mPlaybackRate change from %f to %f", lastPlaybackRate, mPlaybackRate);
mediasync/MediaSync.cpp:1719:        MS_LOGI(MSYNC_DEBUG_LEVEL_VIDEO_PROC, mLogHead, "targetMediaUs: %" PRId64 " outRealUs: %" PRId64 "(rate: %.4f)\n",
mediasync/MediaSync.cpp:1721:       // ALOGI("getRealTimeFor targetMediaUs:%" PRId64 " outRealUs:%" PRId64 " now:%" PRId64 "\n",
mediasync/MediaSync.cpp:1732:       // ALOGI("getRealTimeFor targetMediaUs:%" PRId64 " outRealUs:%" PRId64 " now:%" PRId64 "\n",
mediasync/MediaSync.cpp:1742:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1763:        ALOGE("MediaSync has been released, Error call getTrackMediaTime\n");
mediasync/MediaSync.cpp:1767:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1776:        MS_LOGI(MSYNC_DEBUG_LEVEL_0, mLogHead, "getTrackMediaTime outMediaUs:%" PRIx64 " \n",*outMediaUs);
mediasync/MediaSync.cpp:1788:    ret = mediasync_ioctl(mLogHead, mSyncDev,
mediasync/MediaSync.cpp:1803:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1818:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:1853:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"when reset on state:%s  need to audio lostsync mFirstLostSyncTimeUs:%" PRIx64 "",
mediasync/MediaSync.cpp:1917:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"when reset on state:%s need to video lostsync mFirstLostSyncTimeUs:%" PRIx64 "",
mediasync/MediaSync.cpp:2002:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"----->mediasync reset resumeplaying pts");
mediasync/MediaSync.cpp:2023:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"----->mediasync reset");
mediasync/MediaSync.cpp:2033:    ret = mediasync_ioctl(mLogHead, mSyncDev,
mediasync/MediaSync.cpp:2053:        //MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"no need to change unit.");
mediasync/MediaSync.cpp:2069:        //MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"no need to change unit.");
mediasync/MediaSync.cpp:2078:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"arg == NULL");
mediasync/MediaSync.cpp:2091:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"VideoLatency :%d us",*(int*)arg);
mediasync/MediaSync.cpp:2120:            //MS_LOGI(streamType2Str(mStreamtype), mSyncInsId, mPlayerInstanceNo,"MEDIASYNC_KEY_VIDEOWORKMODE");
mediasync/MediaSync.cpp:2124:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"MEDIASYNC_KEY_VIDEOTRICKMODE");
mediasync/MediaSync.cpp:2130:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"setParameter, mAudioMute =%d", mAudioMute);
mediasync/MediaSync.cpp:2134:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"setParameter, mSourceType =%d", mSourceType);
mediasync/MediaSync.cpp:2138:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "setParameter mALSAReady: %d", mALSAReady);
mediasync/MediaSync.cpp:2143:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "mVideoSyncIntervalUs: %d", mVideoSyncIntervalUs);
mediasync/MediaSync.cpp:2153:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"setParam: framerate:%d.", mFps);
mediasync/MediaSync.cpp:2158:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"video sync disenable:%d.", mVideoFreeRun);
mediasync/MediaSync.cpp:2163:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"audio sync disenable:%d.", mAudioFreeRun);
mediasync/MediaSync.cpp:2168:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"video Sync ThresholdUs:%d.", mVideoSyncThreshold);
mediasync/MediaSync.cpp:2174:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"audio Sync ThresholdUs:%d.", mAudioSyncThreshold);
mediasync/MediaSync.cpp:2179:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"mVideoDuringSlowSyncEnable:%d.", mVideoDuringSlowSyncEnable);
mediasync/MediaSync.cpp:2196:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:2202:            // MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"audio out port:%d.", mAudioOutPortInfo.output_port);
mediasync/MediaSync.cpp:2205:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "OUTPORT_HDMI_ARC AudioAdjustThreshold: %dms", mAudioAdjustThreshold / 90);
mediasync/MediaSync.cpp:2208:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "RESET AudioAdjustThreshold: %dms", mAudioAdjustThreshold / 90);
mediasync/MediaSync.cpp:2213:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "setParam: show first frame no sync:%d.", mPropertyShowFirstFrameNosync);
mediasync/MediaSync.cpp:2218:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "setParam: slowsync enable:%d.", mStartSlowSyncInfo.mSlowSyncEnable);
mediasync/MediaSync.cpp:2224:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "setParam: slowsync preroll rate:%f.", mStartSlowSyncInfo.mSlowSyncSpeed);
mediasync/MediaSync.cpp:2228:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "setParam: slowsync preroll AV tolerance:%d.", mStartSlowSyncInfo.mSlowSyncPVdiffThreshold);
mediasync/MediaSync.cpp:2238:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"startStrategy:%d", startStrategy);
mediasync/MediaSync.cpp:2241:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"set resume playing pts parameter");
mediasync/MediaSync.cpp:2247:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "setParam: outputFirstFrameBeforeAvSyncStage:%d.", mOutputFirstFrameBeforeAvSyncStage);
mediasync/MediaSync.cpp:2251:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "setParam: reset video state machine:%d.", mResetVideoMachine);
mediasync/MediaSync.cpp:2256:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:2262:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"setParam: Invalid type.");
mediasync/MediaSync.cpp:2273:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"arg == NULL");
mediasync/MediaSync.cpp:2306:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"getParam: Invalid type.");
mediasync/MediaSync.cpp:2318:          this logic is to reduce audiohal query driven state.*/
mediasync/MediaSync.cpp:2336:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:2343:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:2365:                    (mDebugLevel > 0 && judgeTimeOut(mAudioQueueLogTime, curSystime, 2000 * mLogPrintInterval))) {
mediasync/MediaSync.cpp:2366:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0, mLogHead, "drop a:%" PRIx64 ", pcr:%" PRIx64 ", diff:%" PRId64 " ms.",
mediasync/MediaSync.cpp:2378:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:2388:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:2413:          this logic is to reduce audiohal query driven state.*/
mediasync/MediaSync.cpp:2424:                if (mDebugLevel > 1 || (mDebugLevel > 0 && judgeTimeOut(mAudioQueueLogTime, curSystime, 2000 * mLogPrintInterval)))
mediasync/MediaSync.cpp:2425:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"drop a:%" PRIx64 ", demuxpcr:%" PRIx64 ", diff:%" PRId64 " ms.",
mediasync/MediaSync.cpp:2445:                (mDebugLevel > 0 && judgeTimeOut(mAudioQueueLogTime, curSystime, 2000 * mLogPrintInterval))) {
mediasync/MediaSync.cpp:2446:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"drop a:%" PRIx64 ", pcr:%" PRIx64 ", diff:%" PRId64 " ms.",
mediasync/MediaSync.cpp:2463:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"exception: null pointer.");
mediasync/MediaSync.cpp:2475:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"isworkingchannel:0 apts == -1 ");
mediasync/MediaSync.cpp:2500:        updateLogHead(1);
mediasync/MediaSync.cpp:2529:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "exception : interval [%d ms, %d ms].", tmpInterval / 90, mQueueAudioInterval / 90);
mediasync/MediaSync.cpp:2537:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "[AUT_PRINT] first audio es pts:%" PRIx64 ".", info->apts);
mediasync/MediaSync.cpp:2571:        judgeTimeOut(mAudioQueueLogTime, curSystime, 600 * mLogPrintInterval))) {
mediasync/MediaSync.cpp:2572:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:2578:             curSystime - mAudioQueueLogTime);
mediasync/MediaSync.cpp:2579:        mAudioQueueLogTime = curSystime;
mediasync/MediaSync.cpp:2602:        updateLogHead(1);
mediasync/MediaSync.cpp:2617:        (mDebugLevel > 0 && judgeTimeOut(mVideoQueueLogTime, curSystime, 600 * mLogPrintInterval))) {
mediasync/MediaSync.cpp:2618:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:2621:        mVideoQueueLogTime = curSystime;
mediasync/MediaSync.cpp:2633:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "[AUT_PRINT] first video es pts:%" PRIx64 ".", vpts);
mediasync/MediaSync.cpp:2880:    ret = mediasync_ioctl(mLogHead,mSyncDev, MEDIASYNC_IOC_GET_SYSTEMTIME, (unsigned long)&time);
mediasync/MediaSync.cpp:2882:        MS_LOGE(mLogHead,"exception getCurrentSystemTime FAILED.");
mediasync/MediaSync.cpp:2930:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:2943:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"clock_type: %s ==> %s", clockType2Str(mClockType),
mediasync/MediaSync.cpp:2946:    updateLogHead(0);
mediasync/MediaSync.cpp:2948:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:2952:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"setClockType error:%s\n", strerror(errno));
mediasync/MediaSync.cpp:2963:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:2998:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"state: %s --> %s.", avSyncState2Str(mAVSyncState), avSyncState2Str(state));
mediasync/MediaSync.cpp:3003:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3007:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"setAVSyncState error:%s\n", strerror(errno));
mediasync/MediaSync.cpp:3020:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3029:    //ALOGI("[%s,%d], streamtype:%s, state: %s.", __FUNCTION__, __LINE__,
mediasync/MediaSync.cpp:3041:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3059:         MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "ok,Now Mode == Change Mode(%s)\n",
mediasync/MediaSync.cpp:3064:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:3075:        //MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"FCC enable.");
mediasync/MediaSync.cpp:3079:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3094:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3106:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:3137:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3149:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3162:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3175:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3185:        MS_LOGI(MSYNC_DEBUG_LEVEL_AUDIO_PROC,mLogHead,"AudioInfo: %d ms",TM_PTS_2_MS(mAudioInfo.cacheDuration));
mediasync/MediaSync.cpp:3193:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3205:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3218:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3228:        MS_LOGI(MSYNC_DEBUG_LEVEL_VIDEO_PROC,mLogHead,"VideoInfo: %d ms",TM_PTS_2_MS(mVideoInfo.cacheDuration));
mediasync/MediaSync.cpp:3236:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3248:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3263:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3276:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3291:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3304:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3319:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3332:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3347:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3360:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3374:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3387:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3401:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3413:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3428:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3441:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3456:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3469:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3484:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3497:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3512:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3525:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3540:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3553:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3568:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3581:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3594:        ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3619:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3636:        ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3660:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3675:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3689:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3704:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3722:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"updateAVRef updateflag:%d\n",updateflag);
mediasync/MediaSync.cpp:3723:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3740:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3747:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"getAVRef:%d\n",*ref);
mediasync/MediaSync.cpp:3756:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3771:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3784:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3799:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3812:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3827:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3840:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3852:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3896:        ret2 = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3908:        ret2 = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3918:        ret2 = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:3936:    //MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"-->mediasyncControl.ptr:0x%lx",mediasyncControl.ptr);
mediasync/MediaSync.cpp:3955:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Switch Audio Tracks %s-->%s",
mediasync/MediaSync.cpp:4015:            MS_LOGI(MSYNC_DEBUG_LEVEL_VIDEO_PROC,mLogHead," mQueueInStcParmUpdateCount:%d \n", mQueueInStcParmUpdateCount);
mediasync/MediaSync.cpp:4071:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"setVideoLatency fail ret:%d", (int)ret);
mediasync/MediaSync.cpp:4123:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:4148:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:4180:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"debugLevel:0x%x",debugLevel);
mediasync/MediaSync.cpp:4185:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"mVideoFreeRun = 1");
mediasync/MediaSync.cpp:4189:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"mVideoFreeRun = 0");
mediasync/MediaSync.cpp:4195:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"mAudioFreeRun = 1");
mediasync/MediaSync.cpp:4199:             MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"mAudioFreeRun = 0");
mediasync/MediaSync.cpp:4207:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"set mDebugLevel:%d ",mDebugLevel);
mediasync/MediaSync.cpp:4211:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"set mDebugLevel = 0");
mediasync/MediaSync.cpp:4219:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"set mDeBugVptsOffset:%" PRId64 " \n",mDeBugVptsOffset);
mediasync/MediaSync.cpp:4223:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"set mDeBugVptsOffset = 0");
mediasync/MediaSync.cpp:4239:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "format: %d, DolbyAudio:%d", audioFormat.format, mIsAmDolbyAudio);
mediasync/MediaSync.cpp:4267:    //MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"hasaudio:%d",hasaudio);
mediasync/MediaSync.cpp:4292:        // MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "has video:%d",hasvideo);
mediasync/MediaSync.cpp:4304:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "audio reset,hasaudio:%d",hasaudio);
mediasync/MediaSync.cpp:4329:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Audio reset.");
mediasync/MediaSync.cpp:4333:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "update systemtime");
mediasync/MediaSync.cpp:4361:            MS_LOGE(mLogHead,"exception: AUDIO_ARRIVE state, video come later.");
mediasync/MediaSync.cpp:4392:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "update systemtime");
mediasync/MediaSync.cpp:4417:        MS_LOGE(mLogHead, "exception: VIDEO_ARRIVE state, audio come later.muteFlag=%d,sourceType=%d, waitTimeOutThresholdUs=%d",
mediasync/MediaSync.cpp:4441:    //MS_LOGE(mLogHead, "mStartFlag = 0x%x",mStartFlag);
mediasync/MediaSync.cpp:4451:            MS_LOGE(mLogHead, "audio reset,hasaudio:%d",hasaudio);
mediasync/MediaSync.cpp:4483:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Audio reset.");
mediasync/MediaSync.cpp:4498:    //MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"FCC(%d),start strategy:%d",mFccEnabled,mStartStrategy);
mediasync/MediaSync.cpp:4502:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"firstvpts:%" PRIx64 ", firstapts:%" PRIx64 " avalignDiffLarge(%" PRIx64 ")", firstvpts, firstapts, ABSSUB(firstvpts, firstapts));
mediasync/MediaSync.cpp:4505:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"no need to do align.");
mediasync/MediaSync.cpp:4512:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"no need to do align.");
mediasync/MediaSync.cpp:4522:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"--->mStartFlag:0x%x",mStartFlag);
mediasync/MediaSync.cpp:4537:            MS_LOGE(mLogHead, "[c:%" PRIx64 ", f:%" PRIx64 ", diff:%" PRId64 " ms].", curtime, mFirstEnterAVarriveTime, (curtime - mFirstEnterAVarriveTime) / 1000);
mediasync/MediaSync.cpp:4541:            MS_LOGE(mLogHead, "exception: AV_ARRIVE state, av align timeout.");
mediasync/MediaSync.cpp:4583:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Audio reset.");
mediasync/MediaSync.cpp:4612:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:4631:           MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:4687:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"set strategy:%d ",strategy);
mediasync/MediaSync.cpp:4703:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"av align ,close slowsync");
mediasync/MediaSync.cpp:4711:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:4717:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] strategy:%d, SlowSyncEnable:%d.", mStartStrategy, mStartSlowSyncInfo.mSlowSyncEnable);
mediasync/MediaSync.cpp:4735:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:4741:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"av aligned: av diff is too much, no need to do align.");
mediasync/MediaSync.cpp:4749:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"stream AV pts too large in invalid case all free run.");
mediasync/MediaSync.cpp:4768:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"apts jump back, av diff is too much, no need to do align.");
mediasync/MediaSync.cpp:4773:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"av aligned: audio do nothing.");
mediasync/MediaSync.cpp:4785:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"av aligned done (slow sync): audioCache:%d ms",
mediasync/MediaSync.cpp:4794:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:4811:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:4823:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:4857:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"av aligning: videoStartWithJumpBack, audio drop %" PRId64 " us, Acache: %" PRId64 " us", dropCache, audioCacheUs);
mediasync/MediaSync.cpp:4862:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"av aligned: audio insert %" PRId64 " us.", diff * 1000 / 90);
mediasync/MediaSync.cpp:4887:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"dropping pcm, apts:0x%" PRIx64 ", firstPts:0x%" PRIx64 ", diff:%" PRId64 " us.",
mediasync/MediaSync.cpp:4910:        MS_LOGE(mLogHead,"exception: [a:%" PRIx64 ", v:%" PRIx64 ", dmx:%" PRIx64 "],dmx pts < 0.",
mediasync/MediaSync.cpp:4916:            MS_LOGE(mLogHead,"exception:video only, vpts is abnormal.");
mediasync/MediaSync.cpp:4922:            MS_LOGE(mLogHead,"exception:audio only, apts is abnormal.");
mediasync/MediaSync.cpp:4929:            MS_LOGE(mLogHead,"exception: dmx_pcr is abnormal.");
mediasync/MediaSync.cpp:4934:                MS_LOGE(mLogHead,"exception: video pts is abnormal.");
mediasync/MediaSync.cpp:4937:                MS_LOGE(mLogHead,"exception: audio pts is abnormal.");
mediasync/MediaSync.cpp:4942:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"pa_diff:%" PRId64 " ms, pv_diff:%" PRId64 " ms, av_diff:%" PRId64 " ms, invalidstream:%s.",
mediasync/MediaSync.cpp:4971:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:4983:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"video cache:%d ms.", mVideoInfo.cacheDuration / 90);
mediasync/MediaSync.cpp:4988:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:4994:        MS_LOGE(mLogHead,"exception: cannot get dmx_pcr, dmx_pcr is invalid.");
mediasync/MediaSync.cpp:5001:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5008:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5024:     //   MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "special frame size, need enlarge cache thread.");
mediasync/MediaSync.cpp:5038:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"FCC case, diff:%d ms, cache:%d ms, threshold:%d ms.",\
mediasync/MediaSync.cpp:5064:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "special frame size, need enlarge cache thread.");
mediasync/MediaSync.cpp:5152:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5169:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5197:                        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5206:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5214:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] startpts:%" PRIx64 ".", startpts);
mediasync/MediaSync.cpp:5238:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"refClockInit, syncmode:%d.", mSyncMode);
mediasync/MediaSync.cpp:5367:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Waiting for video longer.");
mediasync/MediaSync.cpp:5382:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "special frame size, need enlarge cache thread.");
mediasync/MediaSync.cpp:5478:                        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5486:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5493:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5501:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] startpts:%" PRIx64 ".", startpts);
mediasync/MediaSync.cpp:5512:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"refclock[pts:%" PRIx64 ",systemtime:%" PRIx64 ",offset:%d ms, type:%s].", refInfo.framePts, refInfo.frameSystemTime,startPlayOffset/90, clockType2Str(mClockType));
mediasync/MediaSync.cpp:5515:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] Running state.");
mediasync/MediaSync.cpp:5535:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Audio Resample: start playback rate: %f.", mLastRateSlope);
mediasync/MediaSync.cpp:5541:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Audio Resample: playback rate change: %f -> %f.", mLastRateSlope, playbackRateSlope);
mediasync/MediaSync.cpp:5557:        MS_LOGI(MSYNC_DEBUG_LEVEL_AUDIO_PROC,mLogHead,"Audio Resample: playback rate unchanged: %f.", playbackRateSlope);
mediasync/MediaSync.cpp:5582:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Audio Resample: start playback rate: %f.", mLastRateSlope);
mediasync/MediaSync.cpp:5587:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Audio Resample: %f.", playbackRateSlope);
mediasync/MediaSync.cpp:5599:            //MS_LOGI(MSYNC_DEBUG_LEVEL_AUDIO_PROC,mLogHead,"Audio Resample: playback rate unchanged: %f.", playbackRateSlope);
mediasync/MediaSync.cpp:5611:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Audio adjust clock, output clock:%d/%d=%f", mAudioOutputCurrentClock, mAudioOutputDefaultClock,current_audio_output_slope);
mediasync/MediaSync.cpp:5615:                        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Audio adjust clock: speed up");
mediasync/MediaSync.cpp:5624:                        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Audio adjust clock: slow down");
mediasync/MediaSync.cpp:5636:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"slope reset to normal from resample");
mediasync/MediaSync.cpp:5638:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"slope reset to normal from adjust clock");
mediasync/MediaSync.cpp:5643:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"play slope changed: %f -> %f.", mLastRateSlope, playbackRateSlope);
mediasync/MediaSync.cpp:5687:    //    MS_LOGI(streamType2Str(mStreamtype), mSyncInsId, mPlayerInstanceNo,"pa_diff %" PRId64 " ms.", pa_diff/90);
mediasync/MediaSync.cpp:5696:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Alsa not ready, normal output.");
mediasync/MediaSync.cpp:5726:                            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,\
mediasync/MediaSync.cpp:5737:                                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5744:                                        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"audio work change timeout, need output.");
mediasync/MediaSync.cpp:5750:                                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5756:                        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5769:                        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5781:                            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "mEnterDropthreadCount:%d.", mEnterDropthreadCount);
mediasync/MediaSync.cpp:5789:                                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5810:                                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5817:                                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5828:                            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5836:                            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,\
mediasync/MediaSync.cpp:5840:                            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5852:                            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5887:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:5928:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Audio Insert: %d us.", asyncPolicy->param1);
mediasync/MediaSync.cpp:5944:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6000:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6038:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "special frame size, need enlarge discontinue cache thread.");
mediasync/MediaSync.cpp:6064:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Type:%s apts adjust:%" PRId64 " ms, vpts adjust:%" PRId64 " ms.",
mediasync/MediaSync.cpp:6141:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6146:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6149:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6156:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6161:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6209:                    //MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"startpts = audioStartPts \n");
mediasync/MediaSync.cpp:6212:                    ///MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"startpts = videoStartPts \n");
mediasync/MediaSync.cpp:6214:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6219:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6226:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[type:%s, invalid:%s],"
mediasync/MediaSync.cpp:6263:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6280:                        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6285:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[type:%s, invalid:%s],"
mediasync/MediaSync.cpp:6307:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[type:%s, invalid:%s],"
mediasync/MediaSync.cpp:6341:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"type:%s, discontinue time out.", clockType2Str(mClockType));
mediasync/MediaSync.cpp:6369:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"type:%s,"
mediasync/MediaSync.cpp:6419:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,\
mediasync/MediaSync.cpp:6456:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0, mLogHead, "report av out of sync event, avPtsDiff: %" PRId64 " ms! cur_apts:%" PRId64 ",\n",
mediasync/MediaSync.cpp:6508:                                    MS_LOGI(MSYNC_DEBUG_LEVEL_0, mLogHead, "report audio discontinue event\n");
mediasync/MediaSync.cpp:6510:                                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"av + PCRMASTER discontinue,"
mediasync/MediaSync.cpp:6517:                            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"av + PCRMASTER discontinue,"
mediasync/MediaSync.cpp:6527:                        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"av + VMASTER discontinue,"
mediasync/MediaSync.cpp:6542:                                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"report audio discontinue event,"
mediasync/MediaSync.cpp:6569:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"v-only + PCRMASTER discontinue end, [source:%" PRIx64 ", v:%" PRIx64 ", diff:%" PRId64 " ms]!",\
mediasync/MediaSync.cpp:6575:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"v-only + PCRMASTER discontinue timeout!");
mediasync/MediaSync.cpp:6596:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6603:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"v-only + PCRMASTER discontinue timeout!");
mediasync/MediaSync.cpp:6664:              //  MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"discontinue, mStartFlag:%d", mStartFlag);
mediasync/MediaSync.cpp:6685:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6693:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6703:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6713:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"AUDIO NOT SHOW FIRST FRAME!");
mediasync/MediaSync.cpp:6724:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6739:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"discontinue end, mStartFlag:%d", mStartFlag);
mediasync/MediaSync.cpp:6753:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6768:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6774:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6801:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6817:                 MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6826:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,
mediasync/MediaSync.cpp:6827:                        mLogHead,"av + PCRMASTER discontinue end(%s), [dmxpcr:%" PRIx64 ", apts:%" PRIx64 ", vpts:%" PRIx64 ", diffa:%" PRId64 " ms, diffv:%" PRId64 " ms]!",
mediasync/MediaSync.cpp:6835:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6853:                MS_LOGI(MSYNC_DEBUG_LEVEL_0, mLogHead, "set video free!");
mediasync/MediaSync.cpp:6856:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"master:(%s) (%s) discontinue timeout!",
mediasync/MediaSync.cpp:6888:    //MS_LOGI(streamType2Str(mStreamtype), mSyncInsId, mPlayerInstanceNo,"pause->resume,type:%s. [%" PRIx64 ", %" PRIx64 "] ",
mediasync/MediaSync.cpp:6899:             MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead," apts update refclock:[%" PRIx64 ", %" PRIx64 "].", pts, systemTime);
mediasync/MediaSync.cpp:6901:            //MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6906:            // MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6926:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"audio mediasync update refclock.");
mediasync/MediaSync.cpp:6952:    //MS_LOGI(streamType2Str(mStreamtype), mSyncInsId, mPlayerInstanceNo,"pause->resume,type:%s. [%" PRIx64 ", %" PRIx64 "] ",
mediasync/MediaSync.cpp:6962:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"VIDEO_CLOCK vpts update refclock:[%" PRIx64 ", %" PRIx64 "].", pts, systemTime);
mediasync/MediaSync.cpp:6970:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6976:            //MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:6995:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"video mediasync update refclock.");
mediasync/MediaSync.cpp:7021:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "%s_PTS increase:%" PRId64 " ms, period:%" PRId64 " ms, ratio:%.2f",\
mediasync/MediaSync.cpp:7049:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "video_outFps:%.2f, dropFps:%.2f", outputFps, dropFsp);
mediasync/MediaSync.cpp:7087:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"video only, the video not start!.\n");
mediasync/MediaSync.cpp:7092:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"audio only, the audio not start!.\n");
mediasync/MediaSync.cpp:7119:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:7145:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:7150:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"refclock update! curpcr:%" PRIx64 ", cursys:%" PRIx64 ", startThreshold:%d, lastslope:%f, slope:%f.\n", frameInfo.framePts, frameInfo.frameSystemTime, offset / 90,mLastSlope, slope);
mediasync/MediaSync.cpp:7169:        MS_LOGI(MSYNC_DEBUG_LEVEL_VIDEO_PROC,mLogHead," mStcParmUpdateCount:%d \n", mStcParmUpdateCount);
mediasync/MediaSync.cpp:7242:mediasync_result MediaSync::audioDebugInfo(bool logPrintable,int64_t cur_vpts, int64_t cur_apts,int64_t realCurVpts,int64_t apts)
mediasync/MediaSync.cpp:7244:    //debug log
mediasync/MediaSync.cpp:7257:    if (logPrintable) {
mediasync/MediaSync.cpp:7263:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:7277:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:7290:   //     MS_LOGE(streamType2Str(mStreamtype), mSyncInsId, mPlayerInstanceNo,"exception: apts jump back cur_apts:%" PRId64 "-mDebugLastapts:%" PRId64 "=%" PRId64 "us!",cur_apts * 100 / 9, mDebugLastapts * 100 / 9,curAptsLastAptsDiff * 100 / 9);
mediasync/MediaSync.cpp:7293:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"exception: [p-add:%" PRId64 " ms, a-add:%" PRId64 " ms] AudioProcess long time not called.",\
mediasync/MediaSync.cpp:7297:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:7359:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:7413:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:7442:            //MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"AudioReseted, diff %d ms, mStartPlayThreshold %d ms",
mediasync/MediaSync.cpp:7449:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] AUDIO START directly due to diff(%" PRId64 " ms) is large.", ABSSUB(mCurPcr, cur_apts) / 90);
mediasync/MediaSync.cpp:7454:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] AUDIO START,speed:[%f-->%f]!", mLastPlaybackRate, mRefClock.getRealPlaybackRate());
mediasync/MediaSync.cpp:7484:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"large video cache back:%d ms,base:%" PRId64 " ms",\
mediasync/MediaSync.cpp:7491:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"adjust pcr slope back:%f,video cache(ms):%d,range:%d,base:%" PRId64 ",audio cache:%d ms",\
mediasync/MediaSync.cpp:7524:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"adjust pcr slope faster:%f,video cache(ms):%d,range:%d,base:%" PRId64 ",audio cache:%d ms",\
mediasync/MediaSync.cpp:7545:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"large video cache duration:%" PRId64 "/%d ms,cache:%d ms,base:%" PRId64 " ms",\
mediasync/MediaSync.cpp:7563:        MS_LOGI(MSYNC_DEBUG_LEVEL_VIDEO_PROC,mLogHead,"");
mediasync/MediaSync.cpp:7572:        MS_LOGI(MSYNC_DEBUG_LEVEL_VIDEO_PROC,mLogHead,"from %s_%d",from,line);
mediasync/MediaSync.cpp:7586:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"mRichVideoThreshold locked: %" PRId64 " ms(%d)",TM_PTS_2_MS(mRichVideoThreshold),mVCacheBaseFrameCount);
mediasync/MediaSync.cpp:7594:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"mRichVideoThreshold: %" PRId64 " ms(%d) after %" PRId64 " ms,curr_v_cache: %d ms",\
mediasync/MediaSync.cpp:7603:    return (mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:7642:        // MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"cache:%d, cur_apts:%" PRIx64 ", last_apts:%" PRIx64 ", diff:%" PRId64 " ",
mediasync/MediaSync.cpp:7700:    updateLogHead(1);
mediasync/MediaSync.cpp:7702:    bool logPrintable = false;
mediasync/MediaSync.cpp:7703:    if (mDebugLevel > 1 || (mDebugLevel > 0 && judgeTimeOut(mAudioInfoLogTime, curSystime, 300 * mLogPrintInterval))) {
mediasync/MediaSync.cpp:7704:        mAudioInfoLogTime = curSystime;
mediasync/MediaSync.cpp:7705:        logPrintable = true;
mediasync/MediaSync.cpp:7716:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"cur_apts:%" PRIx64 " cur dmx pcr:%" PRIx64 " mStartPts:%" PRIx64 ".", cur_apts, dmxPcrInfo.framePts, mFccStartPts);
mediasync/MediaSync.cpp:7736:               MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"cur_apts:%" PRId64 " < mResumePlayingPts  %" PRId64 " need drop" , cur_apts, mAudioResumePlayingPts);
mediasync/MediaSync.cpp:7740:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"setResumePlayMode MEDIASYNC_STATUS_AUDIO_DONE");
mediasync/MediaSync.cpp:7750:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] first apts:%" PRIx64 ", first apts systemtime:%" PRIx64 ".", cur_apts, curSystime);
mediasync/MediaSync.cpp:7757:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"EXIT PLAYBACK.");
mediasync/MediaSync.cpp:7768:            //MS_LOGI(streamType2Str(mStreamtype), mSyncInsId, mPlayerInstanceNo,"apts:%" PRIx64 ", cur_apts:%" PRIx64 ", syncState:%d, startflag:%x.", apts, cur_apts, syncState, mStartFlag);
mediasync/MediaSync.cpp:7796:            //MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"pauseResumeFlag:%d apts:%" PRIx64 "",pauseResumeFlag,apts);
mediasync/MediaSync.cpp:7822:        //MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"--------->pauseResumeFlag:%d apts:%" PRIx64 "",mUpdateInfo.mPauseResumeFlag,apts);
mediasync/MediaSync.cpp:7838:    audioDebugInfo(logPrintable,curVideoInfo.framePts,cur_apts,realCurVpts,apts);
mediasync/MediaSync.cpp:7847:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Audio is ready to start,hold time :%d us !",asyncPolicy->param1);
mediasync/MediaSync.cpp:7863:           MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:7875:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:7921:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:7932:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"cur_apts:%" PRIx64 ", aPolicy:%s",mAudioClock.getCurPts(), audioPolicy2Str(asyncPolicy->audiopolicy));
mediasync/MediaSync.cpp:7942:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:7960:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:7975:        if (mDebugLevel > 0 || judgeTimeOut(mAudioFreerunLogTime, curSystime, 300 * mLogPrintInterval) ||
mediasync/MediaSync.cpp:7977:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:7980:            mAudioFreerunLogTime = curSystime;
mediasync/MediaSync.cpp:8005:            judgeTimeOut(mAudioPolicyLogTime, curSystime, 300 * mLogPrintInterval))) {
mediasync/MediaSync.cpp:8007:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8018:            mAudioPolicyLogTime = curSystime;
mediasync/MediaSync.cpp:8026:            judgeTimeOut(mAudioPolicyLogTime, curSystime, 300 * mLogPrintInterval))) {
mediasync/MediaSync.cpp:8027:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8034:            mAudioPolicyLogTime = curSystime;
mediasync/MediaSync.cpp:8063:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "video jump");
mediasync/MediaSync.cpp:8078:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "pv diff is large, enter slow play sync.");
mediasync/MediaSync.cpp:8085:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "Video back to sync, leave slow play sync.");
mediasync/MediaSync.cpp:8151:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"mVideoLatency(ms) changed:%d -> %d",mVideoLatency90K4Vsync / 90, tmp / 90);
mediasync/MediaSync.cpp:8158:mediasync_result MediaSync::videoDebugInfo(bool logPrintable,int64_t vpts, int64_t cur_vpts,int64_t actualVpts)
mediasync/MediaSync.cpp:8175:    if (logPrintable) {
mediasync/MediaSync.cpp:8176:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8184:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8194:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8200:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8207:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8220:mediasync_result MediaSync::checkVideoFreeRun(bool logPrintable,int64_t curSystime,int64_t actualVpts,bool* isVideoFreeRun)
mediasync/MediaSync.cpp:8240:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8261:            if (logPrintable || videoComesLate) {
mediasync/MediaSync.cpp:8262:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"video only free run.");
mediasync/MediaSync.cpp:8278:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"discontinue vpts jump back actualVpts:0x %" PRIx64 "", actualVpts);
mediasync/MediaSync.cpp:8293:        if (logPrintable) {
mediasync/MediaSync.cpp:8294:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"video free run. mVideoFreeRun:%d",mVideoFreeRun);
mediasync/MediaSync.cpp:8313:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"mVideoFreeRun 1-->0 ");
mediasync/MediaSync.cpp:8339:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"micro speed --> normal, update refclock.");
mediasync/MediaSync.cpp:8363:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8383:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"ExpectAvSyncDoneTimeUS is less than mSlowSyncRealPVdiffUs, close slowsync!");
mediasync/MediaSync.cpp:8391:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8399:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] SlowSync Start!");
mediasync/MediaSync.cpp:8400:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] VIDEO START directly due to slowsync!");
mediasync/MediaSync.cpp:8412:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] No SlowSync!");
mediasync/MediaSync.cpp:8413:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] VIDEO START directly due to diff is large!");
mediasync/MediaSync.cpp:8424:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] No SlowSync!");
mediasync/MediaSync.cpp:8425:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] VIDEO START!");
mediasync/MediaSync.cpp:8438:     return (mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:8500:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"checkVPtsValid failed:%" PRIx64 "", vpts);
mediasync/MediaSync.cpp:8510:            updateLogHead(1);
mediasync/MediaSync.cpp:8540:    bool logPrintable = false;
mediasync/MediaSync.cpp:8541:    if (mDebugLevel > 1 || (mDebugLevel > 0 && judgeTimeOut(mVideoInfoLogTime, curSystime, 300 * mLogPrintInterval))) {
mediasync/MediaSync.cpp:8542:        mVideoInfoLogTime = curSystime;
mediasync/MediaSync.cpp:8543:        logPrintable = true;
mediasync/MediaSync.cpp:8551:    updateLogHead(1);
mediasync/MediaSync.cpp:8581:        MS_LOGI(MSYNC_DEBUG_LEVEL_VIDEO_PROC, mLogHead, "Ionly mode vpts:%" PRIx64 ", vpts systemtime:%" PRIx64, vpts, curSystime);
mediasync/MediaSync.cpp:8591:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"vpts:%" PRId64 " < mResumePlayingPts  %" PRId64 " need drop" ,vpts, mVideoResumePlayingPts);
mediasync/MediaSync.cpp:8596:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"setResumePlayMode MEDIASYNC_STATUS_VIDEO_DONE");
mediasync/MediaSync.cpp:8605:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"SHOW FIRST FRAME NOSYNC in VIDEO_TRICK_MODE_PAUSE_NEXT, [real:%" PRId64 ", curtime:%" PRId64 ", r-c:%" PRId64 " us].", vsyncPolicy->param1, curSystime, vsyncPolicy->param1 - curSystime);
mediasync/MediaSync.cpp:8621:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"vpts:%" PRIx64 " cur dmx pcr:%" PRIx64 " mStartPts:%" PRIx64 ".",vpts, dmxPcrInfo.framePts, mFccStartPts);
mediasync/MediaSync.cpp:8646:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] first vpts:%" PRIx64 ", first vpts systemtime:%" PRIx64 ", fcc:%d, showfirst:%d.", vpts, curSystime, mFccEnabled, mPropertyShowFirstFrameNosync);
mediasync/MediaSync.cpp:8660:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"SHOW FIRST FRAME NOSYNC, [real:%" PRId64 ", curtime:%" PRId64 " vsync:%d r-c:%" PRId64 " us].",
mediasync/MediaSync.cpp:8670:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"first vpts invalid ,render");
mediasync/MediaSync.cpp:8674:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"first vpts invalid ,drop");
mediasync/MediaSync.cpp:8686:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"SHOW FIRST FRAME NOSYNC 2, [real:%" PRId64 ", curtime:%" PRId64 ", r-c:%" PRId64 " us].", vsyncPolicy->param1, curSystime, vsyncPolicy->param1 - curSystime);
mediasync/MediaSync.cpp:8694:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"EXIT PLAYBACK.");
mediasync/MediaSync.cpp:8759:    videoDebugInfo(logPrintable,vpts,cur_vpts,actualVpts);
mediasync/MediaSync.cpp:8781:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"start apts jump back, need drop video, curvpts:%" PRIx64 ".", vpts);
mediasync/MediaSync.cpp:8798:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8820:    checkVideoFreeRun(logPrintable,curSystime,actualVpts,&isVideoFreeRun);
mediasync/MediaSync.cpp:8848:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8872:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8904:                MS_LOGI(MSYNC_DEBUG_LEVEL_VIDEO_PROC,mLogHead,"VideoHoldTime: %" PRId64 " ms,(actualVpts - mCurPcr)=%" PRId64 " ms",VideoHoldTimeUs / 1000, (actualVpts - mCurPcr) / 90);
mediasync/MediaSync.cpp:8920:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"vptsIncrease:%" PRId64 ", vpts:%" PRId64 ", "
mediasync/MediaSync.cpp:8929:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"needDropButDisplay realshowtime:%" PRId64 " \n",realshowtime);
mediasync/MediaSync.cpp:8939:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:8958:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"mVideoLatency(ms) changed:%d -> %d",mVideoLatency90K4Vsync / 90, tmp / 90);
mediasync/MediaSync.cpp:9012:        logPrintable) {
mediasync/MediaSync.cpp:9013:        mVideoPolicyLogTime = curSystime;
mediasync/MediaSync.cpp:9016:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,\
mediasync/MediaSync.cpp:9024:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:9034:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"cur_vpts:%" PRIx64 ","
mediasync/MediaSync.cpp:9061:                MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"firstNormalOut vpts:%" PRIx64 ",vcache:%dms",vpts,mUpdateInfo.mVideoInfo.cacheDuration/90);
mediasync/MediaSync.cpp:9070:                    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Interlaced stream!");
mediasync/MediaSync.cpp:9095:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:9099:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:9122:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:9125:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
mediasync/MediaSync.cpp:9139:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] SlowSync Finished.");
mediasync/MediaSync.cpp:9151:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[actualVptsPcrDiff:%" PRId64 " ms, Speed=%f, vcache:%d ms fps:%d]",
mediasync/MediaSync.cpp:9163:        MS_LOGI(MSYNC_DEBUG_LEVEL_0, mLogHead, "jump detected, start slow sync.curSystime:%" PRIx64 ", speed:%f",
mediasync/MediaSync.cpp:9171:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] During SlowSync Finished.");
mediasync/MediaSync.cpp:9181:            MS_LOGI(MSYNC_DEBUG_LEVEL_VIDEO_PROC,mLogHead,"VideoHoldTime: %" PRId64 " ms,(actualVpts - mCurPcr)=%" PRId64 " ms",VideoHoldTimeUs / 1000, actualPtsPcrDiff / 90);
mediasync/MediaSync.cpp:9203:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead," mExternalUpdateCount:%d \n", mExternalUpdateCount);
mediasync/MediaSync.cpp:9220:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead," mRefClock is not active, return stc = -1");
mediasync/MediaSync.cpp:9288:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"time: %" PRId64 "", time);
mediasync/MediaSync.cpp:9299:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"set instance demuxid:%d pcrpid:0x%x\n",DemuxId, PcrPid);
mediasync/MediaSync.cpp:9301:    ret = mediasync_ioctl(mLogHead,mSyncDev,
mediasync/MediaSync.cpp:9383:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "no need video tune, interval:%" PRId64 " ms.", interval/1000);
mediasync/MediaSync.cpp:9390:            MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "pcrAdjust tuneUs:%" PRId64 " us.", mVideoTuneUs);
mediasync/MediaSync.cpp:9396:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "UseFreerunClock:%d, tuneUs:%" PRId64 " us.", UseFreerunClock, mVideoTuneUs);
mediasync/MediaSync.cpp:9404:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "pfunc:%s Handle:%s mVideoSyncAdapterWrapper=%s",
mediasync/MediaSync.cpp:9409:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "RegisterCb pfunc:%p disPlayHandle:%p\n",pfunc,Handle);
mediasync/MediaSync.cpp:9419:        MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead, "RegisterCb mCallback:%p mVdecWrapperHandle:%p\n", mCallback, mVdecWrapperHandle);
mediasync/MediaSync.cpp:9467:    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"[AUT_PRINT] StreamInfo: %d .", info);
mediasync/MediaSync.cpp:9476:        ALOGE("exception: /dev/mediasync %s ",strerror(errno));
mediasync/MediaSync.cpp:9647:        ALOGE("exception: MediaSync_getFirstVideoFrameInfo no handle.");
mediasync/MediaSync.cpp:9657:        ALOGE("exception: mediasync_setParameter no handle.");
mediasync/MediaSync.cpp:9666:        ALOGE("exception: mediasync_getParameter no handle.");
mediasync/MediaSync.cpp:9674:        ALOGE("exception: MediaSync_queueAudioFrame no handle.");
mediasync/MediaSync.cpp:9682:        ALOGE("exception: MediaSync_queueVideoFrame no handle.");
mediasync/MediaSync.cpp:9690:        ALOGE("exception: MediaSync_AudioProcess no handle.");
mediasync/MediaSync.cpp:9698:        ALOGE("exception: MediaSync_VideoProcess no handle.");
mediasync/MediaSync.cpp:9707:        ALOGE("exception: MediaSync_GetMediaTimeByType no handle.");
mediasync/MediaSync.cpp:9716:        ALOGE("exception: MediaSync_setPcrAndDmxId no handle.");
mediasync/MediaSync.cpp:9725:        ALOGE("exception: MediaSync_setPcrAndDmxId no handle.");
mediasync/MediaSync.cpp:9734:        ALOGE("exception: MediaSync_setPcrAndDmxId no handle.");
mediasync/MediaSync.cpp:9743:        ALOGE("exception: MediaSync_setPcrAndDmxId no handle.");
mediasync/MediaSync.cpp:9752:        ALOGE("exception: MediaSync_setPcrAndDmxId no handle.");
mediasync/Android.bp:24:        "liblog",
mediasync/Android.bp:30:        "libmediahal_tsplogger_headers",
mediasync/Android.bp:63:        "libmediahal_tsplogger_headers",
mediasync/Android.bp:69:        "liblog",
mediasync/Android.bp:108:        "liblog",
mediasync/Android.bp:114:        "libmediahal_tsplogger_headers",
mediasync/MediaSyncClock.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
mediasync/MediaSyncClock.cpp:10://#define LOG_NDEBUG 0
mediasync/MediaSyncClock.cpp:11:#define LOG_TAG "AmMediaSync"
mediasync/MediaSyncClock.cpp:17:#define MS_CLOCK_LOGI(head,type,fmt,...) \
mediasync/MediaSyncClock.cpp:19:    ALOGI("%s %s(%s:%d) " fmt, head,type, __FUNCTION__, __LINE__, ##__VA_ARGS__);\
mediasync/MediaSyncClock.cpp:49:void ClockBase::setLogHead(char* head) {
mediasync/MediaSyncClock.cpp:50:    memset(mLogHead,0,sizeof(mLogHead));
mediasync/MediaSyncClock.cpp:51:    snprintf(mLogHead,LOG_HEAD_LENGTH,"%s",head);
mediasync/MediaSyncClock.cpp:219:        MS_CLOCK_LOGI(mLogHead,mClockName,"threshold:%d -> %d ms", mStartPlayThreshold/90, threshold/90);
mediasync/MediaSyncClock.cpp:229:        MS_CLOCK_LOGI(mLogHead,mClockName,"setPcrAdjust adjust:%d ms, pcr_add:%d ms", pts_adjust/90, mPcrAdjust/90);
mediasync/MediaSyncClock.cpp:237:        MS_CLOCK_LOGI(mLogHead,mClockName,"adjust:%d ms, pcr_add:%d ms", pts_adjust/90, mPcrAdjust/90);
mediasync/MediaSyncClock.cpp:257:    MS_CLOCK_LOGI(mLogHead,mClockName,"mPlaybackRate:%f, mPcrSlope:%f, mPlaySlope:%f, mBasedPlaySlope:%d",mPlaybackRate, mPcrSlope, mPlaySlope, mBasedPlaySlope);
mediasync/MediaSyncClock.cpp:266:        MS_CLOCK_LOGI(mLogHead,mClockName,"rate:%f->%f",mPlaybackRate,rate);
mediasync/MediaSyncClock.cpp:274:        MS_CLOCK_LOGI(mLogHead,mClockName,"slope:%f->%f",mPcrSlope,slope);
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:9:#define LOG_NDEBUG 0
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:10:#define LOG_TAG "MsVideoSyncAdapterWrapper"
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:12:#include <utils/Log.h>
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:23:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:24:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:25:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:29:    FLOGI(mPlayerInstansNo, "in\n");
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:32:        FLOGI(mPlayerInstansNo,"new VideoSyncFRAC err\n");
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:63:            //FLOGI(mPlayerInstansNo, "getVsyncFracTime vsyncTimestamp:%lld vsyncPeriod:%d\n",vsyncTimestamp,vsyncPeriod);
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:128:        FLOGI(mPlayerInstansNo, "vsyncTimestamp:%" PRId64 " vsyncPeriod:%d diff:%" PRId64 " vSyncCount:%d\n",vsyncTimestamp, mRecordVsyncPeriod,*outRealTime - vsyncTimestamp,vSyncCount);
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:134:        FLOGI(mPlayerInstansNo, "%sgetVsyncFracTime *outRealTime:%" PRId64 " RealTime:%" PRId64 " diff:%" PRId64 " vsyncDiff:%" PRId64 "(%f)\n",
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:143:    //FLOGI(mPlayerInstansNo, "getVsyncFracTime *outRealTime:%lld RealTime:%lld diff:%lld\n",*outRealTime,RealTime,*outRealTime-RealTime);
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:170:    FLOGI(mPlayerInstansNo, "RegisterCb pfunc:%p disPlayHandle:%p\n",pfunc,Handle);
mediasync/frameControl/MsVideoSyncAdapterWrapper.cpp:173:        FLOGE(mPlayerInstansNo, "RegisterCb pfunc == NULL || disPlayHandle == NULL ");
mediasync/frameControl/MsVideoSyncFRAC.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
mediasync/frameControl/MsVideoSyncFRAC.cpp:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
mediasync/frameControl/MsVideoSyncFRAC.cpp:9:#define LOG_NDEBUG 0
mediasync/frameControl/MsVideoSyncFRAC.cpp:10:#define LOG_TAG "MsVideoSyncFRAC"
mediasync/frameControl/MsVideoSyncFRAC.cpp:11:#include <utils/Log.h>
mediasync/frameControl/MsVideoSyncFRAC.cpp:25:#define LOG_ERR 0
mediasync/frameControl/MsVideoSyncFRAC.cpp:26:#define LOG_INFO 1
mediasync/frameControl/MsVideoSyncFRAC.cpp:27:#define LOG_DEBUG_LEVEL1 2
mediasync/frameControl/MsVideoSyncFRAC.cpp:28:#define LOG_DEBUG_LEVEL2 4
mediasync/frameControl/MsVideoSyncFRAC.cpp:30:static unsigned int gloglevel = 1;
mediasync/frameControl/MsVideoSyncFRAC.cpp:31:#define VSFRACLog(level, f, s...) \
mediasync/frameControl/MsVideoSyncFRAC.cpp:33:    if (level & gloglevel) { \
mediasync/frameControl/MsVideoSyncFRAC.cpp:35:            ALOGI(f, ##s); \
mediasync/frameControl/MsVideoSyncFRAC.cpp:36:        else if (level == LOG_DEBUG_LEVEL1 || level == LOG_DEBUG_LEVEL2) \
mediasync/frameControl/MsVideoSyncFRAC.cpp:37:            ALOGD(f, ##s); \
mediasync/frameControl/MsVideoSyncFRAC.cpp:40:        ALOGE(f, ##s); \
mediasync/frameControl/MsVideoSyncFRAC.cpp:48:        VSFRACLog(LOG_INFO, "%s set = %d\n", str, *def);
mediasync/frameControl/MsVideoSyncFRAC.cpp:50:        VSFRACLog(LOG_INFO, "%s is not set used def = %d\n", str, *def);
mediasync/frameControl/MsVideoSyncFRAC.cpp:212:    VSFRACLog(LOG_INFO, "[%s%d]", __func__, __LINE__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:213:    propGetInt("vendor.mediahal.loglevels", (int*)&gloglevel);
mediasync/frameControl/MsVideoSyncFRAC.cpp:216:        VSFRACLog(LOG_ERR, "malloc error");
mediasync/frameControl/MsVideoSyncFRAC.cpp:224:    VSFRACLog(LOG_INFO, "[%s%d]", __func__, __LINE__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:234:        VSFRACLog(LOG_ERR, "[%s]no videoSyncFrac_priv", __func__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:240:        VSFRACLog(LOG_INFO, "[%s] framerate:%d", __func__, framerate);
mediasync/frameControl/MsVideoSyncFRAC.cpp:242:        VSFRACLog(LOG_ERR, "[%s]invalid framerate:%d", __func__, framerate);
mediasync/frameControl/MsVideoSyncFRAC.cpp:251:        VSFRACLog(LOG_ERR, "[%s]no videoSyncFrac_priv", __func__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:268:        VSFRACLog(LOG_ERR, "[%s]no videoSyncFrac_priv", __func__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:281:                    VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]hwcvsync:%" PRId64 ", prevsync:%" PRId64 " syncdiff:%" PRId64 ", synccntdiff:%" PRId64 " vsyncinc:%d, vsynccnt:%" PRId64 "",
mediasync/frameControl/MsVideoSyncFRAC.cpp:290:                    VSFRACLog(LOG_ERR, "invalid vsync info, never should enter here, need hwc check  soft vsync");
mediasync/frameControl/MsVideoSyncFRAC.cpp:296:                VSFRACLog(LOG_INFO, "[%s]hdmi frequency changed from %" PRId32 "->%" PRId32 "",
mediasync/frameControl/MsVideoSyncFRAC.cpp:309:                    VSFRACLog(LOG_DEBUG_LEVEL1, "hwc dispmode: %s", vsf->dispinfo.modestr);
mediasync/frameControl/MsVideoSyncFRAC.cpp:323:                VSFRACLog(LOG_DEBUG_LEVEL1, "hwc dispmode: %s", vsf->dispinfo.modestr);
mediasync/frameControl/MsVideoSyncFRAC.cpp:325:            VSFRACLog(LOG_DEBUG_LEVEL1, "first hwcvsync:%" PRId64 ", vsyncinc:%d", vSyncTimeUs, vsyncInc);
mediasync/frameControl/MsVideoSyncFRAC.cpp:328:        VSFRACLog(LOG_ERR, "[%s]invalid hwc vsync info, vsynctime:%" PRId64 ", vsyncinc:%d", __func__, vSyncTimeUs, vsyncInc);
mediasync/frameControl/MsVideoSyncFRAC.cpp:338:        VSFRACLog(LOG_ERR, "[%s]no videoSyncFrac_priv", __func__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:345:    VSFRACLog(LOG_DEBUG_LEVEL2, "[%s] %s", __func__, getPatternStr(pattern));
mediasync/frameControl/MsVideoSyncFRAC.cpp:369:                    VSFRACLog(LOG_INFO, "[%s]4:1 pattern detected", __func__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:385:                VSFRACLog(LOG_INFO, "[%s]4:1 pattern broken", __func__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:398:            VSFRACLog(LOG_INFO, "[%s]4:1 pattern broken", __func__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:415:                VSFRACLog(LOG_INFO, "[%s]%d:%d pattern detected", __func__, factor1, factor2);
mediasync/frameControl/MsVideoSyncFRAC.cpp:422:        VSFRACLog(LOG_INFO, "[%s] pattern %s broken", __func__, getPatternStr(pattern));
mediasync/frameControl/MsVideoSyncFRAC.cpp:434:        VSFRACLog(LOG_ERR, "[%s]no videoSyncFrac_priv", __func__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:460:        VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]hwcvsync:%" PRId64 " vsyncnt:%" PRId64 ", realtime:%" PRId64 " mediatimeus:%" PRId64 " vsyncnt:%" PRId64 ", timediff=%" PRId64 ", repeatVsynCnt:%d",
mediasync/frameControl/MsVideoSyncFRAC.cpp:488:            VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]first hwcvsync:%" PRId64 " [%" PRId64 "-%" PRId64 "], diff=%" PRId64 ", hwcoffset:%" PRId64 "",
mediasync/frameControl/MsVideoSyncFRAC.cpp:499:            VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]first hwcvsync have not get,  %" PRId64 " not calculate pattern", __func__, mediaTimeUS);
mediasync/frameControl/MsVideoSyncFRAC.cpp:509:        VSFRACLog(LOG_ERR, "[%s]no videoSyncFrac_priv", __func__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:513:        VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]no pattern enable, return", __func__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:552:        VSFRACLog(LOG_ERR, "[%s]no videoSyncFrac_priv", __func__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:594:                VSFRACLog(LOG_DEBUG_LEVEL1, "need hold one sync !!");
mediasync/frameControl/MsVideoSyncFRAC.cpp:600:                VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]pattern %s hold one frame", __func__, getPatternStr(vsf->pattern_detected));
mediasync/frameControl/MsVideoSyncFRAC.cpp:602:                VSFRACLog(LOG_ERR, "[%s] pattern %s here may need escape one sync, holdFrame:%d, prevcnt:%d, %d, shouldcnt:%d, nowrepeatcnt:%d",
mediasync/frameControl/MsVideoSyncFRAC.cpp:624:                                VSFRACLog(LOG_DEBUG_LEVEL1, "[%s] little differ pattern %s No:%d, not seen should short frame", __func__,
mediasync/frameControl/MsVideoSyncFRAC.cpp:634:                                VSFRACLog(LOG_DEBUG_LEVEL1, "[%s] pattern %s No:%d will occur one short frame", __func__,
mediasync/frameControl/MsVideoSyncFRAC.cpp:639:                                VSFRACLog(LOG_ERR, "[%s]diff is too large[%d->%d], cannnot pull frame to keep pattern %s",
mediasync/frameControl/MsVideoSyncFRAC.cpp:646:                    VSFRACLog(LOG_DEBUG_LEVEL1, "[%s] pattern %s will hold frame", __func__, getPatternStr(vsf->pattern_detected));
mediasync/frameControl/MsVideoSyncFRAC.cpp:652:            VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]pattern %s need pull one frame", __func__, getPatternStr(vsf->pattern_detected));
mediasync/frameControl/MsVideoSyncFRAC.cpp:660:                VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]pattern %s pull one frame", __func__, getPatternStr(vsf->pattern_detected));
mediasync/frameControl/MsVideoSyncFRAC.cpp:662:                VSFRACLog(LOG_ERR, "[%s] pattern %s here may need freeze one sync, pullFrame:%d, prevcnt:%d, %d, shouldcnt:%d, nowrepeatcnt:%d",
mediasync/frameControl/MsVideoSyncFRAC.cpp:680:                        VSFRACLog(LOG_DEBUG_LEVEL1, "[%s] pattern %s No:%d will occur one freeze frame", __func__,
mediasync/frameControl/MsVideoSyncFRAC.cpp:685:                    VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]diff is too large[%d->%d], cannnot pull frame to pattern %s",
mediasync/frameControl/MsVideoSyncFRAC.cpp:696:        VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]pattern %s No:%d finnal repeatcnt:%d vsynccnt:%" PRId64 ", vsynctime[%" PRId64 "-%" PRId64 "], diffvsync:%" PRId64 ", diffnow:%" PRId64 "", __func__, getPatternStr(vsf->pattern_detected),
mediasync/frameControl/MsVideoSyncFRAC.cpp:711:            VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]no pattern may also adjust realtime, %" PRId64 "->%" PRId64 " diff:%" PRId64 "", __func__,
mediasync/frameControl/MsVideoSyncFRAC.cpp:718:        VSFRACLog(LOG_DEBUG_LEVEL1, "[%s] NO:%d finnal repeatcnt:%d vsynccnt:%" PRId64 ", vsynctime[%" PRId64 "-%" PRId64 "], diffvsync:%" PRId64 ", diffnow:%" PRId64 "", __func__,
mediasync/frameControl/MsVideoSyncFRAC.cpp:734:        VSFRACLog(LOG_ERR, "[%s]no videoSyncFrac_priv", __func__);
mediasync/frameControl/MsVideoSyncFRAC.cpp:738:    VSFRACLog(LOG_DEBUG_LEVEL1, "[%s] reset FRAC", __func__);
mediasync/frameControl/MsVideoSyncAdapterWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
mediasync/include/MediaSync.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
mediasync/include/MediaSync.h:115:#define PROPERTY_DEBUG_LOGT_FAT  "vendor.media.mediahal.mediasync.debug_fat"
mediasync/include/MediaSync.h:622:    mediasync_result audioDebugInfo(bool logPrintable,int64_t cur_vpts, int64_t cur_apts,int64_t realCurVpts,int64_t apts);
mediasync/include/MediaSync.h:623:    mediasync_result videoDebugInfo(bool logPrintable,int64_t vpts, int64_t cur_vpts,int64_t actualVpts);
mediasync/include/MediaSync.h:624:    mediasync_result checkVideoFreeRun(bool logPrintable,int64_t curSystime,int64_t actualVpts,bool* isVideoFreeRun);
mediasync/include/MediaSync.h:627:    void updateLogHead(int optional = 0);
mediasync/include/MediaSync.h:656:    char mLogHead[LOG_HEAD_LENGTH];
mediasync/include/MediaSync.h:706:    int mLogPrintInterval;
mediasync/include/MediaSync.h:709:    int64_t mStateStartLogTime;
mediasync/include/MediaSync.h:710:    int64_t mAudioQueueLogTime;
mediasync/include/MediaSync.h:711:    int64_t mAudioInfoLogTime;
mediasync/include/MediaSync.h:712:    int64_t mAudioPolicyLogTime;
mediasync/include/MediaSync.h:713:    int64_t mAudioFreerunLogTime;
mediasync/include/MediaSync.h:714:    int64_t mVideoQueueLogTime;
mediasync/include/MediaSync.h:715:    int64_t mVideoInfoLogTime;
mediasync/include/MediaSync.h:716:    int64_t mVideoPolicyLogTime;
mediasync/include/MediaSync.h:717:    int64_t mVideoFreerunLogTime;
mediasync/include/MediaSync.h:718:    int64_t mMediaListLogTime;
mediasync/include/MediaSync.h:796:    uint32_t mDebugProcFrameCount;//just used for debug in logHead
mediasync/include/MediaSync.h:797:    uint32_t mDebugQueueFrameCount;//just used for debug in logHead
mediasync/include/MediaSyncInterface.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
mediasync/include/MediaSyncClock.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
mediasync/include/MediaSyncClock.h:14:#define LOG_HEAD_LENGTH (60)
mediasync/include/MediaSyncClock.h:81:        void setLogHead(char* head);
mediasync/include/MediaSyncClock.h:87:        char mLogHead[LOG_HEAD_LENGTH];
mediasync/msUtil/msUtil.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
mediasync/msUtil/msUtil.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
mediasync/msUtil/msUtil.cpp:10:#include <utils/Log.h>
mediasync/msUtil/msUtil.cpp:16:        ALOGE("input parameter was NULL, propGetInt failed!");
mediasync/msUtil/msUtil.cpp:22:        ALOGI("%s set = %d\n", str, *variable);
mediasync/msUtil/msUtil.cpp:25:        ALOGI("%s is not set used def = %d\n", str, *variable);
mediasync/msUtil/msUtil.cpp:31:        ALOGE("input parameter was NULL, propGetFloat failed!");
mediasync/msUtil/msUtil.cpp:37:        ALOGI("%s set = %f\n", str, *variable);
mediasync/msUtil/msUtil.cpp:40:        ALOGI("%s is not set used def = %f\n", str, *variable);
test/AmTsplayerAutoTest/AmTsPlayerAutoTest.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
test/AmTsplayerAutoTest/AmTsPlayerAutoTest.cpp:42:#include <amlogic/am_gralloc_ext.h>
test/AmTsplayerAutoTest/AmTsPlayerAutoTest.cpp:107:     int    enablelog;
test/AmTsplayerAutoTest/AmTsPlayerAutoTest.cpp:220:        sevinfo.enablelog = 0;
test/AmTsplayerAutoTest/AmTsPlayerAutoTestSystemLib.go:51:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext")
test/AmTsplayerAutoTest/AmTsPlayerAutoTestSystemLib.go:55:        includePath = append(includePath,"hardware/amlogic/gralloc")
test/AmTsplayerAutoTest/AmTsPlayerAutoTestSystemLib.go:57:             includePath = append(includePath,"vendor/amlogic/common/frameworks/services/systemcontrol","vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include")
test/AmTsplayerAutoTest/AmTsPlayerAutoTestSystemLib.go:59:             includePath = append(includePath,"vendor/amlogic/common/frameworks/services/systemcontrol/aidl","vendor/amlogic/common/frameworks/services/systemcontrol/aidl/PQ/include")
test/AmTsplayerAutoTest/AmTsPlayerAutoTestSystemLib.go:73:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext@2")
test/AmTsplayerAutoTest/AmTsPlayerAutoTestSystemLib.go:77:        includePath = append(includePath,"hardware/amlogic/gralloc")
test/AmTsplayerAutoTest/systemlib_u.go.in:26:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext")
test/AmTsplayerAutoTest/systemlib_u.go.in:30:        includePath = append(includePath,"vendor/amlogic/common/frameworks/services/systemcontrol","vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include","hardware/amlogic/gralloc")
test/AmTsplayerAutoTest/systemlib_u.go.in:43:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext@2")
test/AmTsplayerAutoTest/systemlib_u.go.in:47:        includePath = append(includePath,"hardware/amlogic/gralloc")
test/AmTsplayerAutoTest/systemlib.go.in:26:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext")
test/AmTsplayerAutoTest/systemlib.go.in:30:        includePath = append(includePath,"vendor/amlogic/common/frameworks/services/systemcontrol","vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include","hardware/amlogic/gralloc")
test/AmTsplayerAutoTest/systemlib.go.in:43:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext@2")
test/AmTsplayerAutoTest/systemlib.go.in:47:        includePath = append(includePath,"hardware/amlogic/gralloc")
test/AmTsplayerAutoTest/Android.bp:8:    // all of the 'license_kinds' from "vendor_amlogic_common_license"
test/AmTsplayerAutoTest/Android.bp:16:    default_applicable_licenses: ["vendor_amlogic_common_license"],
test/AmTsplayerAutoTest/AmTsPlayerAutoTestAndroidVersion.go:48:        p.Include_dirs = append(p.Include_dirs, "vendor/amlogic/common/media_hal/AmTsplayer/include")
test/Android.mk.in:10:		liblog \
test/MediaProxyTest/MediaProxyWrapperTest.cpp:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
test/MediaProxyTest/MediaProxyWrapperTest.cpp:9:#define LOG_NDEBUG 0
test/MediaProxyTest/MediaProxyWrapperTest.cpp:10:#define LOG_TAG "MediaProxyWrapperTest"
test/MediaProxyTest/MediaProxyWrapperTest.cpp:13:#include <utils/Log.h>
test/MediaProxyTest/MediaProxyWrapperTest.cpp:22:#include "log_debug.h"
test/MediaProxyTest/MediaProxyWrapperTest.cpp:25:#define MPLog(level, f,s...) VDLog(level, f, ##s)
test/MediaProxyTest/MediaProxyWrapperTest.cpp:55:            MPLog(LOG_ERR, "not find initialize symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:60:            MPLog(LOG_ERR, "not find registerMsgType symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:65:            MPLog(LOG_ERR, "not find readData symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:70:            MPLog(LOG_ERR, "not find openDev symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:75:            MPLog(LOG_ERR, "not find connectDev symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:80:            MPLog(LOG_ERR, "not find initialize symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:85:            MPLog(LOG_ERR, "not find poll symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:90:            MPLog(LOG_ERR, "not find getBufferInfo symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:96:            MPLog(LOG_ERR, "not find setFifoLen symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:101:            MPLog(LOG_ERR, "not find setVdecId symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:104:        MPLog(LOG_ERR, "dlopen libmediaproxy_consumer.so error: %s", dlerror());
test/MediaProxyTest/MediaProxyWrapperTest.cpp:138:            MPLog(LOG_ERR, "not find initialize symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:143:            MPLog(LOG_ERR, "not find writeData symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:148:            MPLog(LOG_ERR, "not find openDev symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:153:            MPLog(LOG_ERR, "not find connectDev symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:158:            MPLog(LOG_ERR, "not find initialize symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:163:            MPLog(LOG_ERR, "not find injectBufferInfo symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:168:            MPLog(LOG_ERR, "not find setFifoLen symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:173:            MPLog(LOG_ERR, "not find setVdecId symbol, may need check!");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:176:        MPLog(LOG_ERR, "dlopen libmediaproxy_producer.so error: %s", dlerror());
test/MediaProxyTest/MediaProxyWrapperTest.cpp:199:            MPLog(LOG_ERR, "producer symbol not load normal, need check");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:207:            MPLog(LOG_ERR, "consumer symbol not load normal, need check");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:212:        MPLog(LOG_ERR, "error role type %d", type);
test/MediaProxyTest/MediaProxyWrapperTest.cpp:217:        MPLog(LOG_ERR, "%s role %d initialize failed", mName, type);
test/MediaProxyTest/MediaProxyWrapperTest.cpp:245:            MPLog(LOG_DEBUG_LEVEL2, "readData timeout");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:249:        MPLog(LOG_ERR, "readData symbol error,fd:%d,readData:%p", mProxy_fd, gMediaConsumer.readData);
test/MediaProxyTest/MediaProxyWrapperTest.cpp:258:            MPLog(LOG_ERR, "writeData error");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:261:        MPLog(LOG_ERR, "writeData symbol error,fd:%d,readData:%p", mProxy_fd, gMediaProducer.writeData);
test/MediaProxyTest/MediaProxyWrapperTest.cpp:271:        MPLog(LOG_ERR, "registermsgtype error");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:283:            MPLog(LOG_ERR, "setVdecIdTest error");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:290:            MPLog(LOG_ERR, "setVdecIdTest error");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:304:            MPLog(LOG_ERR, "setFifoLenTest error");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:311:            MPLog(LOG_ERR, "setFifoLenTest error");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:324:            MPLog(LOG_ERR, "injectBufferInfo error");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:328:        MPLog(LOG_ERR, "injectBufferInfo error not producer");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:338:            MPLog(LOG_ERR, "getBufferInfo error");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:342:        MPLog(LOG_ERR, "getBufferInfo error not consumer");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:358:            MPLog(LOG_ERR, "poll error");
test/MediaProxyTest/MediaProxyWrapperTest.cpp:362:        MPLog(LOG_ERR, "poll error type is consumer");
test/MediaProxyTest/Android.mk:13:LOCAL_SHARED_LIBRARIES += liblog
test/MediaProxyTest/Android.mk:31:LOCAL_SHARED_LIBRARIES += liblog
test/MediaProxyTest/MediaProxyWrapperTest.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
test/MediaProxyTest/mediaproxytest.c:1:#define LOG_TAG "mediaproxytest"
test/MediaProxyTest/mediaproxytest.c:10:#include <utils/Log.h>
test/MediaProxyTest/mediaproxytest.c:17:        ALOGD("processData MEDIA_VDEC_CONNECTED decoderId =%d,vdecConnect =%d",
test/MediaProxyTest/mediaproxytest.c:21:        ALOGD("processData MEDIA_VIDEO_FIRST_OUT_FRAME_INFO decoderId =%d, width=%d",
test/MediaProxyTest/mediaproxytest.c:23:        ALOGD("processData MEDIA_VIDEO_FIRST_OUT_FRAME_INFO decoderId =%d,color_primaries =%d, matrix_coeff =%d",
test/MediaProxyTest/mediaproxytest.c:26:            ALOGD("processData MEDIA_VIDEO_FIRST_OUT_FRAME_INFO decoderId =%d, afd_data =%x",
test/MediaProxyTest/mediaproxytest.c:31:        ALOGD("processData MEDIA_VIDEO_STATISTIC_INFO decoderId =%d, decodedFrames=%d, errFrames=%d, dropFrames=%d",
test/MediaProxyTest/mediaproxytest.c:36:        ALOGD("processData MEDIA_VIDEO_INPUT_INFO decoderId =%d, bitStreamId = %llu",
test/MediaProxyTest/mediaproxytest.c:40:        ALOGD("processData MEDIA_VIDEO_OUTPUT_INFO decoderId =%d, bitStreamId = %llu",
test/MediaProxyTest/mediaproxytest.c:44:        ALOGE("unknown message type");
test/MediaProxyTest/mediaproxytest.c:62:    ALOGD("start dlopen libmediaproxy_consumer.so");
test/MediaProxyTest/mediaproxytest.c:71:        ALOGE("unable to dlopen libmediaproxy_consumer.so: %s", dlerror());
test/MediaProxyTest/mediaproxytest.c:76:        ALOGE("can not get init %s", dlerror());
test/MediaProxyTest/mediaproxytest.c:83:        ALOGE("open device failed or register consumer failed, fd =%d, %s", fd, dlerror());
test/MediaProxyTest/mediaproxytest.c:90:        ALOGE("can not get registerMsgType %s", dlerror());
test/MediaProxyTest/mediaproxytest.c:101:        ALOGE("have not found read or destroy %s", dlerror());
test/MediaProxyTest/mediaproxytest.c:106:    ALOGD("dlopen libmediaproxy_consumer.so done");
test/MediaProxyTest/mediaproxytest.c:109:        ALOGD("reading data");
test/MediaProxyTest/mediaproxytest.c:115:            ALOGE("read data failed, err = %s", strerror(errno));
test/MediaProxyTest/proxy_wrapper_test.cpp:18:#include "log_debug.h"
test/MediaProxyTest/proxy_wrapper_test.cpp:38:            ALOGE("pthread_create failed (err=%d)", ret);
test/MediaProxyTest/proxy_wrapper_test.cpp:41:        ALOGE("pthread_create start (id=%d)name(%s)", id, name);
test/MediaProxyTest/proxy_wrapper_test.cpp:76:                ALOGE("consumerThread[%s][%d] get_id:%d framecnt:%lld getframecnt:%lld \r\n",threadarg->name, threadarg->id,get_id, framecnt, getframecnt);
test/MediaProxyTest/proxy_wrapper_test.cpp:80:                //         ALOGE("[%d]:%c \r\n", i, value1[i]);
test/MediaProxyTest/proxy_wrapper_test.cpp:82:                //         ALOGE("[%d]:%c ", i, value1[i]);
test/MediaProxyTest/proxy_wrapper_test.cpp:122:                ALOGE("producerThread[%s] set_id:%d framecnt:%lld  \r\n",threadarg->name, threadarg->id, framecnt);
test/MediaProxyTest/proxy_wrapper_test.cpp:146:    ALOGE("test start instnum(id=%d)argc:%d(%s)", instnum, argc, pname);
test/MediaProxyTest/proxy_wrapper_test.cpp:167:    ALOGE("test start instnum(id=%d)argc:%d(%s)", instnum, argc, pname);
test/MediaProxyTest/proxy_wrapper_test.cpp:175:        ALOGE("test start new (id=%d)", id);
test/MediaProxyTest/proxy_wrapper_test.cpp:182:    ALOGE("prod test start instnum(id=%d)", instnum);
test/MediaProxyTest/proxy_wrapper_test.cpp:188:        ALOGE("test start p new (id=%d)", id);
test/AmTsplayerTest/AmTsPlayerTest.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
test/AmTsplayerTest/AmTsPlayerTest.cpp:54:            TLog("[evt] AM_TSPLAYER_EVENT_TYPE_VIDEO_CHANGED: %d x %d @%d [%d]\n",
test/AmTsplayerTest/AmTsPlayerTest.cpp:182:                    TLog("file eof\n");
test/AmTsplayerTest/AmTsPlayerTest.cpp:190:                //TLog("size(%ld), pos %ld\n", fsize, pos);
test/AmTsplayerTest/AmTsPlayerTest.cpp:213:        TLog("TearDown\n");
test/AmTsplayerTest/AmTsPlayerTest.cpp:695:    TLog("=========VINFO=========\n");
test/AmTsplayerTest/AmTsPlayerTest.cpp:696:    TLog("width: %d\n", vinfo.width);
test/AmTsplayerTest/AmTsPlayerTest.cpp:697:    TLog("height: %d\n", vinfo.height);
test/AmTsplayerTest/AmTsPlayerTest.cpp:698:    TLog("framerate: %d\n", vinfo.framerate);
test/AmTsplayerTest/AmTsPlayerTest.cpp:699:    TLog("bitrate: %d\n", vinfo.bitrate);
test/AmTsplayerTest/AmTsPlayerTest.cpp:700:    TLog("ratio64: %lld\n", vinfo.ratio64);
test/AmTsplayerTest/AmTsPlayerTest.cpp:701:    TLog("=========VINFO=========\n");
test/AmTsplayerTest/AmTsPlayerTest.cpp:705:    TLog("=========VSTAT=========\n");
test/AmTsplayerTest/AmTsPlayerTest.cpp:706:    TLog("QOS.num: %d\n", vstat.qos.num);
test/AmTsplayerTest/AmTsPlayerTest.cpp:707:    TLog("QOS.type: %d\n", vstat.qos.type);
test/AmTsplayerTest/AmTsPlayerTest.cpp:708:    TLog("QOS.size: %d\n", vstat.qos.size);
test/AmTsplayerTest/AmTsPlayerTest.cpp:709:    TLog("QOS.pts: %d\n", vstat.qos.pts);
test/AmTsplayerTest/AmTsPlayerTest.cpp:710:    TLog("QOS.max_qp: %d\n", vstat.qos.max_qp);
test/AmTsplayerTest/AmTsPlayerTest.cpp:711:    TLog("QOS.avg_qp: %d\n", vstat.qos.avg_qp);
test/AmTsplayerTest/AmTsPlayerTest.cpp:712:    TLog("QOS.min_qp: %d\n", vstat.qos.min_qp);
test/AmTsplayerTest/AmTsPlayerTest.cpp:713:    TLog("QOS.max_skip: %d\n", vstat.qos.max_skip);
test/AmTsplayerTest/AmTsPlayerTest.cpp:714:    TLog("QOS.avg_skip: %d\n", vstat.qos.avg_skip);
test/AmTsplayerTest/AmTsPlayerTest.cpp:715:    TLog("QOS.min_skip: %d\n", vstat.qos.min_skip);
test/AmTsplayerTest/AmTsPlayerTest.cpp:716:    TLog("QOS.max_mv: %d\n", vstat.qos.max_mv);
test/AmTsplayerTest/AmTsPlayerTest.cpp:717:    TLog("QOS.min_mv: %d\n", vstat.qos.min_mv);
test/AmTsplayerTest/AmTsPlayerTest.cpp:718:    TLog("QOS.avg_mv: %d\n", vstat.qos.avg_mv);
test/AmTsplayerTest/AmTsPlayerTest.cpp:719:    TLog("QOS.decode_buffer: %d\n", vstat.qos.decode_buffer);
test/AmTsplayerTest/AmTsPlayerTest.cpp:721:    TLog("decode_time_cost: %d\n", vstat.decode_time_cost);
test/AmTsplayerTest/AmTsPlayerTest.cpp:722:    TLog("frame_width: %d\n", vstat.frame_width);
test/AmTsplayerTest/AmTsPlayerTest.cpp:723:    TLog("frame_height: %d\n", vstat.frame_height);
test/AmTsplayerTest/AmTsPlayerTest.cpp:724:    TLog("frame_rate: %d\n", vstat.frame_rate);
test/AmTsplayerTest/AmTsPlayerTest.cpp:725:    TLog("bit_depth_luma: %d\n", vstat.bit_depth_luma);
test/AmTsplayerTest/AmTsPlayerTest.cpp:726:    TLog("frame_dur: %d\n", vstat.frame_dur);
test/AmTsplayerTest/AmTsPlayerTest.cpp:727:    TLog("bit_depth_chroma: %d\n", vstat.bit_depth_chroma);
test/AmTsplayerTest/AmTsPlayerTest.cpp:728:    TLog("error_count: %d\n", vstat.error_count);
test/AmTsplayerTest/AmTsPlayerTest.cpp:729:    TLog("status: %d\n", vstat.status);
test/AmTsplayerTest/AmTsPlayerTest.cpp:730:    TLog("frame_count: %d\n", vstat.frame_count);
test/AmTsplayerTest/AmTsPlayerTest.cpp:731:    TLog("error_frame_count: %d\n", vstat.error_frame_count);
test/AmTsplayerTest/AmTsPlayerTest.cpp:732:    TLog("drop_frame_count: %d\n", vstat.drop_frame_count);
test/AmTsplayerTest/AmTsPlayerTest.cpp:733:    TLog("total_data: %llu\n", vstat.total_data);
test/AmTsplayerTest/AmTsPlayerTest.cpp:734:    TLog("double_write_mode: %d\n", vstat.double_write_mode);
test/AmTsplayerTest/AmTsPlayerTest.cpp:735:    TLog("offset: %d\n", vstat.offset);
test/AmTsplayerTest/AmTsPlayerTest.cpp:736:    TLog("ratio_control: %d\n", vstat.ratio_control);
test/AmTsplayerTest/AmTsPlayerTest.cpp:737:    TLog("vf_type: %d\n", vstat.vf_type);
test/AmTsplayerTest/AmTsPlayerTest.cpp:738:    TLog("signal_type: %d\n", vstat.signal_type);
test/AmTsplayerTest/AmTsPlayerTest.cpp:739:    TLog("pts: %d\n", vstat.pts);
test/AmTsplayerTest/AmTsPlayerTest.cpp:740:    TLog("pts_us64: %llu\n", vstat.pts_us64);
test/AmTsplayerTest/AmTsPlayerTest.cpp:741:    TLog("=========VSTAT=========\n");
test/AmTsplayerTest/AmTsPlayerTest.cpp:750:    TLog("dtime %lld\n", dtime1);
test/AmTsplayerTest/AmTsPlayerTest.cpp:753:    TLog("dtime %lld\n", dtime1);
test/AmTsplayerTest/AmTsPlayerTest.cpp:756:    TLog("dtime %lld\n", dtime1);
test/AmTsplayerTest/AmTsPlayerTest.cpp:761:    TLog("dtime2 %lld, vpts %lld, apts %lld\n", dtime2, vpts, apts);
test/AmTsplayerTest/AmTsPlayerTest.cpp:770:        TLog("QOS.pts: %d\n", vstat.qos.pts);
test/AmTsplayerTest/AmTsPlayerTest.cpp:771:        TLog("pts: %d\n", vstat.pts);
test/AmTsplayerTest/AmTsPlayerTest.cpp:772:        TLog("pts_us64: %llu\n", vstat.pts_us64);
test/AmTsplayerTest/AmTsPlayerTest.cpp:787:    TLog("=========AINFO=========\n");
test/AmTsplayerTest/AmTsPlayerTest.cpp:788:    TLog("sample_rate: %d\n", ainfo.sample_rate);
test/AmTsplayerTest/AmTsPlayerTest.cpp:789:    TLog("channels: %d\n", ainfo.channels);
test/AmTsplayerTest/AmTsPlayerTest.cpp:790:    TLog("channel_mask: %d\n", ainfo.channel_mask);
test/AmTsplayerTest/AmTsPlayerTest.cpp:791:    TLog("bitrate: %d\n", ainfo.bitrate);
test/AmTsplayerTest/AmTsPlayerTest.cpp:792:    TLog("=========AINFO=========\n");
test/AmTsplayerTest/AmTsPlayerTest.cpp:793:    TLog("=========ASTAT=========\n");
test/AmTsplayerTest/AmTsPlayerTest.cpp:794:    TLog("frame_count: %d\n", astat.frame_count);
test/AmTsplayerTest/AmTsPlayerTest.cpp:795:    TLog("error_frame_count: %d\n", astat.error_frame_count);
test/AmTsplayerTest/AmTsPlayerTest.cpp:796:    TLog("drop_frame_count: %d\n", astat.drop_frame_count);
test/AmTsplayerTest/AmTsPlayerTest.cpp:797:    TLog("=========ASTAT=========\n");
test/AmTsplayerTest/AmTsPlayerTest.cpp:1448:    printf("-e | --amute        analog mute\n");
test/AmTsplayerTest/mpeg2string.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
test/AmTsplayerTest/AmTsPlayerSession.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
test/AmTsplayerTest/AmTsPlayerSession.cpp:84:    //TLog("AmTsPlayerSession::AVSync::AVSync\n");
test/AmTsplayerTest/AmTsPlayerSession.cpp:88:    //TLog("~AVSync\n");
test/AmTsplayerTest/AmTsPlayerSession.cpp:127:    //TLog("AmTsPlayerSession::Control::Control\n");
test/AmTsplayerTest/AmTsPlayerSession.cpp:131:    //TLog("~Control\n");
test/AmTsplayerTest/AmTsPlayerSession.cpp:157:    //TLog("AmTsPlayerSession::Video::Video\n");
test/AmTsplayerTest/AmTsPlayerSession.cpp:161:    //TLog("~Video\n");
test/AmTsplayerTest/AmTsPlayerSession.cpp:229:    //TLog("AmTsPlayerSession::Audio::Audio\n");
test/AmTsplayerTest/AmTsPlayerSession.cpp:233:    //TLog("~Audio\n");
test/AmTsplayerTest/AmTsPlayerSession.cpp:257:            bool_t analog_mute,
test/AmTsplayerTest/AmTsPlayerSession.cpp:259:    return AmTsPlayer_setAudioMute(mSession, analog_mute, digital_mute);
test/AmTsplayerTest/AmTsPlayerSession.cpp:263:            bool_t *analog_unmute,
test/AmTsplayerTest/AmTsPlayerSession.cpp:265:    return AmTsPlayer_getAudioMute(mSession, analog_unmute, digital_unmute);
test/AmTsplayerTest/AmTsPlayerSession.cpp:307:    //TLog("AmTsPlayerSession::AD::AD\n");
test/AmTsplayerTest/AmTsPlayerSession.cpp:311:    //TLog("~AD\n");
test/AmTsplayerTest/AmTsPlayerSession.cpp:378:            bool_t analog_mute,
test/AmTsplayerTest/AmTsPlayerSession.cpp:380:    UNUSED(analog_mute);
test/AmTsplayerTest/AmTsPlayerSession.cpp:383:    //return AmTsPlayer_setADMute(mSession, analog_mute, digital_mute);
test/AmTsplayerTest/AmTsPlayerSession.cpp:387:            bool_t* analog_unmute,
test/AmTsplayerTest/AmTsPlayerSession.cpp:389:    UNUSED(analog_unmute);
test/AmTsplayerTest/AmTsPlayerSession.cpp:392:    //return AmTsPlayer_getADMute(mSession, analog_unmute, digital_unmute);
test/AmTsplayerTest/AmTsPlayerSession.cpp:425:    //TLog("AmTsPlayerSession::Subtitle::Subtitle\n");
test/AmTsplayerTest/AmTsPlayerSession.cpp:429:    //TLog("~Subtitle\n");
test/AmTsplayerTest/gtest-1.10.0/.gitignore:10:bazel-testlogs
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:198:    GTEST_LOG_(FATAL) << "Unable to open file \"" << output_file << "\"";
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:414:// inserted to report ether an error or a log message.
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:525:    GTEST_LOG_(ERROR) << "Unknown type parameterized test suit '"
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:992:  // http://analogous.blogspot.com/2005/04/epoch.html
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:2766:  GTEST_LOG_(ERROR) << FormatFileLocation(code_location.file.c_str(),
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:3779:    GTEST_LOG_(FATAL) << "XML output file may not be null";
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:4216:    GTEST_LOG_(FATAL) << "JSON output file may not be null";
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:4574:    GTEST_LOG_(WARNING) << "stream_result_to: getaddrinfo() failed: "
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:4595:    GTEST_LOG_(WARNING) << "stream_result_to: failed to connect to "
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:4693:        GTEST_LOG_(ERROR) << "Failed to remove premature exit filepath \""
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:4908:// properties logged outside of individual test suites.
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:5065:  // process. In either case the user does not want to see pop-up dialogs
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:5076:    // _abort() can show a dialog with a warning message.  This forces the
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:5082:    // In the debug version, Visual Studio pops up a separate dialog
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:5084:    // this dialog or it will pop up for every EXPECT/ASSERT_DEATH statement
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:5094:    // for these assertions is to pop up a dialog and wait for user input.
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:5260:    GTEST_LOG_(WARNING) << "WARNING: unrecognized output format \""
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:5276:      GTEST_LOG_(WARNING) << "unrecognized streaming target \"" << target
test/AmTsplayerTest/gtest-1.10.0/src/gtest.cc:6154:    GTEST_LOG_(FATAL) << "Unable to open file \"" << GTEST_FLAG(flagfile)
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:343:// message from the death test child process and log it with the FATAL
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:359:    GTEST_LOG_(FATAL) << error.GetString();
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:362:    GTEST_LOG_(FATAL) << "Error while reading death test internal: "
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:433:  virtual std::string GetErrorLogs();
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:490:        GTEST_LOG_(FATAL) << "Death test child process reported "
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:495:    GTEST_LOG_(FATAL) << "Read from death test child process failed: "
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:502:std::string DeathTestImpl::GetErrorLogs() {
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:531:// This makes distinguishing death test output lines from regular log lines
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:573:  const std::string error_message = GetErrorLogs();
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:612:      GTEST_LOG_(FATAL)
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:783:  // Flush the log buffers since the log streams are shared with the child.
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:784:  FlushInfoLog();
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:824:  std::string GetErrorLogs() override;
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:986:  // Flush the log buffers since the log streams are shared with the child.
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:987:  FlushInfoLog();
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:1064:std::string FuchsiaDeathTest::GetErrorLogs() {
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:1122:    GTEST_LOG_(WARNING) << DeathTestThreadWarning(thread_count);
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:1130:  // When we fork the process below, the log file buffers are copied, but the
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:1131:  // file descriptors are shared.  We flush all log files here so that closing
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:1136:  // thread writes to the log file.
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:1137:  FlushInfoLog();
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:1145:    // Redirects all logging to stderr in the child process to prevent
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:1146:    // concurrent writes to the log files.  We capture stderr in the parent
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:1147:    // process and append the child process' output to a log.
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:1148:    LogToStderr();
test/AmTsplayerTest/gtest-1.10.0/src/gtest-death-test.cc:1449:  FlushInfoLog();
test/AmTsplayerTest/gtest-1.10.0/src/gtest-internal-inl.h:1100:        GTEST_LOG_(WARNING)
test/AmTsplayerTest/gtest-1.10.0/src/gtest-port.cc:1050:GTestLog::GTestLog(GTestLogSeverity severity, const char* file, int line)
test/AmTsplayerTest/gtest-1.10.0/src/gtest-port.cc:1061:GTestLog::~GTestLog() {
test/AmTsplayerTest/gtest-1.10.0/src/gtest-port.cc:1118:      GTEST_LOG_(WARNING)
test/AmTsplayerTest/gtest-1.10.0/src/gtest-port.cc:1144:      GTEST_LOG_(FATAL) << "Failed to open tmp file " << filename_
test/AmTsplayerTest/gtest-1.10.0/src/gtest-port.cc:1170:    GTEST_LOG_(FATAL) << "Only one " << stream_name
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:216:// Logging:
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:217://   GTEST_LOG_()   - logs messages at the specified severity level.
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:218://   LogToStderr()  - directs all log messages to stderr.
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:219://   FlushInfoLog() - flushes informational log messages.
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:588:// pops up a dialog window that cannot be suppressed programmatically.
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:636:// used.  This is useful when all interesting logic happens inside the
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:937:// Defines logging utilities:
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:938://   GTEST_LOG_(severity) - logs messages at the specified severity level. The
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:940://   LogToStderr()  - directs all log messages to stderr.
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:941://   FlushInfoLog() - flushes informational log messages.
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:943:enum GTestLogSeverity {
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:950:// Formats log entry severity, provides a stream object for streaming the
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:951:// log message, and terminates the message with a newline when going out of
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:953:class GTEST_API_ GTestLog {
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:955:  GTestLog(GTestLogSeverity severity, const char* file, int line);
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:958:  ~GTestLog();
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:963:  const GTestLogSeverity severity_;
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:965:  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestLog);
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:968:#if !defined(GTEST_LOG_)
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:970:# define GTEST_LOG_(severity) \
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:971:    ::testing::internal::GTestLog(::testing::internal::GTEST_##severity, \
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:974:inline void LogToStderr() {}
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:975:inline void FlushInfoLog() { fflush(nullptr); }
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:977:#endif  // !defined(GTEST_LOG_)
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:999:      GTEST_LOG_(FATAL) << "Condition " #condition " failed. "
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:1009:    GTEST_LOG_(FATAL) << #posix_call << "failed with error " \
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-port.h:1396:  // Per https://blogs.msdn.microsoft.com/oldnewthing/20040223-00/?p=40503,
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-internal.h:995:// This helper reduces code bloat.  If we instead put its logic inside
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-internal.h:1035:// This helper reduces code bloat.  If we instead put its logic inside
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-internal.h:1203:// Analog to std::tuple but with different tradeoffs.
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/custom/README.md:30:### Logging:
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/custom/README.md:32:*   `GTEST_LOG_(severity)`
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/custom/README.md:34:*   Functions `LogToStderr()` and `FlushInfoLog()` have to be provided too.
test/AmTsplayerTest/gtest-1.10.0/include/gtest/internal/gtest-death-test-internal.h:99:  // test is encountered.  EXECUTE means that the death test logic should
test/AmTsplayerTest/gtest-1.10.0/include/gtest/gtest.h:47:// registration from Barthelemy Dagenais' (barthelemy@prologique.com)
test/AmTsplayerTest/gtest-1.10.0/include/gtest/gtest.h:96:// and logs them as failures.
test/AmTsplayerTest/gtest-1.10.0/include/gtest/gtest.h:449:  // Logs a property for the current test, test suite, or for the entire
test/AmTsplayerTest/gtest-1.10.0/include/gtest/gtest.h:457:  // SetUpTestSuite or TearDownTestSuite are logged as attributes of the
test/AmTsplayerTest/gtest-1.10.0/include/gtest/gtest.h:482:  // A sub-class must implement this to define the test logic.
test/AmTsplayerTest/gtest-1.10.0/include/gtest/gtest.h:1373:  // properties logged outside of individual test suites.
test/AmTsplayerTest/gtest-1.10.0/include/gtest/gtest-death-test.h:48:// meaning that the child process will execute the test logic immediately
test/AmTsplayerTest/gtest-1.10.0/include/gtest/gtest-death-test.h:220:// LOG(DFATAL) macro using the following style:
test/AmTsplayerTest/gtest-1.10.0/include/gtest/gtest-death-test.h:226://   LOG(DFATAL) << "death";
test/AmTsplayerTest/gtest-1.10.0/include/gtest/gtest-death-test.h:245:// mode, usually due to a DCHECK or LOG(DFATAL), but returns the
test/AmTsplayerTest/gtest-1.10.0/include/gtest/gtest-death-test.h:314:      GTEST_LOG_(WARNING) \
test/AmTsplayerTest/gtest-1.10.0/.travis.yml:19:      install: ./ci/install-linux.sh && ./ci/log-config.sh
test/AmTsplayerTest/gtest-1.10.0/.travis.yml:24:      install: ./ci/install-linux.sh && ./ci/log-config.sh
test/AmTsplayerTest/gtest-1.10.0/.travis.yml:37:      env: BUILD_TYPE=Release VERBOSE=1 CXX_FLAGS=-std=c++11 HOMEBREW_LOGS=~/homebrew-logs HOMEBREW_TEMP=~/homebrew-temp
test/AmTsplayerTest/gtest-1.10.0/.travis.yml:40:      env: BUILD_TYPE=Release VERBOSE=1 CXX_FLAGS=-std=c++11 HOMEBREW_LOGS=~/homebrew-logs HOMEBREW_TEMP=~/homebrew-temp
test/AmTsplayerTest/gtest-1.10.0/.travis.yml:47:  - ./ci/log-config.sh
test/AmTsplayerTest/h264string.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
test/AmTsplayerTest/AmTsPlayerStub.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
test/AmTsplayerTest/AmTsPlayerStub.cpp:504: *\inparam:      If analog mute or unmute .
test/AmTsplayerTest/AmTsPlayerStub.cpp:508:am_tsplayer_result  AmTsPlayer_setAudioMute(am_tsplayer_handle Handle, bool_t analog_mute, bool_t digital_mute)
test/AmTsplayerTest/AmTsPlayerStub.cpp:511:    UNUSED(analog_mute);
test/AmTsplayerTest/AmTsPlayerStub.cpp:520: *\outparam:     If analog mute or unmute .
test/AmTsplayerTest/AmTsPlayerStub.cpp:524:am_tsplayer_result  AmTsPlayer_getAudioMute(am_tsplayer_handle Handle, bool_t *analog_unmute, bool_t *digital_unmute)
test/AmTsplayerTest/AmTsPlayerStub.cpp:527:    UNUSED(analog_unmute);
test/AmTsplayerTest/AmTsPlayerStub.cpp:785: *\inparam:      If analog mute or unmute .
test/AmTsplayerTest/AmTsPlayerStub.cpp:789:am_tsplayer_result  AmTsPlayer_setADMute(am_tsplayer_handle Handle, bool_t analog_mute, bool_t digital_mute)
test/AmTsplayerTest/AmTsPlayerStub.cpp:792:    UNUSED(analog_mute);
test/AmTsplayerTest/AmTsPlayerStub.cpp:801: *\outparam:     If analog mute or unmute .
test/AmTsplayerTest/AmTsPlayerStub.cpp:805:am_tsplayer_result  AmTsPlayer_getADMute(am_tsplayer_handle Handle, bool_t analog_unmute, bool_t digital_unmute)
test/AmTsplayerTest/AmTsPlayerStub.cpp:808:    UNUSED(analog_unmute);
test/AmTsplayerTest/include/AmTsPlayerTest.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
test/AmTsplayerTest/include/AmTsPlayer.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
test/AmTsplayerTest/include/AmTsPlayer.h:804: *\inparam:      If analog mute or unmute .
test/AmTsplayerTest/include/AmTsPlayer.h:808:am_tsplayer_result  AmTsPlayer_setAudioMute(am_tsplayer_handle Hadl, bool_t analog_mute, bool_t digital_mute);
test/AmTsplayerTest/include/AmTsPlayer.h:813: *\outparam:     If analog mute or unmute .
test/AmTsplayerTest/include/AmTsPlayer.h:817:am_tsplayer_result  AmTsPlayer_getAudioMute(am_tsplayer_handle Hadl, bool_t *analog_unmute, bool_t *digital_unmute);
test/AmTsplayerTest/include/AmTsPlayerSession.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
test/AmTsplayerTest/include/AmTsPlayerSession.h:18:#define TLog(f, s...) \
test/AmTsplayerTest/include/AmTsPlayerSession.h:127:                            bool_t analog_mute,
test/AmTsplayerTest/include/AmTsPlayerSession.h:130:                            bool_t *analog_unmute,
test/AmTsplayerTest/include/AmTsPlayerSession.h:175:                            bool_t analog_mute,
test/AmTsplayerTest/include/AmTsPlayerSession.h:178:                            bool_t* analog_unmute,
test/AmTsplayerTest/h265string.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
test/Android.bp:31:        "hardware/amlogic/gralloc",
test/Android.bp:46:        "liblog",
test/Android.bp:54:        "//hardware/amlogic:libamgralloc_ext@2",
test/Android.bp:84:        "liblog",
test/VideoDecPlayer.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
test/VideoDecPlayer.cpp:21://#define LOG_NDEBUG 0
test/VideoDecPlayer.cpp:22:#define LOG_TAG "test"
test/VideoDecPlayer.cpp:23:#include <utils/Log.h>
test/VideoDecPlayer.cpp:49:#include <amlogic/am_gralloc_ext.h>
test/VideoDecPlayer.cpp:108:                ALOGE("unable to dlopen libmediahal_videodec.so: %s", dlerror());
test/VideoDecPlayer.cpp:122:        ALOGE("can not create AmVideoDec\n");
test/VideoDecPlayer.cpp:127:    ALOGI("getAmVideoDec ok\n");
test/VideoDecPlayer.cpp:293:        ALOGI("~VideoDecPlayer free graphic buffer\n");
test/VideoDecPlayer.cpp:297:        ALOGI("~VideoDecPlayer: free ion buffer\n");
test/VideoDecPlayer.cpp:317:    ALOGI("onOutputFormatChanged bufnum %d, width %d, height %d\n",
test/VideoDecPlayer.cpp:323:            ALOGI("resolution change free graphic buffer, mOutputBufferNum %d, mQueuedSlot.size() %d\n",
test/VideoDecPlayer.cpp:353:            ALOGI("resolution change free all ion buffer, mOutputBufferNum %d\n", mOutputBufferNum);
test/VideoDecPlayer.cpp:366:        ALOGI("setMaxDequeuedBufferCount %d\n", mOutputBufferNum);
test/VideoDecPlayer.cpp:392:            ALOGI("ALLOCATE dequeuebuffer slot %d, status %d, [%d x %d]\n", slot, status, width, height);
test/VideoDecPlayer.cpp:410:            ALOGI("slotBuffer->handle %p, fd %d, metafd %d\n", slotBuffer->handle, dmabufFd, metaFd);
test/VideoDecPlayer.cpp:421:            //ALOGI("allocIonBuffer vaddr %p, size %d\n", vaddr, imagesize);
test/VideoDecPlayer.cpp:426:            ALOGI("allocIonBuffer fd %d\n", fd);
test/VideoDecPlayer.cpp:433:    ALOGI("onOutputFormatChanged ok this %p>>>>>\n", this);
test/VideoDecPlayer.cpp:445:    ALOGI("onOutputBufferDone this %p, pictureBufferId %d, bitstreamId %lld, mDisplayWork.size %d, mInputWork.size %d\n",
test/VideoDecPlayer.cpp:462:    ALOGI("onInputBufferDone this %p bitstream_buffer_id %d, mInputBuffer.size() %d\n", this, bitstreamId, mInputBuffer.size());
test/VideoDecPlayer.cpp:473:    ALOGI("onUpdateDecInfo info %p, size %d\n", info, isize);
test/VideoDecPlayer.cpp:477:    ALOGI("onFlushDone\n");
test/VideoDecPlayer.cpp:484:    ALOGI("onResetDone\n");
test/VideoDecPlayer.cpp:488:    ALOGE("onError error %d\n", error);
test/VideoDecPlayer.cpp:657:        ALOGI("this [%p] render frame [%d] timestampMs %0.3f S, playtimeMs %0.3f S, width %d, height %d\n",
test/VideoDecPlayer.cpp:672:            ALOGI("igpb queueBuffer err %d, passthrough\n", err);
test/VideoDecPlayer.cpp:676:        ALOGI("displayThread pictureBufferId %d, bitstreamId %d,"
test/VideoDecPlayer.cpp:704:            ALOGI("source read INFO_FORMAT_CHANGED\n");
test/VideoDecPlayer.cpp:708:        ALOGI("source read error %d\n", err);
test/VideoDecPlayer.cpp:722:    ALOGI("data size %d, data %p, timestamp %lld\n", buffer->size(), buffer->data(), time);
test/VideoDecPlayer.cpp:771:        ALOGI("display loop finished");
test/VideoDecPlayer.cpp:874:        ALOGI("display loop finished");
test/VideoDecPlayer.cpp:886:        ALOGI("csd0 size %d, data %p, bitstreamId:%d\n", newbuf->size(), (void*)newbuf->data(), bitstreamId);
test/VideoDecPlayer.cpp:900:        ALOGI("csd1 size %d, data %p, bitstreamId:%d\n", newbuf->size(), (void*)newbuf->data(), bitstreamId);
test/VideoDecPlayer.cpp:941:                ALOGI("csd0 size %d, data %p, bitstreamId:%d\n", newbuf->size(), (void*)newbuf->data(), bitstreamId);
test/VideoDecPlayer.cpp:955:                ALOGI("csd1 size %d, data %p, bitstreamId:%d\n", newbuf->size(), (void*)newbuf->data(), bitstreamId);
test/VideoDecPlayer.cpp:973:        ALOGI("queueInputBuffer bitstreamId %d, size %zd\n",
test/ResManTest/resmantest.c:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
test/AmVideoDecBase.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
test/EsVideoDecPlayerTest/EsVideoDecPlayerTest.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
test/VideoDecTest.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
test/VideoDecTest.cpp:15:#define LOG_TAG "VideoDecTest"
test/VideoDecTest.cpp:16:#include <utils/Log.h>
test/VideoDecTest.cpp:25:#include <utils/Log.h>
test/VideoDecTest.cpp:60:#include <android-base/logging.h>
test/VideoDecTest.cpp:91:                ALOGE("unable to dlopen libmediahal_videodec.so: %s", dlerror());
test/VideoDecTest.cpp:105:        ALOGE("can not create AmVideoDec\n");
test/VideoDecTest.cpp:110:    ALOGI("getAmVideoDec ok\n");
test/VideoDecTest.cpp:251:        ALOGI("~VideoDecPlayer free graphic buffer\n");
test/VideoDecTest.cpp:255:        ALOGI("~VideoDecPlayer: free ion buffer\n");
test/VideoDecTest.cpp:274:        ALOGI("setMaxDequeuedBufferCount %d\n", mOutputBufferNum);
test/VideoDecTest.cpp:298:            ALOGI("slotBuffer->handle %p, fd %d\n", slotBuffer->handle, slotBuffer->handle->data[0]);
test/VideoDecTest.cpp:309:            ALOGI("allocIonBuffer vaddr %p, size %d\n", vaddr, imagesize);
test/VideoDecTest.cpp:314:    ALOGI("onOutputFormatChanged ok this %p>>>>>\n", this);
test/VideoDecTest.cpp:319:    ALOGI("onOutputBufferDone this %p, pictureBufferId %d, bitstreamId %lld, mDisplayWork.size %d, mInputWork.size %d\n",
test/VideoDecTest.cpp:329:    ALOGI("onInputBufferDone this %p bitstream_buffer_id %d, mInputBuffer.size() %d\n", this, bitstreamId, mInputBuffer.size());
test/VideoDecTest.cpp:336:    ALOGI("onUpdateDecInfo info %p size %d\n", info, isize);
test/VideoDecTest.cpp:340:    ALOGI("onFlushDone\n");
test/VideoDecTest.cpp:346:    ALOGI("onResetDone\n");
test/VideoDecTest.cpp:352:    ALOGE("onError error %d\n", error);
test/VideoDecTest.cpp:386:            ALOGI("video mime %s\n", mimetype);
test/VideoDecTest.cpp:483:            ALOGI("igpb queueBuffer err %d, [%d x %d] passthrough\n", err, width, height);
test/VideoDecTest.cpp:487:        ALOGI("displayThread pictureBufferId %d, bitstreamId %d,"
test/VideoDecTest.cpp:506:            ALOGI("source read INFO_FORMAT_CHANGED\n");
test/VideoDecTest.cpp:509:        ALOGI("source read error %d\n", err);
test/VideoDecTest.cpp:522:    ALOGI("data size %d, data %p, timestamp %lld\n", buffer->size(), buffer->data(), time);
test/VideoDecTest.cpp:587:        ALOGI("display loop finished");
test/VideoDecTest.cpp:599:        ALOGI("csd0 size %d, data %p\n", newbuf->size(), (void*)newbuf->data());
test/VideoDecTest.cpp:609:        ALOGI("csd1 size %d, data %p\n", newbuf->size(), (void*)newbuf->data());
test/VideoDecTest.cpp:619:            ALOGE("source read fail err %d\n", err);
test/VideoDecTest.cpp:623:        ALOGI("queueInputBuffer bitstreamId %d, size %zd\n",
test/VideoDecTest.cpp:679:        ALOGI("display loop finished");
test/VideoDecTest.cpp:691:        ALOGI("csd0 size %d, data %p\n", newbuf->size(), (void*)newbuf->data());
test/VideoDecTest.cpp:701:        ALOGI("csd1 size %d, data %p\n", newbuf->size(), (void*)newbuf->data());
test/VideoDecTest.cpp:711:            ALOGE("source read fail err %d\n", err);
test/VideoDecTest.cpp:758:        ALOGI("display loop finished");
test/VideoDecTest.cpp:764:        ALOGI("csd0 size %d, data %p\n", newbuf->size(), (void*)newbuf->data());
test/VideoDecTest.cpp:774:        ALOGI("csd1 size %d, data %p\n", newbuf->size(), (void*)newbuf->data());
test/VideoDecTest.cpp:785:            ALOGE("source read fail err %d\n", err);
test/VideoDecTest.cpp:840:        ALOGI("display loop finished");
test/VideoDecTest.cpp:852:        ALOGI("csd0 size %d, data %p\n", newbuf->size(), (void*)newbuf->data());
test/VideoDecTest.cpp:862:        ALOGI("csd1 size %d, data %p\n", newbuf->size(), (void*)newbuf->data());
test/VideoDecTest.cpp:872:            ALOGE("source read fail err %d\n", err);
test/VideoDecTest.cpp:930:        ALOGI("display loop finished");
test/VideoDecTest.cpp:936:        ALOGI("csd0 size %d, data %p\n", newbuf->size(), (void*)newbuf->data());
test/VideoDecTest.cpp:946:        ALOGI("csd1 size %d, data %p\n", newbuf->size(), (void*)newbuf->data());
test/VideoDecTest.cpp:957:            ALOGE("source read fail err %d\n", err);
test/VideoDecTest.cpp:1014:        ALOGI("display loop finished");
test/VideoDecTest.cpp:1058:        ALOGI("display loop finished");
test/VideoDecTest.cpp:1070:        ALOGI("csd0 size %d, data %p\n", newbuf->size(), (void*)newbuf->data());
test/VideoDecTest.cpp:1080:        ALOGI("csd1 size %d, data %p\n", newbuf->size(), (void*)newbuf->data());
test/VideoDecTest.cpp:1090:            ALOGE("source read fail err %d\n", err);
test/VideoDecTest.cpp:1094:        ALOGI("queueInputBuffer bitstreamId %d, size %zd\n",
test/VideoDecTest.cpp:1249:  android::base::InitLogging(argv, android::base::StderrLogger);
Config.in:4:		amlogic media hal
Config.in:6:menu "Amlogic Media HAL"
mediaproxy/mediaproxyproducer.c:1:#define LOG_TAG "mediaproxyproducer"
mediaproxy/mediaproxyproducer.c:11:#include <utils/Log.h>
mediaproxy/mediaproxyproducer.c:39:        ALOGE("Failed to open device, fd =%d", fd);
mediaproxy/mediaproxyproducer.c:43:        ALOGE("Failed to register mediaproxy producer, fd = %d", fd);
mediaproxy/mediaproxyproducer.c:46:    ALOGD("initialized producer, opened device fd = %d", fd);
mediaproxy/mediaproxyproducer.c:53:        ALOGE("Failed to open device");
mediaproxy/mediaproxyproducer.c:56:    ALOGD("initialized producer, opened device fd = %d", fd);
mediaproxy/mediaproxyproducer.c:63:        ALOGE("Failed to connect device, fd < 0");
mediaproxy/mediaproxyproducer.c:67:        ALOGE("Failed to register mediaproxy producer");
mediaproxy/mediaproxyproducer.c:80:        ALOGE("Failed to set vid %d", vid);
mediaproxy/mediaproxyproducer.c:89:        ALOGE("Failed to set fifo len %d", len);
mediaproxy/mediaproxyproducer.c:98:        ALOGE("Failed to get bufInfo");
mediaproxy/mediaproxyproducer.c:106:        //ALOGE("there is no consumer, will not write data");
mediaproxy/mediaproxyproducer.c:115:        ALOGE("Failed to destroy mediaproxy producer");
mediaproxy/mediaproxyconsumer.c:1:#define LOG_TAG "mediaproxyconsumer"
mediaproxy/mediaproxyconsumer.c:12:#include <utils/Log.h>
mediaproxy/mediaproxyconsumer.c:39:        ALOGE("Failed to open device");
mediaproxy/mediaproxyconsumer.c:43:        ALOGE("Failed to register mediaproxy consumer");
mediaproxy/mediaproxyconsumer.c:46:    ALOGD("initialized consumer, opened device fd = %d", fd);
mediaproxy/mediaproxyconsumer.c:53:        ALOGE("Failed to open device");
mediaproxy/mediaproxyconsumer.c:56:    ALOGD("initialized consumer, opened device fd = %d", fd);
mediaproxy/mediaproxyconsumer.c:63:        ALOGE("Failed to connect device, fd < 0");
mediaproxy/mediaproxyconsumer.c:67:        ALOGE("Failed to register mediaproxy consumer");
mediaproxy/mediaproxyconsumer.c:75:        ALOGE("Failed to subscribe msg type %x", msgType);
mediaproxy/mediaproxyconsumer.c:84:        ALOGE("Failed to set vid %d", vid);
mediaproxy/mediaproxyconsumer.c:93:        ALOGE("Failed to set fifo len %d", len);
mediaproxy/mediaproxyconsumer.c:102:        ALOGE("Failed to get bufInfo");
mediaproxy/mediaproxyconsumer.c:117:    ALOGE("poll call fail");
mediaproxy/mediaproxyconsumer.c:122:    //ALOGE("poll had data to read data [ox%x][0x%x][0x%x]",pollfds[0].revents, POLLIN, POLLPRI);
mediaproxy/mediaproxyconsumer.c:125:    ALOGE("poll no data to read data occur error");
mediaproxy/mediaproxyconsumer.c:127:  //ALOGE("poll events[0x%x]",pollfds[0].revents);
mediaproxy/mediaproxyconsumer.c:144:        ALOGE("Failed to destroy mediaproxy consumer");
mediaproxy/Android.bp:2:    default_applicable_licenses: ["vendor_amlogic_mediahal_mediaproxy_license"],
mediaproxy/Android.bp:6:    name: "vendor_amlogic_mediahal_mediaproxy_license",
mediaproxy/Android.bp:37:       "liblog",
mediaproxy/Android.bp:65:       "liblog",
mediaproxy/Android.bp:92:       "liblog",
mediaproxy/Android.bp:119:       "liblog",
Android_s.bp.in:7:    // all of the 'license_kinds' from "vendor_amlogic_common_license"
Android_s.bp.in:15:    default_applicable_licenses: ["vendor_amlogic_common_license"],
Android_s.bp.in:20:    pkgPath: "android/soong/vendor/amlogic/mediahal_sdk",
tool_execution.log:10:        Logs:
tool_execution.log:11:        ID:97 | LOG:AmCodecWrapper mCodecParam %p, drmmode %d
tool_execution.log:12:ID:98 | LOG:mVideoPath %d
tool_execution.log:13:ID:99 | LOG:~AmCodecWrapper,receive_id:%d
tool_execution.log:14:ID:100 | LOG:setVideoConfig config_len %d config:%s
tool_execution.log:15:ID:101 | LOG:setUnstablePts, unstable:%d
tool_execution.log:16:ID:102 | LOG:setFormat vformat %d, aformat %d, vpid %d, apid %d pcrid %d
tool_execution.log:17:ID:103 | LOG:setVideoStreamType type %d
tool_execution.log:18:ID:104 | LOG:setResolution width %d, height %d
tool_execution.log:19:ID:105 | LOG:setVideoType type %d
tool_execution.log:20:ID:106 | LOG:setFramebasePath PATH %d
tool_execution.log:21:ID:107 | LOG:setReceiveId receiveid %d
tool_execution.log:22:ID:108 | LOG:setMediasyncVfmDevId mediasync_vfm_dec_id %d
tool_execution.log:23:ID:109 | LOG:mDemuxType %d dmx_dev_id:%d dmx_player_id:%d
tool_execution.log:24:ID:110 | LOG:setDemuxStbufInfo start:0x%x size:%d
tool_execution.log:25:ID:111 | LOG:setPtsServerId : %d
tool_execution.log:26:ID:112 | LOG:vcodec_init format(%d) [%d:%d], type %d, dves_type:%d, rate %d, path %d, ret %d
tool_execution.log:27:ID:113 | LOG:vcodec_close ret %d
tool_execution.log:28:ID:114 | LOG:input parameter is NULL, setFccMode failed
tool_execution.log:29:ID:115 | LOG:AmCodecWrapper::setFccMode
tool_execution.log:30:ID:116 | LOG:input parameter is NULL, resetAudio failed
tool_execution.log:31:ID:117 | LOG:AmCodecWrapper::resetAudio
tool_execution.log:32:ID:118 | LOG:AmCodecWrapper::start
tool_execution.log:33:ID:119 | LOG:AmCodecWrapper::stop
tool_execution.log:34:ID:120 | LOG:AmCodecWrapper::pause
tool_execution.log:35:ID:121 | LOG:AmCodecWrapper::resume
tool_execution.log:36:ID:122 | LOG:reset receiveid %d
tool_execution.log:37:ID:123 | LOG:AmCodecWrapper::disableVideo %d
tool_execution.log:38:ID:124 | LOG:AmCodecWrapper::setBlackout
tool_execution.log:39:ID:125 | LOG:AmCodecWrapper::getFirstFrameToggled mediasync_vfm_dev_id:%d count:%d
tool_execution.log:40:ID:126 | LOG:AmCodecWrapper::setFastSpeed speed %d
tool_execution.log:41:ID:127 | LOG:AmCodecWrapper::setVideoAxis
tool_execution.log:42:ID:128 | LOG:AmCodecWrapper::setVideoCrop
tool_execution.log:43:ID:129 | LOG:AmCodecWrapper::setSyncMode %d
tool_execution.log:44:ID:130 | LOG:AmCodecWrapper::setVideoWorkMode %d
tool_execution.log:45:ID:131 | LOG:AmCodecWrapper::setInstansNo %d
tool_execution.log:46:ID:132 | LOG:AmCodecWrapper::setTsyncEnable %d
tool_execution.log:47:ID:133 | LOG:AmCodecWrapper::setVfmMap %s
tool_execution.log:48:ID:134 | LOG:AmCodecWrapper::setFastShowFrameEnable %d
tool_execution.log:49:ID:135 | LOG:AmCodecWrapper::setVideoPid %d
tool_execution.log:50:ID:136 | LOG:AmCodecWrapper::setVideoFormat %d
tool_execution.log:51:ID:137 | LOG:AmCodecWrapper::getVideoCodeIsInit
tool_execution.log:52:ID:138 | LOG:open %s failed
tool_execution.log:53:ID:139 | LOG:read fail %d
tool_execution.log:54:ID:140 | LOG:AmCodecUserdataDevice
tool_execution.log:55:ID:141 | LOG:~~AmCodecUserdataDevice
tool_execution.log:56:ID:142 | LOG:AmCodecUserdataDevice init fd %d
tool_execution.log:57:ID:143 | LOG:call AMSTREAM_IOC_GET_MVDECINFO failed
tool_execution.log:58:ID:144 | LOG:get avaible vdec failed
tool_execution.log:59:ID:145 | LOG:playerID is not match read_vdec_id=%d,mPlayerInstansNo=%d
tool_execution.log:60:ID:146 | LOG:AmCodecUserdataDevice, mPlayerInstansNo:%d
tool_execution.log:61:ID:147 | LOG:call AMSTREAM_IOC_UD_BUF_READ failed cmd:0x%x
tool_execution.log:62:ID:148 | LOG:do not support vformat %d
tool_execution.log:63:ID:149 | LOG:checkFormat %d
tool_execution.log:64:ID:150 | LOG:[writeData] poc %d, pts %u, mNotifyData.size() %d
tool_execution.log:65:ID:151 | LOG:MPEG AFD notify %d, flag:%d
tool_execution.log:66:ID:152 | LOG:H264 AFD notify %d
tool_execution.log:67:ID:153 | LOG:AmCodecVDAMpeg4
tool_execution.log:68:ID:154 | LOG:~AmCodecVDAMpeg4
tool_execution.log:69:ID:155 | LOG:AmCodecVDAMpeg4::codecInit
tool_execution.log:70:ID:156 | LOG:AmCodecVDAMpeg4::doCodecSpec
tool_execution.log:71:ID:157 | LOG:AmCodecVDAH265
tool_execution.log:72:ID:158 | LOG:~AmCodecVDAH265
tool_execution.log:73:ID:159 | LOG:AmCodecVDAH265::codecInit
tool_execution.log:74:ID:160 | LOG:AmCodecVDAH265::doCodecSpec
tool_execution.log:75:ID:161 | LOG:AmCodecVDAH265 buf %x-%x-%x-%x-%x-%x-%x-%x
tool_execution.log:76:ID:162 | LOG:copy csd size %d, mCsdBufSize %d
tool_execution.log:77:ID:163 | LOG:add csd essize %d, csdsize %d
tool_execution.log:78:ID:164 | LOG:AmCodecVDAVP9
tool_execution.log:79:ID:165 | LOG:~AmCodecVDAVP9
tool_execution.log:80:ID:166 | LOG:AmCodecVDAVP9::codecInit
tool_execution.log:81:ID:167 | LOG:AmCodecVDAVP9::doCodecSpec
tool_execution.log:82:ID:168 | LOG:Wrong marker2 : 0x%X --> 0x%X
tool_execution.log:83:ID:169 | LOG:DATA overflow : 0x%X --> 0x%X
tool_execution.log:84:ID:170 | LOG:data has gaps,set to 0
tool_execution.log:85:ID:171 | LOG:ERROR!!! data over writed!!!! over write %d
tool_execution.log:86:ID:172 | LOG:AmCodecVDAMpeg2ts
tool_execution.log:87:ID:173 | LOG:~AmCodecVDAMpeg2ts
tool_execution.log:88:ID:174 | LOG:AmCodecVDAMpeg2ts::codecInit
tool_execution.log:89:ID:175 | LOG:display mode %d, vformat %d
tool_execution.log:90:ID:176 | LOG:AmCodecVDAMpeg2ts::doCodecSpec
tool_execution.log:91:ID:177 | LOG:AmCodecVDAH264
tool_execution.log:92:ID:178 | LOG:~AmCodecVDAH264
tool_execution.log:93:ID:179 | LOG:AmCodecVDAH264::codecInit
tool_execution.log:94:ID:180 | LOG:AmCodecVDAH264::doCodecSpec
tool_execution.log:95:ID:181 | LOG:AmCodecVDAH264 buf %x-%x-%x-%x-%x-%x-%x-%x
tool_execution.log:96:ID:182 | LOG:AmCodecVDAH266
tool_execution.log:97:ID:183 | LOG:~AmCodecVDAH266
tool_execution.log:98:ID:184 | LOG:AmCodecVDAH266::codecInit
tool_execution.log:99:ID:185 | LOG:AmCodecVDAH266::doCodecSpec
tool_execution.log:100:ID:186 | LOG:AmCodecVDAH266 buf %x-%x-%x-%x-%x-%x-%x-%x
tool_execution.log:101:ID:187 | LOG:AmCodecVDAAVS2
tool_execution.log:117:        Logs:
tool_execution.log:118:        ID:97 | LOG:AmCodecWrapper mCodecParam %p, drmmode %d
tool_execution.log:119:ID:98 | LOG:mVideoPath %d
tool_execution.log:120:ID:99 | LOG:~AmCodecWrapper,receive_id:%d
tool_execution.log:121:ID:100 | LOG:setVideoConfig config_len %d config:%s
tool_execution.log:122:ID:101 | LOG:setUnstablePts, unstable:%d
tool_execution.log:123:ID:102 | LOG:setFormat vformat %d, aformat %d, vpid %d, apid %d pcrid %d
tool_execution.log:124:ID:103 | LOG:setVideoStreamType type %d
tool_execution.log:125:ID:104 | LOG:setResolution width %d, height %d
tool_execution.log:126:ID:105 | LOG:setVideoType type %d
tool_execution.log:127:ID:106 | LOG:setFramebasePath PATH %d
tool_execution.log:128:ID:107 | LOG:setReceiveId receiveid %d
tool_execution.log:129:ID:108 | LOG:setMediasyncVfmDevId mediasync_vfm_dec_id %d
tool_execution.log:130:ID:109 | LOG:mDemuxType %d dmx_dev_id:%d dmx_player_id:%d
tool_execution.log:131:ID:110 | LOG:setDemuxStbufInfo start:0x%x size:%d
tool_execution.log:132:ID:111 | LOG:setPtsServerId : %d
tool_execution.log:133:ID:112 | LOG:vcodec_init format(%d) [%d:%d], type %d, dves_type:%d, rate %d, path %d, ret %d
tool_execution.log:134:ID:113 | LOG:vcodec_close ret %d
tool_execution.log:135:ID:114 | LOG:input parameter is NULL, setFccMode failed
tool_execution.log:136:ID:115 | LOG:AmCodecWrapper::setFccMode
tool_execution.log:137:ID:116 | LOG:input parameter is NULL, resetAudio failed
tool_execution.log:138:ID:117 | LOG:AmCodecWrapper::resetAudio
tool_execution.log:139:ID:118 | LOG:AmCodecWrapper::start
tool_execution.log:140:ID:119 | LOG:AmCodecWrapper::stop
tool_execution.log:141:ID:120 | LOG:AmCodecWrapper::pause
tool_execution.log:142:ID:121 | LOG:AmCodecWrapper::resume
tool_execution.log:143:ID:122 | LOG:reset receiveid %d
tool_execution.log:144:ID:123 | LOG:AmCodecWrapper::disableVideo %d
tool_execution.log:145:ID:124 | LOG:AmCodecWrapper::setBlackout
tool_execution.log:146:ID:125 | LOG:AmCodecWrapper::getFirstFrameToggled mediasync_vfm_dev_id:%d count:%d
tool_execution.log:147:ID:126 | LOG:AmCodecWrapper::setFastSpeed speed %d
tool_execution.log:148:ID:127 | LOG:AmCodecWrapper::setVideoAxis
tool_execution.log:149:ID:128 | LOG:AmCodecWrapper::setVideoCrop
tool_execution.log:150:ID:129 | LOG:AmCodecWrapper::setSyncMode %d
tool_execution.log:151:ID:130 | LOG:AmCodecWrapper::setVideoWorkMode %d
tool_execution.log:152:ID:131 | LOG:AmCodecWrapper::setInstansNo %d
tool_execution.log:153:ID:132 | LOG:AmCodecWrapper::setTsyncEnable %d
tool_execution.log:154:ID:133 | LOG:AmCodecWrapper::setVfmMap %s
tool_execution.log:155:ID:134 | LOG:AmCodecWrapper::setFastShowFrameEnable %d
tool_execution.log:156:ID:135 | LOG:AmCodecWrapper::setVideoPid %d
tool_execution.log:157:ID:136 | LOG:AmCodecWrapper::setVideoFormat %d
tool_execution.log:158:ID:137 | LOG:AmCodecWrapper::getVideoCodeIsInit
tool_execution.log:159:ID:138 | LOG:open %s failed
tool_execution.log:160:ID:139 | LOG:read fail %d
tool_execution.log:161:ID:140 | LOG:AmCodecUserdataDevice
tool_execution.log:162:ID:141 | LOG:~~AmCodecUserdataDevice
tool_execution.log:163:ID:142 | LOG:AmCodecUserdataDevice init fd %d
tool_execution.log:164:ID:143 | LOG:call AMSTREAM_IOC_GET_MVDECINFO failed
tool_execution.log:165:ID:144 | LOG:get avaible vdec failed
tool_execution.log:166:ID:145 | LOG:playerID is not match read_vdec_id=%d,mPlayerInstansNo=%d
tool_execution.log:167:ID:146 | LOG:AmCodecUserdataDevice, mPlayerInstansNo:%d
tool_execution.log:168:ID:147 | LOG:call AMSTREAM_IOC_UD_BUF_READ failed cmd:0x%x
tool_execution.log:169:ID:148 | LOG:do not support vformat %d
tool_execution.log:170:ID:149 | LOG:checkFormat %d
tool_execution.log:171:ID:150 | LOG:[writeData] poc %d, pts %u, mNotifyData.size() %d
tool_execution.log:172:ID:151 | LOG:MPEG AFD notify %d, flag:%d
tool_execution.log:173:ID:152 | LOG:H264 AFD notify %d
tool_execution.log:174:ID:153 | LOG:AmCodecVDAMpeg4
tool_execution.log:175:ID:154 | LOG:~AmCodecVDAMpeg4
tool_execution.log:176:ID:155 | LOG:AmCodecVDAMpeg4::codecInit
tool_execution.log:177:ID:156 | LOG:AmCodecVDAMpeg4::doCodecSpec
tool_execution.log:178:ID:157 | LOG:AmCodecVDAH265
tool_execution.log:179:ID:158 | LOG:~AmCodecVDAH265
tool_execution.log:180:ID:159 | LOG:AmCodecVDAH265::codecInit
tool_execution.log:181:ID:160 | LOG:AmCodecVDAH265::doCodecSpec
tool_execution.log:182:ID:161 | LOG:AmCodecVDAH265 buf %x-%x-%x-%x-%x-%x-%x-%x
tool_execution.log:183:ID:162 | LOG:copy csd size %d, mCsdBufSize %d
tool_execution.log:184:ID:163 | LOG:add csd essize %d, csdsize %d
tool_execution.log:185:ID:164 | LOG:AmCodecVDAVP9
tool_execution.log:186:ID:165 | LOG:~AmCodecVDAVP9
tool_execution.log:187:ID:166 | LOG:AmCodecVDAVP9::codecInit
tool_execution.log:188:ID:167 | LOG:AmCodecVDAVP9::doCodecSpec
tool_execution.log:189:ID:168 | LOG:Wrong marker2 : 0x%X --> 0x%X
tool_execution.log:190:ID:169 | LOG:DATA overflow : 0x%X --> 0x%X
tool_execution.log:191:ID:170 | LOG:data has gaps,set to 0
tool_execution.log:192:ID:171 | LOG:ERROR!!! data over writed!!!! over write %d
tool_execution.log:193:ID:172 | LOG:AmCodecVDAMpeg2ts
tool_execution.log:194:ID:173 | LOG:~AmCodecVDAMpeg2ts
tool_execution.log:195:ID:174 | LOG:AmCodecVDAMpeg2ts::codecInit
tool_execution.log:196:ID:175 | LOG:display mode %d, vformat %d
tool_execution.log:197:ID:176 | LOG:AmCodecVDAMpeg2ts::doCodecSpec
tool_execution.log:198:ID:177 | LOG:AmCodecVDAH264
tool_execution.log:199:ID:178 | LOG:~AmCodecVDAH264
tool_execution.log:200:ID:179 | LOG:AmCodecVDAH264::codecInit
tool_execution.log:201:ID:180 | LOG:AmCodecVDAH264::doCodecSpec
tool_execution.log:202:ID:181 | LOG:AmCodecVDAH264 buf %x-%x-%x-%x-%x-%x-%x-%x
tool_execution.log:203:ID:182 | LOG:AmCodecVDAH266
tool_execution.log:204:ID:183 | LOG:~AmCodecVDAH266
tool_execution.log:205:ID:184 | LOG:AmCodecVDAH266::codecInit
tool_execution.log:206:ID:185 | LOG:AmCodecVDAH266::doCodecSpec
tool_execution.log:207:ID:186 | LOG:AmCodecVDAH266 buf %x-%x-%x-%x-%x-%x-%x-%x
tool_execution.log:208:ID:187 | LOG:AmCodecVDAAVS2
OTT-45403_mediahal_debug.patch:2:Author: ye.zhu <ye.zhu@amlogic.com>
OTT-45403_mediahal_debug.patch:23:                 MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,
OTT-45403_mediahal_debug.patch:29:+        MS_LOGI(MSYNC_DEBUG_LEVEL_0, mLogHead, "wrong acache:%d ms.", info->cacheDuration / 90);
OTT-45403_mediahal_debug.patch:41:+        MS_LOGI(MSYNC_DEBUG_LEVEL_0, mLogHead, "wrong vcache:%d ms.", info->cacheDuration / 90);
Android_p.bp.in:3:    pkgPath: "android/soong/vendor/amlogic/mediahal_sdk",
systembuild/systemcheck.go:35:    // Log failure and return a default value
systembuild/systemcheck.go:44:    // Log the retrieved SDK version
systembuild/Android.bp:2:    default_applicable_licenses: ["vendor_amlogic_mediahal_license"],
systembuild/utilsLibsCheck.go:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
systembuild/utilsLibsCheck.go:61:        sharedlib = append(sharedlib, "//vendor/amlogic/common:libsystemcontrolservice")
systembuild/utilsLibsCheck.go:64:            sharedlib = append(sharedlib, "//vendor/amlogic/common:vendor.amlogic.hardware.systemcontrol@1.0")
systembuild/utilsLibsCheck.go:65:            sharedlib = append(sharedlib, "//vendor/amlogic/common:vendor.amlogic.hardware.systemcontrol@1.1")
systembuild/utilsLibsCheck.go:67:            sharedlib = append(sharedlib, "//vendor/amlogic/common:vendor.amlogic.hardware.systemcontrol-V1-ndk")
systembuild/utilsLibsCheck.go:68:            sharedlib = append(sharedlib, "//vendor/amlogic/common:libdroidaudioclient")
systembuild/utilsLibsCheck.go:83:        sharedlib = append(sharedlib, "//vendor/amlogic/common:vendor.amlogic.hardware.systemcontrol@1.0")
systembuild/utilsLibsCheck.go:84:        sharedlib = append(sharedlib, "//vendor/amlogic/common:vendor.amlogic.hardware.systemcontrol@1.1")
systembuild/utilsLibsCheck.go:98:            include_dir = append(include_dir, "vendor/amlogic/common/frameworks/services/systemcontrol")
systembuild/utilsLibsCheck.go:99:            include_dir = append(include_dir, "vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include")
systembuild/utilsLibsCheck.go:101:            include_dir = append(include_dir, "vendor/amlogic/common/frameworks/services/systemcontrol/aidl")
systembuild/utilsLibsCheck.go:102:            include_dir = append(include_dir, "vendor/amlogic/common/frameworks/services/systemcontrol/aidl/PQ/include")
systembuild/utilsLibsCheck.go:103:            include_dir = append(include_dir, "vendor/amlogic/common/interfaces/droidaudio/default/libdroidaudioclient")
systembuild/utilsLibsCheck.go:116:        include_dir = append(include_dir, "vendor/amlogic/common/frameworks/services/systemcontrol")
systembuild/utilsLibsCheck.go:117:        include_dir = append(include_dir, "vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include")
version/autobuild_release.sh:19:GIT_CHANGED_ID=$(cd ${MEIDAHAL_PATCH} && git log -1 | grep Change-Id | awk '{print $2}' | cut -c 1-6)
version/autobuild_release.sh:20:COMMIT_NUMS=$(cd ${MEIDAHAL_PATCH} && git log | grep "Change-Id: " | grep -n ${BASE_CHANGE_ID} | awk -F ":" '{printf "%d", $1-1}' )
version/autobuild_release.sh:32:GIT_LOG_NUM=10
version/autobuild_release.sh:33:GIT_COMMIT_FULL=$(cd ${MEIDAHAL_PATCH} && git log -$GIT_LOG_NUM | sed 's/^[ \t]*//g')
version/VERSION:328:#Adapted to the new interface of AudioHAL (main-Amlogic) and replaced parameter setting with DroidAudioManager.
version/VERSION:342:#Supported enabling AVBCD (Amlogic Video Buffer Compression Decoder).
version/VERSION:477:#Added key logs for automated tests.
version/VERSION:743:#Add v4l2 event log info.
version/VERSION:745:#Videodec logcat & trace use sessionid#decoderid distinguish.
version/VERSION:939:#Remove the logic to start and stop the audio decode when setting mute and set volume.
version/VERSION:954:#V4L2:optimization log level and dump codec mm
version/VERSION:1002:#optimize log information.
mediametrics/utils/ThreadUtil.cpp:1://#define LOG_NDEBUG 0
mediametrics/utils/ThreadUtil.cpp:2:#define LOG_TAG "ThreadUtil"
mediametrics/utils/ThreadUtil.cpp:3:#include <utils/Log.h>
mediametrics/utils/ThreadUtil.cpp:72:        ALOGD("%s:%d in", __func__, __LINE__);
mediametrics/utils/ThreadUtil.cpp:76:    ALOGD("%s:%d in", __func__, __LINE__);
mediametrics/utils/ThreadUtil.cpp:82:        ALOGD("%s:%d in", __func__, __LINE__);
mediametrics/utils/ThreadUtil.cpp:90:    ALOGD("%s:%d in", __func__, __LINE__);
mediametrics/utils/ThreadUtil.cpp:105:    ALOGD("%s:%d exit", __func__, __LINE__);
mediametrics/utils/ThreadUtil.cpp:111:    ALOGD("%s:%d in", __func__, __LINE__);
mediametrics/utils/ThreadUtil.cpp:148:    ALOGD("%s:%d threadid:%d", __func__, __LINE__, (int)mThread);
mediametrics/utils/ThreadUtil.cpp:153:    ALOGD("%s:%d in", __func__, __LINE__);
mediametrics/utils/ThreadUtil.cpp:160:                ALOGE("pthread on exit wait clean\n");
mediametrics/utils/ThreadUtil.cpp:171:        ALOGE("Worker is already running igonore start.");
mediametrics/utils/ThreadUtil.cpp:177:        ALOGE("pthread_create failed (err=%d)", ret);
mediametrics/utils/ThreadUtil.cpp:180:    ALOGD("%s:%d threadid:%d", __func__, __LINE__, (int)mThread);
mediametrics/utils/ThreadUtil.cpp:195:            ALOGW("pthread_join failed (err=%d)", ret);
mediametrics/utils/ThreadUtil.cpp:204:    ALOGD("%s:%d thread exit", __func__, __LINE__);
mediametrics/utils/ThreadUtil.cpp:220:    ALOGD("%s:%d in", __func__, __LINE__);
mediametrics/utils/ThreadUtil.cpp:230:    ALOGD("%s:%d in", __func__, __LINE__);
mediametrics/test/Android.bp:3:    default_applicable_licenses: ["vendor_amlogic_mediahal_mediametricstest_license"],
mediametrics/test/Android.bp:7:    name: "vendor_amlogic_mediahal_mediametricstest_license",
mediametrics/test/Android.bp:56:        "liblog",
mediametrics/test/metrics_test.cpp:16:#include "log_debug.h"
mediametrics/Android.bp:3:    default_applicable_licenses: ["vendor_amlogic_mediahal_mediametrics_license"],
mediametrics/Android.bp:7:    name: "vendor_amlogic_mediahal_mediametrics_license",
mediametrics/Android.bp:43:        "liblog",
mediametrics/Android.bp:76:        "liblog",
mediametrics/Android.bp_:3:    default_applicable_licenses: ["vendor_amlogic_mediahal_mediametrics_license"],
mediametrics/Android.bp_:7:    name: "vendor_amlogic_mediahal_mediametrics_license",
mediametrics/Android.bp_:37:        "vendor/amlogic/common/mediahal_sdk/include",
mediametrics/Android.bp_:44:        "liblog",
mediametrics/wrapper/MediaProxyWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
mediametrics/wrapper/MediaProxyWrapper.cpp:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
mediametrics/wrapper/MediaProxyWrapper.cpp:9:#define LOG_NDEBUG 0
mediametrics/wrapper/MediaProxyWrapper.cpp:10:#define LOG_TAG "MediaProxyWrapper"
mediametrics/wrapper/MediaProxyWrapper.cpp:13:#include <utils/Log.h>
mediametrics/wrapper/MediaProxyWrapper.cpp:22:#include "log_debug.h"
mediametrics/wrapper/MediaProxyWrapper.cpp:25:#define MPLog(level, f,s...) VDLog(level, f, ##s)
mediametrics/wrapper/MediaProxyWrapper.cpp:28:#define PROPERTY_MEDIAMETRICS_LOGLEVELS "vendor.mediahal.metrics.loglevels"
mediametrics/wrapper/MediaProxyWrapper.cpp:52:            MPLog(LOG_ERR, "not find initialize symbol, may need check!");
mediametrics/wrapper/MediaProxyWrapper.cpp:57:            MPLog(LOG_ERR, "not find registerMsgType symbol, may need check!");
mediametrics/wrapper/MediaProxyWrapper.cpp:62:            MPLog(LOG_ERR, "not find readData symbol, may need check!");
mediametrics/wrapper/MediaProxyWrapper.cpp:67:            VDLog(LOG_ERR, "not find readMultiData symbol, may need check!");
mediametrics/wrapper/MediaProxyWrapper.cpp:72:            VDLog(LOG_ERR, "not find pollInfo symbol, may need check!");
mediametrics/wrapper/MediaProxyWrapper.cpp:77:            MPLog(LOG_ERR, "not find initialize symbol, may need check!");
mediametrics/wrapper/MediaProxyWrapper.cpp:80:        MPLog(LOG_ERR, "dlopen libmediaproxy_consumer.so error: %s", dlerror());
mediametrics/wrapper/MediaProxyWrapper.cpp:109:            MPLog(LOG_ERR, "not find initialize symbol, may need check!");
mediametrics/wrapper/MediaProxyWrapper.cpp:114:            MPLog(LOG_ERR, "not find writeData symbol, may need check!");
mediametrics/wrapper/MediaProxyWrapper.cpp:119:            MPLog(LOG_ERR, "not find initialize symbol, may need check!");
mediametrics/wrapper/MediaProxyWrapper.cpp:122:        MPLog(LOG_ERR, "dlopen libmediaproxy_producer.so error: %s", dlerror());
mediametrics/wrapper/MediaProxyWrapper.cpp:140:    gloglevel = property_get_int32(PROPERTY_MEDIAMETRICS_LOGLEVELS, 1);
mediametrics/wrapper/MediaProxyWrapper.cpp:146:            MPLog(LOG_ERR, "producer symbol not load normal, need check");
mediametrics/wrapper/MediaProxyWrapper.cpp:154:            MPLog(LOG_ERR, "consumer symbol not load normal, need check");
mediametrics/wrapper/MediaProxyWrapper.cpp:159:        MPLog(LOG_ERR, "error role type %d", type);
mediametrics/wrapper/MediaProxyWrapper.cpp:164:        MPLog(LOG_ERR, "%s role %d initialize failed", mName, type);
mediametrics/wrapper/MediaProxyWrapper.cpp:187:            MPLog(LOG_DEBUG_LEVEL2, "readData timeout");
mediametrics/wrapper/MediaProxyWrapper.cpp:191:        MPLog(LOG_ERR, "readData symbol error,fd:%d,readData:%p", mProxy_fd, gMediaConsumer.readData);
mediametrics/wrapper/MediaProxyWrapper.cpp:202:        MPLog(LOG_ERR, "readMultiData symbol error,fd:%d,readMultiData:%p", mProxy_fd, gMediaConsumer.readMultiData);
mediametrics/wrapper/MediaProxyWrapper.cpp:210:            MPLog(LOG_ERR, "writeData error");
mediametrics/wrapper/MediaProxyWrapper.cpp:213:        MPLog(LOG_ERR, "writeData symbol error,fd:%d,readData:%p", mProxy_fd, gMediaProducer.writeData);
mediametrics/wrapper/MediaProxyWrapper.cpp:223:        MPLog(LOG_ERR, "poll_wait symbol error,fd:%d,poll_wait:%p", mProxy_fd, gMediaConsumer.poll_wait);
mediametrics/wrapper/MediaProxyWrapper.cpp:232:        MPLog(LOG_ERR, "registermsgtype error");
mediametrics/include/MediaMetricsData.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
mediametrics/include/MediaMetrics.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
mediametrics/include/MediaMetrics.h:104:    int mLogTimeDuration;
mediametrics/include/MediaMetrics.h:105:    int mLogFlipGap;
mediametrics/include/log_debug.h:1:#ifndef _LOG_DEBUG_H
mediametrics/include/log_debug.h:2:#define _LOG_DEBUG_H
mediametrics/include/log_debug.h:6:#include <utils/Log.h>
mediametrics/include/log_debug.h:11:#define LOG_ERR 0
mediametrics/include/log_debug.h:12:#define LOG_INFO 1
mediametrics/include/log_debug.h:13:#define LOG_BUFFER 2
mediametrics/include/log_debug.h:14:#define LOG_DEBUG_LEVEL1 4
mediametrics/include/log_debug.h:15:#define LOG_DEBUG_LEVEL2 8
mediametrics/include/log_debug.h:16:#define LOG_TRACE 16
mediametrics/include/log_debug.h:18:static unsigned int gloglevel = 1;
mediametrics/include/log_debug.h:19:#define VDLog(level, f, s...) \
mediametrics/include/log_debug.h:21:    if (level & gloglevel) {\
mediametrics/include/log_debug.h:22:        if (level == LOG_INFO)\
mediametrics/include/log_debug.h:23:            ALOGI(f, ##s);\
mediametrics/include/log_debug.h:24:        else if (level == LOG_BUFFER || level == LOG_DEBUG_LEVEL1 || level == LOG_DEBUG_LEVEL2) \
mediametrics/include/log_debug.h:25:            ALOGD(f, ##s);\
mediametrics/include/log_debug.h:28:            ALOGD(f, ##s);\
mediametrics/include/log_debug.h:35:    if (gloglevel & LOG_TRACE) {\
mediametrics/MediaMetrics.cpp:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
mediametrics/MediaMetrics.cpp:9:#define LOG_NDEBUG 0
mediametrics/MediaMetrics.cpp:10:#define LOG_TAG "MediaMetrics"
mediametrics/MediaMetrics.cpp:12:#include <utils/Log.h>
mediametrics/MediaMetrics.cpp:24:#include "log_debug.h"
mediametrics/MediaMetrics.cpp:27:#define MMLog(level, f,s...) VDLog(level, f, ##s)
mediametrics/MediaMetrics.cpp:28:#define PROPERTY_MEDIAMETRICS_LOGLEVELS "vendor.mediahal.metrics.loglevels"
mediametrics/MediaMetrics.cpp:29:#define PROPERTY_MEDIAMETRICS_LOG_DURATION "vendor.mediahal.metrics.logdurationMs"
mediametrics/MediaMetrics.cpp:30:#define PROPERTY_MEDIAMETRICS_LOG_FLIP "vendor.mediahal.metrics.flipgaplog"
mediametrics/MediaMetrics.cpp:63:    gloglevel = property_get_int32(PROPERTY_MEDIAMETRICS_LOGLEVELS, 1);
mediametrics/MediaMetrics.cpp:73:    mLogTimeDuration = 0;
mediametrics/MediaMetrics.cpp:81:    mLogTimeDuration = 0;
mediametrics/MediaMetrics.cpp:126:                //MMLog(LOG_BUFFER, "read packets:%d(%d/%d)", readpackets, readSize, sizeof(struct aml_video_user_data));
mediametrics/MediaMetrics.cpp:141:        MMLog(LOG_BUFFER, "read msgtype:%s decoderid:%d", metricsDataType2Str(userdata->message_type), msgInfo->decoder_instid);
mediametrics/MediaMetrics.cpp:145:            MMLog(LOG_ERR, "no session id:%d", msgInfo->decoder_instid);
mediametrics/MediaMetrics.cpp:192:                MMLog(LOG_BUFFER, "new record id:%d type:%d bitstreamId:%lld, frame_index:%lld, decodetime:%lld", msgInfo->decoder_instid, userdata->message_type, (long long)bitstreamId, (long long)msgInfo->frame_index, (long long)msgInfo->time);
mediametrics/MediaMetrics.cpp:197:                MMLog(LOG_BUFFER, "store record id:%d type:%d bitstreamId:%lld, frame_index:%lld, mediatime:%lld, decodetime:%lld, toggletime:%lld, signalfenctime:%lld", msgInfo->decoder_instid, userdata->message_type, (long long)bitstreamId, (long long)msgInfo->frame_index, (long long)iter->mediatime, (long long)iter->decoded_time, (long long)iter->toggle_time, (long long)iter->signalfence_time);
mediametrics/MediaMetrics.cpp:233:                MMLog(LOG_BUFFER, "new record id:%d type:%d bitstreamId:%lld, frame_index:%lld toggletime:%lld", msgInfo->decoder_instid, userdata->message_type, (long long)bitstreamId, (long long)msgInfo->frame_index, (long long)msgInfo->time);
mediametrics/MediaMetrics.cpp:238:                MMLog(LOG_BUFFER, "store record id:%d type:%d bitstreamId:%lld, frame_index:%lld, mediatime:%lld, decodetime:%lld, toggletime:%lld, signalfenctime:%lld", msgInfo->decoder_instid, userdata->message_type, (long long)bitstreamId, (long long)msgInfo->frame_index, (long long)iter->mediatime, (long long)iter->decoded_time, (long long)iter->toggle_time, (long long)iter->signalfence_time);
mediametrics/MediaMetrics.cpp:249:                    MMLog(LOG_BUFFER, "have signal id:%d  bitstreamId:%lld, frame_index:%lld signalfenctime:%lld", msgInfo->decoder_instid, (long long)bitstreamId, (long long)msgInfo->frame_index, (long long)iter->signalfence_time);
mediametrics/MediaMetrics.cpp:279:                MMLog(LOG_BUFFER, "new record id:%d type:%d bitstreamId:%lld, frame_index:%lld signalfencetime:%lld", msgInfo->decoder_instid, userdata->message_type, (long long)bitstreamId, (long long)msgInfo->frame_index, (long long)msgInfo->time);
mediametrics/MediaMetrics.cpp:284:                MMLog(LOG_BUFFER, "store record id:%d type:%d bitstreamId:%lld, frame_index:%lld, mediatime:%lld, duration_us:%d, decodetime:%lld, toggletime:%lld, signalfenctime:%lld", msgInfo->decoder_instid, userdata->message_type, (long long)bitstreamId, (long long)msgInfo->frame_index, (long long)iter->mediatime, iter->duration_us, (long long)iter->decoded_time, (long long)iter->toggle_time, (long long)iter->signalfence_time);
mediametrics/MediaMetrics.cpp:308:        MMLog(LOG_INFO, "id %d have connected", id);
mediametrics/MediaMetrics.cpp:315:    mLogTimeDuration = property_get_int32(PROPERTY_MEDIAMETRICS_LOG_DURATION, 5000);
mediametrics/MediaMetrics.cpp:316:    mLogFlipGap = property_get_int32(PROPERTY_MEDIAMETRICS_LOG_FLIP, 0);
mediametrics/MediaMetrics.cpp:317:    MMLog(LOG_INFO, "input session with id %d connected", id);
mediametrics/MediaMetrics.cpp:329:        MMLog(LOG_DEBUG_LEVEL1, "invalid session (id:%d) or not connect, no need disconnect, ignore", ses->id);
mediametrics/MediaMetrics.cpp:331:        MMLog(LOG_INFO, "will disconnect input session(id:%d)", ses->id);
mediametrics/MediaMetrics.cpp:348:            MMLog(LOG_ERR, "invalid session %p, please check!", session);
mediametrics/MediaMetrics.cpp:367:            MMLog(LOG_BUFFER, "queue in frame id:%d update bitstreamId:%lld mediatimeus:%lld duration_us:%u", s->id, (long long)frame->bitstreamid, (long long)frame->mediatime, frame->duration_us);
mediametrics/MediaMetrics.cpp:375:                MMLog(LOG_BUFFER, "queue in frame id:%d bitstreamId:%lld mediatimeus:%lld duration_us:%u", s->id, (long long)frame->bitstreamid, (long long)frame->mediatime, frame->duration_us);
mediametrics/MediaMetrics.cpp:393:            MMLog(LOG_ERR, "invalid session %p, please check!", session);
mediametrics/MediaMetrics.cpp:411:    //MMLog(LOG_DEBUG_LEVEL1,"%s:%d cmd:%d", __func__, __LINE__, cmd);
mediametrics/MediaMetrics.cpp:445:            MMLog(LOG_ERR, "invalid session %p, please check!", session);
mediametrics/MediaMetrics.cpp:449:        MMLog(LOG_INFO, "clear session %d medtrics info", ses->id);
mediametrics/MediaMetrics.cpp:470:            MMLog(LOG_ERR, "invalid session %p, please check!", session);
mediametrics/MediaMetrics.cpp:474:        MMLog(LOG_INFO, "session %d pause(%d) medtrics info", ses->id, val);
mediametrics/MediaMetrics.cpp:494:            MMLog(LOG_ERR, "invalid session %p, please check!", session);
mediametrics/MediaMetrics.cpp:498:        MMLog(LOG_INFO, "session %d show(%d) display info", ses->id, val);
mediametrics/MediaMetrics.cpp:508:        metrics->getTaskThread()->postDelayTask(showDisplayMetricsInfo, static_cast<void*>(mDisplayArgQueue[id].get()), metrics->mLogTimeDuration * 1000);
mediametrics/MediaMetrics.cpp:514:    MMLog(LOG_BUFFER, "processDisplayMetricsInfo, frame_index:%lld, mediatime:%lld, duration_us:%d, decodetime:%lld, toggletime:%lld, signalfenctime:%lld", (long long)info->frame_index, (long long)info->mediatime, info->duration_us, (long long)info->decoded_time, (long long)info->toggle_time, (long long)info->signalfence_time);
mediametrics/MediaMetrics.cpp:521:    MMLog(LOG_BUFFER, "processDisplayMetricsInfo, id:%d frame_index:%lld, mediatime:%lld, duration_us:%d, decodetime:%lld, toggletime:%lld, signalfenctime:%lld",s->id, (long long)info->frame_index, (long long)info->mediatime, info->duration_us, (long long)info->decoded_time, (long long)info->toggle_time, (long long)info->signalfence_time);
mediametrics/MediaMetrics.cpp:527:    MMLog(LOG_BUFFER, "id:%d frames_dropped:%u, curToggleTimeMs:%lld, last_set_frame_at_ms:%lld", s->id, s->displayInfo.frames_dropped, (long long)curToggleTimeMs, (long long)s->displayInfo.last_set_frame_at_ms);
mediametrics/MediaMetrics.cpp:534:            MMLog(LOG_INFO, "[id:%d] the last rendering is %lld ms old, Possible resume detected",
mediametrics/MediaMetrics.cpp:544:                MMLog(LOG_INFO, "[id:%u] Possible seek found! [%lld ~ %lld, %+lld]",
mediametrics/MediaMetrics.cpp:569:            if (mLogFlipGap != 0) {
mediametrics/MediaMetrics.cpp:570:                MMLog(LOG_INFO, "[id:%u] DisplayMetricsInfo [%u][performance] found rendering frames are not consecutive[%lld ~ %lld, %+lld], separated by %d consecutive frames.",
mediametrics/MediaMetrics.cpp:601:                MMLog(LOG_ERR, "id %d no show arg, should not enter here", id);
mediametrics/MediaMetrics.cpp:607:            MMLog(LOG_INFO, "id %d should have disconnected, ignore display info", id);
mediametrics/MediaMetrics.cpp:619:            MMLog(LOG_INFO, "id %d display info not change, do not have rendering frames", id);
mediametrics/MediaMetrics.cpp:626:        MMLog(LOG_INFO, "DisplayMetricsInfo session id:%d frame count(%lld) (timestamp: [%lld~%lld, %+lld], FrameRate %s/%d MaxWH: %dx%d, FWxH %dx%d) drop(%u, max consec:%u) gapMs(min:%lld(%lld) max:%lld(%lld) avg:%lld(%lld))",
mediametrics/MediaMetrics.cpp:653:                MMLog(LOG_INFO, "[%d] Found playback speed > 1.0x, %d frames are processed within %dms while only %d frames expected. %d frames may have been skipped",
mediametrics/MediaMetrics.cpp:680:        metrics->getTaskThread()->postDelayTask(showDisplayMetricsInfo, arg, metrics->mLogTimeDuration * 1000);
mediametrics/MediaMetrics.cpp:703:    MMLog(LOG_INFO, "resetDisplayInfo session %d displayInfo:%p", s->id, &(s->displayInfo));
mediametrics/MediaMetrics.cpp:717:    MMLog(LOG_BUFFER, "setFrameSize session %d width:%d height:%d max_width:%d max_height:%d", s->id, size->width, size->height, size->max_width, size->max_height);
DemuxWrapper/HardwareDemux/Common/DemuxWrapperProperty.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/Common/DemuxWrapperProperty.cpp:13:#include "log/log.h"
DemuxWrapper/HardwareDemux/Common/DemuxWrapperProperty.cpp:27:        ALOGE("input parameter was NULL, DemuxWrapper_getPropertyInt failed!");
DemuxWrapper/HardwareDemux/Common/DemuxWrapperProperty.cpp:49:        ALOGE("input parameter was NULL, DemuxWrapper_propertyGet failed!");
DemuxWrapper/HardwareDemux/test/AmDemuxWrappertest.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:10:#define LOG_NDEBUG 0
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:11:#define LOG_TAG "AmHwDemuxWrapper"
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:35:    ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:45:        ALOGV("cannot open \"%s\" (%d:%s)", DSC_DEV_NAME, errno, strerror(errno));
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:54:    ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:86:        ALOGE("do not support demux source %d", src);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:97:    ALOGV("%s at #line %d src %d\n",__func__,__LINE__,src);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:110:            ALOGV("illegal ts source %d", src);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:123:    ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:166:		    ALOGV("cannot open device \"%s\"", STREAM_TS_FILE);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:170:            ALOGV("open device \"%s\" ok 0x%x \n", STREAM_TS_FILE,vfd);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:178:		    ALOGV("cannot open device \"%s\" \n", STREAM_TS_SCHED_FILE);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:182:            ALOGV("open device \"%s\" ok \n", STREAM_TS_SCHED_FILE);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:190:	          ALOGV("set drm_mode with secure buffer failed\n");
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:194:            ALOGV("ioctl 0x%x ok", AMSTREAM_IOC_SET_DRMMODE);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:200:		    ALOGV("set drm_mode with normal buffer failed\n");
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:204:            ALOGV("ioctl 0x%x ok", AMSTREAM_IOC_SET_DRMMODE);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:209:		ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:213:			ALOGV("set video format failed");
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:218:			ALOGV("set video PID failed");
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:250:			ALOGV("set AMSTREAM_IOC_SYSINFO");
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:253:		ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:257:		ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:261:			ALOGV("set audio format failed");
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:266:			ALOGV("set audio PID failed");
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:277:		ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:281:		ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:285:			ALOGV("set subtitle PID failed");
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:291:			ALOGV("set subtitle type failed");
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:300:			ALOGV("amport init failed");
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:307:			ALOGV("cannot open \"%s\"", AMVIDEO_FILE);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:311:			ALOGV("open \"%s\" ok", AMVIDEO_FILE);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:331:  ALOGV("inject data send %d para->vid_fd 0x%x\n", send,para->vid_fd);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:337:            ALOGV("inject data failed errno:%d msg:%s \n", errno, strerror(errno));
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:370:			ALOGV("pause inject");
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:381:			ALOGV("resume inject");
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:384:			ALOGV("illegal media player command");
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:395:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:400:    ALOGE("%s at # %d\n",__FUNCTION__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:437:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:445:    ALOGV("%s at # %d device_type %d\n",__FUNCTION__,__LINE__,para->device_type);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:457:            ALOGV("%s at #line %d ret 0x%x\n",__func__,__LINE__,ret);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:466:            ALOGV("%s at #line %d ret 0x%x\n",__func__,__LINE__,ret);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:474:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:481:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:485:		ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:497:    ALOGV("%s at # %d return %d\n",__FUNCTION__,__LINE__,ret);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:504:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:516:    ALOGV("%s at # %d send %d\n",__FUNCTION__,__LINE__,send);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:526:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:536:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:544:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:552:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:560:    ALOGV("%s at # %d\n",__FUNCTION__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:568:    ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:581:    ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:593:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:602:    ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:613:    ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:623:    ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:631:    ALOGV("%s at #line %d\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:639:    ALOGV("%s at #line %d TODO\n",__func__,__LINE__);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:662:                    ALOGV("%s at # %d states %d\n",__func__,__LINE__,*states);
DemuxWrapper/HardwareDemux/HwDemux/AmHwDemuxWrapper.cpp:666:            ALOGV("illegal command");
DemuxWrapper/HardwareDemux/HwDemux/include/AmHwDemuxWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/Android.bp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/Android.bp:11:    default_applicable_licenses: ["vendor_amlogic_mediahal_demuxwrapper_license"],
DemuxWrapper/HardwareDemux/Android.bp:15:    name: "vendor_amlogic_mediahal_demuxwrapper_license",
DemuxWrapper/HardwareDemux/Android.bp:53:        "liblog",
DemuxWrapper/HardwareDemux/Android.bp:101:        "liblog",
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:16:#define LOG_NDEBUG 0
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:17:#define LOG_TAG "TsAmLinuxDvb"
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:42:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:43:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:44:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:47:    ALOGI("AmLinuxDvb (%p)\n",this);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:60:    FLOGI(mPlayerInstansNo,"end");
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:69:        FLOGE(mPlayerInstansNo,"not enough memory");
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:79:        ALOGI("eventfd error");
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:100:        FLOGE(mPlayerInstansNo,"cannot open \"%s\" (%s)", dmx->dev_name, strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:106:    FLOGE(mPlayerInstansNo,"open (%s) ok! fd:%d \n",dmx->dev_name,fd);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:116:       FLOGE(mPlayerInstansNo,"dvb_free_filter error close fd:%d (%s)\n",fd,strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:118:       FLOGI(mPlayerInstansNo,"dvb_free_filter close fd:%d\n",fd);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:134:            FLOGE(mPlayerInstansNo,"num %d: base:0x%0x, stc:0x%llx\n", stc.num, stc.base, stc.stc);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:136:            FLOGI(mPlayerInstansNo," %d, fail\n", i);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:156:        FLOGE(mPlayerInstansNo,"set section filter failed (%s)", strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:169:        FLOGE(mPlayerInstansNo,"fcntl(fd,F_SETFL,O_NONBLOCK) == -1!");
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:174:        FLOGE(mPlayerInstansNo,"set section filter failed (%s)", strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:177:    FLOGI(mPlayerInstansNo,"%s success\n", __FUNCTION__);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:192:        FLOGE(mPlayerInstansNo,"start filter failed (%s)", strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:205:        FLOGE(mPlayerInstansNo,"ioctl DMX_GET_MEM_INFO failed (%s)", strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:220:            FLOGE(mPlayerInstansNo,"cannot open \"%s\" (%s)", dev_name, strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:228:        FLOGE(mPlayerInstansNo,"ioctl DMX_GET_FILTER_MEM_INFO failed (%s)", strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:243:        FLOGE(mPlayerInstansNo,"ioctl DMX_SET_DECODE_INFO failed (%s)", strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:256:        FLOGE(mPlayerInstansNo,"ioctl DMX_SET_BUFFER_SIZE failed (%s)", strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:266:    ALOGV("dvb_poll_exit");
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:301:            FLOGE(mPlayerInstansNo,"Can't get es data from demux. cnt:%d pollFailCount:%d (%s)",
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:312:            //ALOGI("dvb_poll  i:%d cnt:%d fd:%d\n",i,cnt,fds[i].fd);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:329:        FLOGI(mPlayerInstansNo,"dvb_read fd:%d \n", fd);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:348:            FLOGE(mPlayerInstansNo,"read demux failed (%s) %d", strerror(errno), errno);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:362:        FLOGE(mPlayerInstansNo,"cannot open \"%s\" (%s)", name, strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:365:    FLOGI(mPlayerInstansNo,"open %s  ok \n", name);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:370:        FLOGE(mPlayerInstansNo,"cannot open \"%s\" (%s)", name, strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:375:        FLOGI(mPlayerInstansNo,"set INPUT_LOCAL \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:379:            FLOGI(mPlayerInstansNo,"set hw souece :%d\n",dev->dev_no);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:381:                FLOGE(mPlayerInstansNo, "AMDMX_SET_HW_SOURCE ioctl failed %s\n", strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:387:        FLOGI(mPlayerInstansNo,"set INPUT_DEMOD \n" );
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:392:        FLOGI(mPlayerInstansNo,"set INPUT_LOCAL_SEC \n" );
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:396:        FLOGI(mPlayerInstansNo,"set INPUT_USB_CAMCARD \n" );
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:400:    FLOGI(mPlayerInstansNo,"DMX_SET_INPUT ret:%d\n", ret);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:402:        FLOGE(mPlayerInstansNo,"dvr_open ioctl failed %s\n", strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:419:        FLOGI(mPlayerInstansNo,"buf_start 0x%lx buf_end 0x%lx left %d size %d\n",
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:435:                //FLOGE(mPlayerInstansNo,"Write DVR data failed:%d(%s)",ret,strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:444:            FLOGE(mPlayerInstansNo,"timeout(%" PRId64 ") \n",timeout);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:450:            FLOGE(mPlayerInstansNo,"INPUT_LOCAL_SEC left  0x%x\n",left);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:478:        FLOGE(mPlayerInstansNo,"ioctl DMX_GET_DMA_BUF_FD failed (%s)", strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:483:    // FLOGI(mPlayerInstansNo,"export dma fd:%d, 0x%x", info->fd, DMX_GET_DMA_BUF_FD);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:497:        FLOGE(mPlayerInstansNo,"ioctl DMX_GET_DMA_BUF_INFO failed (%s)", strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmLinuxDvb.cpp:503:        // FLOGI(mPlayerInstansNo, "export dma info: pts_dts_flag=%u, video_pts=0x%" PRIx64 ", video_dts=0x%" PRIx64
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmDmxDrive.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmDmxDrive.cpp:10:#define LOG_NDEBUG 0
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmDmxDrive.cpp:11:#define LOG_TAG "TsAmDmxDrive"
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmDmxDrive.cpp:13:#include <utils/Log.h>
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmDmxDrive.cpp:30:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmDmxDrive.cpp:31:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmDmxDrive.cpp:32:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmDmxDrive.cpp:36:    ALOGI("AmLinuxDvb (%p)\n",this);
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmDmxDrive.cpp:45:    FLOGI(mPlayerInstansNo,"end");
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmDmxDrive.cpp:58:            FLOGE(mPlayerInstansNo,"cannot open \"%s\" (%s)", dev_name, strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/Common/AmDmxDrive.cpp:66:        FLOGE(mPlayerInstansNo,"ioctl DMX_GET_FILTER_MEM_INFO failed (%s)", strerror(errno));
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:12:#define LOG_NDEBUG 0
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:13:#define LOG_TAG "TsAmDmxDevice"
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:14:#include <utils/Log.h>
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:26:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:27:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:28:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:34:    FLOGI(mPlayerInstansNo,"");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:49:    FLOGI(mPlayerInstansNo,"end");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:62:        FLOGE(mPlayerInstansNo,"invalid filter id, must in %d~%d", 0, AMDMX_FILTER_COUNT-1);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:69:        FLOGE(mPlayerInstansNo,"filter %d has not been allocated", filter_id);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:95:   // ALOGI("dmx_non_sec_es_data in \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:110:                   // ALOGE("dmx_non_sec_es_data read head error! sec_len:%d \n",sec_len);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:129:                ALOGI("[No-%d](%p) dvb_read retry sec_len:%d ReadDmxNonSecEsSize:%d esHeader->len:%d ",
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:145:                    ALOGI("[No-%d](%p) mReadDmxNonSecEsSize:%d esHeader->len:%d\n",
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:175:    // ALOGI("dmx_non_sec_es_data out \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:230:    ALOGI("[No-%d](%p) dmx_data_thread start ",dev->mPlayerInstansNo,dev);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:304:    ALOGI("[No-%d](%p) dmx_data_thread end ",dev->mPlayerInstansNo,dev);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:364:        FLOGI(mPlayerInstansNo,"demux device %d has already been opened", dev_no);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:371:    FLOGI(mPlayerInstansNo,"");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:431:        FLOGI(mPlayerInstansNo,"no free section filter");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:469:        FLOGI(mPlayerInstansNo,"set sec filter %d PID: %d filter: %02x:%02x %02x:%02x %02x:%02x %02x:%02x %02x:%02x %02x:%02x %02x:%02x %02x:%02x",
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:510:        FLOGI(mPlayerInstansNo,"set pes filter %d PID %d", fhandle, params->pid);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmDmx.cpp:532:    FLOGI(mPlayerInstansNo,"end");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:12:#define LOG_NDEBUG 0
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:13:#define LOG_TAG "TsAmHwMultiDemuxWrapper"
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:33:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:34:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:35:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:42:    // ALOGI("AmHwMultiDemuxWrapper getVideoEsData ---> len:%d \n",len);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:46:        ALOGI("[No-%d](%p) getVideoEsData mStopGetVideoEsData\n",mDemuxWrapper->mPlayerInstansNo,mDemuxWrapper);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:65:        ALOGI("[No-%d]split length:%d, dmxSecEsDataCount %d, dmxSecEsNextDataSize:%d lastNeedSize:%d\n",
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:111:            ALOGI("[No-%d](%p) dicontinue PtsBefore:%" PRId64 " PtsAfter:%" PRId64 " diff:%" PRId64 "  \n",
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:121:            ALOGI("[No-%d](%p) buf_start:0x%x buf_end:0x%x  data_start:0x%x data_end:0x%x pts:%" PRId64 "(%" PRId64 ") size:%d flag:0x%x\n",
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:134:                ALOGI("[No-%d](%p) buf_start:0x%x buf_end:0x%x  data_start:0x%x data_end:0x%x pts:%" PRId64 "(%" PRId64 ") size:%d flag:0x%x\n",
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:154:                ALOGI("[No-%d](%p) time-consuming:%" PRId64 "us frame_rate:%" PRId32 "fps dmxEsDataCount:%" PRId32 " \n",
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:178:            //ALOGI("[No-%d](%p) pts_dts_flag：0x%x --> 0x%x\n",mDemuxWrapper->mPlayerInstansNo,mDemuxWrapper,dmxEsdata->pts_dts_flag,dmxEsdata->pts_dts_flag & 0x8);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:182:                ALOGI("[No-%d](%p) PostVideoEsinvalid \n",mDemuxWrapper->mPlayerInstansNo,mDemuxWrapper);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:193:            ALOGI("[No-%d](%p) PostVideoEsvalid \n",mDemuxWrapper->mPlayerInstansNo,mDemuxWrapper);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:239:    //ALOGI("AmHwMultiDemuxWrapper getAudioEsData ---> len:%d \n",len);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:261:        //ALOGI("AmHwMultiDemuxWrapper mStopGetAudioEsData\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:262:        ALOGI("[No-%d](%p) getAudioEsData mStopGetAudioEsData\n",mDemuxWrapper->mPlayerInstansNo,mDemuxWrapper);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:271:        //ALOGI("---->audio es error! AudioEsHead->len:%d len:%d flag:%d \n",AudioEsHead->len,len,AudioEsHead->pts_dts_flag);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:272:        ALOGI("[No-%d](%p)audio es error! AudioEsHead->len:%d len:%d flag:%d\n",
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:286:        ALOGI("[No-%d](%p) audio pts:%" PRId64 " len:%d\n",mDemuxWrapper->mPlayerInstansNo,
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:311:        ALOGI("TsAmHwMultiDemuxWrapper enable splice es mode as default");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:312:        if (ammh_filesystem_writefile("/sys/module/amlogic_dvb_demux/parameters/video_es_splice","1") != 0) {
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:314:                ALOGI("TsAmHwMultiDemuxWrapper set video_es_splic disable \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:321:        ALOGI("TsAmHwMultiDemuxWrapper ptsserver dev_open [%s] ,ret=%d %d(%s)\n",
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:333:        ALOGI("TsAmHwMultiDemuxWrapper ptsserver ioctl cmd [%s],ret:%d %d(%s)\n",
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:339:            if (ammh_filesystem_writefile("/sys/module/amlogic_dvb_demux/parameters/video_es_splice","1") != 0) {
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:340:                ALOGI("TsAmHwMultiDemuxWrapper set video_es_splic disable \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:353:    ALOGI("AmHwMultiDemuxWrapper %p, Pipeline:%d, V4L2mode:%d\n",this, PipeLineMode, V4L2Mode);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:382:    ALOGI("[%s/%d] isSupport4K:%d video_buf_size=%zu, audio_buf_size=%zu\n",
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:389:        if (ammh_filesystem_writefile("/sys/module/amlogic_dvb_demux/parameters/video_buf_size",strVideoSize) != 0) {
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:390:            ALOGE("set video_buf_size erro %p\n",this);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:395:        if (ammh_filesystem_writefile("/sys/module/amlogic_dvb_demux/parameters/audio_buf_size",strAudioSize) != 0) {
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:396:            ALOGE("set audio_buf_size erro %p\n",this);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:449:    FLOGI(mPlayerInstansNo,"in");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:471:    FLOGI(mPlayerInstansNo,"end");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:496:    FLOGI(mPlayerInstansNo,"dev_no:%d device_type:%d drm_mode:%d tf_passthrough:%d\n",
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:533:        FLOGI(mPlayerInstansNo, "[mediahal_kpi] first write data to demux\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:587:        FLOGI(mPlayerInstansNo,"mCycleEsVideoQueue.size : %d \n",size);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:600:    FLOGI(mPlayerInstansNo,"aid : %d \n",aid);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:631:    FLOGI(mPlayerInstansNo,"aparam.flags:0x%x\n",aparam.flags );
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:633:    FLOGI(mPlayerInstansNo,"AM_DMX_AllocateFilter\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:635:        FLOGE(mPlayerInstansNo,"Audio AM_DMX_AllocateFilter error\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:639:    FLOGI(mPlayerInstansNo,"(fid:%d) AM_DMX_SetCallback \n",fid_audio);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:641:        FLOGE(mPlayerInstansNo,"Audio AM_DMX_SetCallback error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:645:    FLOGI(mPlayerInstansNo,"AM_DMX_SetBufferSize\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:647:        FLOGE(mPlayerInstansNo,"Audio AM_DMX_SetBufferSize error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:651:    FLOGI(mPlayerInstansNo,"AM_DMX_SetPesFilter \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:653:        FLOGE(mPlayerInstansNo,"Audio AM_DMX_SetPesFilter error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:657:    FLOGI(mPlayerInstansNo," AM_DMX_StartFilter \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:659:        FLOGE(mPlayerInstansNo,"Audio AM_DMX_StartFilter error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:663:    FLOGI(mPlayerInstansNo,"ok\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:683:    FLOGI(mPlayerInstansNo,"vpid:0x%x seculevel %d\n",vid,seculevel);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:714:    FLOGI(mPlayerInstansNo,"vparam.flags:0x%x  seculevel:%d\n",vparam.flags,seculevel);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:716:    FLOGI(mPlayerInstansNo,"AM_DMX_AllocateFilter\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:718:        FLOGE(mPlayerInstansNo,"video AM_DMX_AllocateFilter error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:723:    FLOGI(mPlayerInstansNo,"(fid:%d) AM_DMX_SetCallback\n",fid_video);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:725:        FLOGE(mPlayerInstansNo,"video AM_DMX_SetCallback error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:730:    FLOGI(mPlayerInstansNo,"AM_DMX_SetBufferSize\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:732:        FLOGE(mPlayerInstansNo,"video AM_DMX_SetBufferSize error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:737:    FLOGI(mPlayerInstansNo,"AM_DMX_SetPesFilter\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:739:        FLOGE(mPlayerInstansNo,"video AM_DMX_SetPesFilter error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:744:    FLOGI(mPlayerInstansNo,"AM_DMX_StartFilter\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:746:        FLOGE(mPlayerInstansNo,"video AmDemuxWrapperSetVideoParam error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:750:    FLOGI(mPlayerInstansNo,"ok\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:758:    FLOGI(mPlayerInstansNo,"pcr pid:0x%x \n",Pcrpid);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:760:        FLOGE(mPlayerInstansNo,"set mDemuxPara.pcr_id == pcr pid:0x%x \n",Pcrpid);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:793:    FLOGI(mPlayerInstansNo,"PcrParam.flags : 0x%x  \n",PcrParam.flags );
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:795:    FLOGI(mPlayerInstansNo,"AM_DMX_AllocateFilter\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:797:        FLOGE(mPlayerInstansNo,"video AM_DMX_AllocateFilter error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:802:    FLOGI(mPlayerInstansNo,"(fid:%d) AM_DMX_SetCallback\n",fid_pcr);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:804:        FLOGE(mPlayerInstansNo,"video AM_DMX_SetCallback error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:811:    FLOGI(mPlayerInstansNo,"AM_DMX_SetBufferSize bufferSize:%d\n",bufferSize);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:813:        FLOGE(mPlayerInstansNo,"video AM_DMX_SetBufferSize error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:818:    FLOGI(mPlayerInstansNo,"AM_DMX_SetPesFilter\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:820:        FLOGE(mPlayerInstansNo,"video AM_DMX_SetPesFilter error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:825:    FLOGI(mPlayerInstansNo,"AM_DMX_StartFilter\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:827:        FLOGE(mPlayerInstansNo,"video AmDemuxWrapperSetVideoParam error \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:831:    FLOGI(mPlayerInstansNo,"ok\n");
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:888:            // FLOGI(mPlayerInstansNo, "AmDemuxWrapperExportDmaFd:%d\n", EsdataInfo->dma_fd);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:949:    FLOGI(mPlayerInstansNo,"AmDemuxWrapperVideoLoopDisable:%d\n", enable);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:956:    FLOGI(mPlayerInstansNo,"AmDemuxWrapperAudioLoopDisable:%d\n", enable);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:970:        FLOGI(mPlayerInstansNo,"video 0x%x\n",mDemuxPara.vid_id);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:982:        FLOGI(mPlayerInstansNo,"audio 0x%x\n",mDemuxPara.aud_id);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:987:        FLOGI(mPlayerInstansNo,"pcr 0x%x\n",mDemuxPara.pcr_id);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:999:            FLOGI(mPlayerInstansNo,"mEsDataQueue.size(%d) > 200\n",(int)mEsDataQueue.size());
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:1086:            ALOGE("reach max size!:%d", mCurQueueSize);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:1096:                ALOGI("[%s/%d] mallocESBuffer failed, NULL return\n", __FUNCTION__, __LINE__);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:1151:        ALOGI("[%s/%d] mIdleQueue is empty", __FUNCTION__, __LINE__);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:1159:        ALOGI("[%s/%d] esData is NULL", __FUNCTION__, __LINE__);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:1167:        ALOGI("[%s/%d] esData->data is NULL", __FUNCTION__, __LINE__);
DemuxWrapper/HardwareDemux/MultiHwDemux/EsdataSink/AmHwMultiDemuxWrapper.cpp:1247:        FLOGI(mPlayerInstansNo,"frameRate:%d\n", frame_rate);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:11:#define LOG_NDEBUG 0
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:12:#define LOG_TAG "TsAmStreamControl"
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:15:#include <utils/Log.h>
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:43:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:44:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:45:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:49:        ALOGE("input parameter was NULL, propGetInt failed!");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:55:        ALOGI("%s set = %d\n", str, *variable);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:58:        ALOGI("%s is not set used def = %d\n", str, *variable);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:68:    ALOGI("AmStreamControl %p\n",this);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:97:    FLOGI(mPlayerInstansNo,"in (%p)\n",this);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:108:    FLOGI(mPlayerInstansNo,"out (%p)\n",this);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:113:    FLOGI(mPlayerInstansNo,"in (%p)\n",this);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:135:        FLOGI(mPlayerInstansNo,"mDemuxId %d mediasyncId:0x%x",mDemuxId,info->mediasyncId);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:153:    FLOGI(mPlayerInstansNo,"out (%p)\n",this);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:170:    FLOGI(mPlayerInstansNo,"in (%p)\n",this);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:177:            FLOGI(mPlayerInstansNo,"delete mediasync");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:199:    FLOGI(mPlayerInstansNo,"out (%p)\n",this);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:208:        FLOGI(mPlayerInstansNo,"mDmxFilterMemInfo->filter_num : %d mVpid:0x%x mApid:0x%x\n",
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:219:                    FLOGI(mPlayerInstansNo,"apid:%d, type:%d", aPid, mDmxFilterMemInfo->info[i].type);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:267:                    FLOGI(mPlayerInstansNo,"apid:%d", aPid);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:352:        FLOGI(mPlayerInstansNo,
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:366:        FLOGI(mPlayerInstansNo,
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:423:        FLOGI(mPlayerInstansNo,
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:454:            FLOGI(mPlayerInstansNo, "switch audiotrack stop");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:491:        FLOGI(mPlayerInstansNo, "videoNeedTry:%d, audioNeedTry:%d, pauseStatus:%d", videoNeedTry, audioNeedTry, pauseStatus);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:514:            FLOGI(mPlayerInstansNo, "lastStatus: %d, videoRenderPts: %" PRIx64 ", videoHoldCount: %" PRId64 "",
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:522:                FLOGI(mPlayerInstansNo,
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:552:        FLOGI(mPlayerInstansNo, "pauseStatus:%d", pauseStatus);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:575:                FLOGI(mPlayerInstansNo,
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:608:                    FLOGI(mPlayerInstansNo,
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:645:            FLOGI(mPlayerInstansNo, "switch audiotrack start");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:655:                            FLOGI(mPlayerInstansNo,
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:676:            FLOGI(mPlayerInstansNo,"vpid:0x%x %s apid:0x%x %s \n",
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:688:            FLOGI(mPlayerInstansNo,"video only vpid:0x%x %s",
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:698:            FLOGI(mPlayerInstansNo,"audio only apid:0x%x %s",
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:713:        FLOGI(mPlayerInstansNo,"AmStreamControl version not match");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:737:        FLOGI(mPlayerInstansNo, "%s", oss.str().c_str());
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:742:            FLOGI(mPlayerInstansNo,"<-------> sync id invalid streamcontrol not work");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:754:            FLOGI(mPlayerInstansNo,"<------- retry \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:756:            FLOGI(mPlayerInstansNo,"-------> ok \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:783:        FLOGI(mPlayerInstansNo,"<-------> in WriteTsSize:%" PRId64 ", mVpid:%d,  mApid:%d\n",WriteTsSize, mVpid, mApid);
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:787:        FLOGI(mPlayerInstansNo,"<-------> sync id invalid streamcontrol not work");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:798:            FLOGI(mPlayerInstansNo,"<------- retry \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:800:            FLOGI(mPlayerInstansNo,"-------> ok \n");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:815:    FLOGI(mPlayerInstansNo, "flush");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmStreamControl.cpp:817:        FLOGI(mPlayerInstansNo, "flush mVideoFirstRenderPts:%" PRIx64 " mRecordVideoNewPts:%" PRIx64 "\n",
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmDmxDevice.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmDmxDevice.cpp:10:#define LOG_NDEBUG 0
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmDmxDevice.cpp:11:#define LOG_TAG "TsAmDmxDevice"
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmDmxDevice.cpp:13:#include <utils/Log.h>
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmDmxDevice.cpp:26:#define FLOGV(number,fmt,...) ALOGV("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmDmxDevice.cpp:27:#define FLOGI(number,fmt,...) ALOGI("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmDmxDevice.cpp:28:#define FLOGE(number,fmt,...) ALOGE("[No-%d](%p) %s " fmt, number,this, __FUNCTION__,##__VA_ARGS__)
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmDmxDevice.cpp:33:    FLOGI(mPlayerInstansNo,"");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmDmxDevice.cpp:38:    FLOGI(mPlayerInstansNo,"in");
DemuxWrapper/HardwareDemux/MultiHwDemux/StreamControl/AmDmxDevice.cpp:43:    FLOGI(mPlayerInstansNo,"end");
DemuxWrapper/HardwareDemux/MultiHwDemux/include/AmDmx.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/MultiHwDemux/include/am_mem.h:2: * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/MultiHwDemux/include/am_mem.h:12: * \author Gong Ke <ke.gong@amlogic.com>
DemuxWrapper/HardwareDemux/MultiHwDemux/include/AmLinuxDvb.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/MultiHwDemux/include/AmDmxDevice.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/MultiHwDemux/include/am_util.h:2: * Copyright (c) 2014 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/MultiHwDemux/include/am_util.h:12: * \author Gong Ke <ke.gong@amlogic.com>
DemuxWrapper/HardwareDemux/MultiHwDemux/include/AmStreamControl.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/MultiHwDemux/include/AmDmxDrive.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/MultiHwDemux/include/AmHwMultiDemuxWrapper.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/include/AmHwDemuxInterface.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/include/DemuxWrapperProperty.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
DemuxWrapper/HardwareDemux/include/DemuxWrapperProperty.h:16:#define PROPERTY_DEMUXWRAPPER_DEMUXPTS             "vendor.media.mediahal.demuxwrapper.demuxpts"      /* demux pts log print */
DemuxWrapper/HardwareDemux/include/AmDemuxWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/SoftwareDemux/AmSwDemuxWrapper.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/SoftwareDemux/Android.bp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/SoftwareDemux/Android.bp:11:    default_applicable_licenses: ["vendor_amlogic_mediahal_demuxwrapper_license"],
DemuxWrapper/SoftwareDemux/Android.bp:15:    name: "vendor_amlogic_mediahal_demuxwrapper_license",
DemuxWrapper/SoftwareDemux/Android.bp:47:        "liblog",
DemuxWrapper/SoftwareDemux/Android.bp:87:        "liblog",
DemuxWrapper/SoftwareDemux/Android.bp:127:        "liblog",
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:2:* Copyright (c) 2024 Amlogic, Inc. All rights reserved.
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:10:#define LOG_TAG "AmDssDemuxCore"
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:12:#include <cutils/log.h>
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:165:        ALOGE("malloc audData fail");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:172:        ALOGE("malloc DssSwDmxMem fail");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:222:        ALOGE("parameter is invalid, vidpid:%d, audpid:%d", vidPid, audPid);
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:448:        ALOGE("one sec buf is too low, please check. [%u - %u]", willCopyBufSize, mem->vidEsData.esDataMaxSize);
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:476:        ALOGI("drop dirty data");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:482:            ALOGE("copyVidEsData failed");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:706:                    ALOGE("audio es len[%d] is very large, so will relarge it", len);
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:709:                        ALOGE("malloc fail");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:748:        ALOGE("parameter is invalid.");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:762:            ALOGE("secure buffer is not supported yet.");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:784:            ALOGE("av pid not set, fail.");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:793:            ALOGE("why data size not %d * n, need check it", DSS_ONE_PACKET_SIZE);
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:803:            ALOGE("need Descrambling data. flag:%d, flag_cf:%d", flag, mem->dssHeader.flagCF);
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.c:808:        // ALOGE("data: %x %x %x %x %x %x, flagPF:%d, flagBB:%d, flagCF:%d, flagCS:%d, scid:0x%x, tbCC:%d, tbHD:%d",
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.cpp:10:#define LOG_NDEBUG 0
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.cpp:11:#define LOG_TAG "AmDssDemux"
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.cpp:28:        ALOGE("output thread is null");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.cpp:37:    //     ALOGE("open esdump.es failed");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.cpp:77:                ALOGE("push es data failed, type:%d, size:%d, pts:%" PRId64 ", dts:%" PRId64 " ",
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.cpp:89:    ALOGE("output thread exit");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.cpp:97:        ALOGE("input thread is null");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.cpp:122:    ALOGD("input thread exit.");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.cpp:175:            ALOGI("pthread_create ok InputThread:%ld\n",mInputThreadId);
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.cpp:177:            ALOGE("pthread_create errno:%d (%s) \n",errno,strerror(errno));
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.cpp:182:        ALOGI("pthread_create ok OutputThread:%ld\n",mOutputThreadId);
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.cpp:184:        ALOGE("pthread_create errno:%d (%s) \n",errno,strerror(errno));
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxStream.h:2: * Copyright (c) 2024 Amlogic, Inc. All rights reserved.
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxStream.c:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxStream.c:9:#define LOG_TAG "AmDssDemuxStream"
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxStream.c:10:#include <cutils/log.h>
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxStream.c:63:            ALOGE("open file failed");
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxStream.c:68:    ALOGE("create stream, size=%d, nodeCnt=%d, bufMaxSize=%d, buffer:%p, bufferEnd: %p", size, stream->bufNodeCnt, stream->bufMaxSize,
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxStream.c:111://     ALOGE("bufWrIdx = %d, bufRdIdx = %d, buffer:%p, bufferRead:%p, bufferWrite:%p , bufferEnd:%p, hasread:%d",
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxStream.c:132:        ALOGE("Invalid parameters: dmxStream=%p, data=%p, size=%d", dmxStream, data, size);
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxStream.c:160:                // ALOGE("WriteStream timeout, written=%u/%u", total_written, size);
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxStream.c:217:        ALOGE("readSize < DSS_ONE_PACKET_SIZE, readSize = %d", readSize);
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemuxCore.h:2: * Copyright (c) 2024 Amlogic, Inc. All rights reserved.
DemuxWrapper/SoftwareDemux/AmDssDemux/AmDssDemux.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/SoftwareDemux/include/AmSwDemuxBase.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
DemuxWrapper/SoftwareDemux/include/AmSwDemuxInterface.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
0001-mediahal-No-Video-Change-event-1-1.patch:3: <sining.huang@amlogic.com>
0001-mediahal-No-Video-Change-event-1-1.patch:13:sycn patch from r-amlogic-hybrid-v3.4
0001-mediahal-No-Video-Change-event-1-1.patch:24:Signed-off-by: “sining.huang” <sining.huang@amlogic.com>
0001-mediahal-No-Video-Change-event-1-1.patch:77:                 FLOGI(mPlayerInstansNo,"VIDEO FORMAT CHANGED [%d x %d] @%d\n",
0001-mediahal-No-Video-Change-event-1-1.patch:124:+        FLOGI(mPlayerInstansNo,"frameRate:%d\n", frame_rate);
0001-mediahal-No-Video-Change-event-1-1.patch:168:     FLOGI(mPlayerInstansNo,"ok");
0001-mediahal-No-Video-Change-event-1-1.patch:177:+        FLOGI(mPlayerInstansNo,"frameRate:%d\n", frame_rate);
0001-mediahal-No-Video-Change-event-1-1.patch:232:             FLOGV(mPlayerInstansNo,"VIDEO FORMAT CHANGED [%d x %d] @%d fps\n",
0001-mediahal-No-Video-Change-event-1-1.patch:258:     MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"fccenable:%d, a-cache:[%d ms, %" PRId64 " ms], "
0001-mediahal-No-Video-Change-event-1-1.patch:276:     propGetInt("vendor.mediahal.loglevels", (int*)&gloglevel);
0001-mediahal-No-Video-Change-event-1-1.patch:281:     MVRLog(LOG_INFO, "[%s] mFreeRun:%d mVideoSyncMode:%d\n", __func__, mFreeRun, mVideoSyncMode);
0001-mediahal-No-Video-Change-event-1-1.patch:285:             MVRLog(LOG_DEBUG_LEVEL2, "[%s] mediaTimeUs:%" PRId64 " videopolicy:%d\n", __func__, mediaTimeUs, mVideoPolicy.videopolicy);
0001-mediahal-No-Video-Change-event-1-1.patch:306:+        MVRLog(LOG_ERR, "[%s] mTunnel is null!\n", __func__);
0001-mediahal-No-Video-Change-event-1-1.patch:320:+        MVRLog(LOG_ERR, "[%s] mTunnel is null!\n", __func__);
0001-mediahal-No-Video-Change-event-1-1.patch:331:     MVRLog(LOG_DEBUG_LEVEL1, "[%s] ==in== [%d] fd:%d, timestampUs:%" PRId64 "\n", __func__, ++mInFrameCount, fd, timestampUs);
0001-mediahal-No-Video-Change-event-1-1.patch:431:-                FLOGI(mPlayerInstansNo,"vdec.status : 0x%x UNSUPPORT\n",vdec.status);
0001-mediahal-No-Video-Change-event-1-1.patch:453:+            FLOGI(mPlayerInstansNo,"vdec.status : 0x%x UNSUPPORT\n",vdec.status);
0001-mediahal-No-Video-Change-event-1-1.patch:480:-        FLOGI(mPlayerInstansNo,"notifyEvent, EVENT_TYPE_VIDEO_CHANGED [%d x %d] @ %d, asp %d vpid:%d\n",
0001-mediahal-No-Video-Change-event-1-1.patch:481:+        FLOGI(mPlayerInstansNo,"notifyEvent, EVENT_TYPE_VIDEO_CHANGED [%d x %d] @ %d, asp %d vpid:%d, sar [%d x %d], dar [%d x %d]\n",
0001-mediahal-No-Video-Change-event-1-1.patch:505:                     //ALOGI("in offset:%lld pts_32:%d pts_64:%lld \n",vf.pts,pts_32,pts_64);
0001-mediahal-No-Video-Change-event-1-1.patch:512:     FLOGI(mPlayerInstansNo,"terminates");
0001-mediahal-No-Video-Change-event-1-1.patch:539:         ALOGE("playerID is not match read_vdec_id=%d,mPlayerInstansNo=%d",read_vdec_id,mPlayerInstansNo);
0001-mediahal-No-Video-Change-event-1-1.patch:544:-            ALOGE("AMSTREAM_IOC_UD_FLUSH_USERDATA failed");
0001-mediahal-No-Video-Change-event-1-1.patch:552:+    //         ALOGE("AMSTREAM_IOC_UD_FLUSH_USERDATA failed");
0001-mediahal-No-Video-Change-event-1-1.patch:564:-                ALOGI("MPEG AFD notify %d\n", afd.af);
0001-mediahal-No-Video-Change-event-1-1.patch:565:+                ALOGI("MPEG AFD notify %d, flag:%d, size:%d\n", afd.af, afd.af_flag, sizeof(AM_USERDATA_AFD_t));
0001-mediahal-No-Video-Change-event-1-1.patch:619:     ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
0001-mediahal-No-Video-Change-event-1-1.patch:625:+    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
0001-mediahal-No-Video-Change-event-1-1.patch:632:     ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
0001-mediahal-No-Video-Change-event-1-1.patch:665:+ * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
0001-mediahal-No-Video-Change-event-1-1.patch:744:+ * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
0001-mediahal-No-Video-Change-event-1-1.patch:752:+#define LOG_TAG "TIME_TRACE"
0001-mediahal-No-Video-Change-event-1-1.patch:754:+#include <utils/Log.h>
0001-mediahal-No-Video-Change-event-1-1.patch:759:+    // ALOGI("init_stb_trace\n");
0001-mediahal-No-Video-Change-event-1-1.patch:761:+        ALOGE("input parameter was NULL, init_stb_trace failed!\n");
0001-mediahal-No-Video-Change-event-1-1.patch:770:+        ALOGE("input parameter was NULL, stb_trace_dbg failed!");
0001-mediahal-No-Video-Change-event-1-1.patch:775:+    ALOGI("[%s][%d] step: No-%d %s, time: %u, consume: %u \n", trace_info->module_name, key_step, trace_info->player_instansNo, step_str, cur_step_time, interval);
0001-mediahal-No-Video-Change-event-1-1.patch:785:+ * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
0001-mediahal-No-Video-Change-event-1-1.patch:856:     FLOGI(mPlayerInstansNo,"~TunerPassthroughVideo %p \n",this);
0001-mediahal-No-Video-Change-event-1-1.patch:870:     FLOGI(mPlayerInstansNo,"~TunerPassthroughVideo return %p\n",this);
0001-mediahal-No-Video-Change-event-1-1.patch:875:     FLOGI(mPlayerInstansNo,"vcodecType:%d\n", mVideoCfg.vcodecType);
0001-mediahal-No-Video-Change-event-1-1.patch:896:     FLOGI(mPlayerInstansNo,"(%p) StartVideoDecoding\n",this);
0001-mediahal-No-Video-Change-event-1-1.patch:902:         FLOGI(mPlayerInstansNo,"new mVideoDecoder\n");
0001-mediahal-No-Video-Change-event-1-1.patch:911:                 FLOGI(mPlayerInstansNo,"mVideoDecoder->SetRender\n");
0001-mediahal-No-Video-Change-event-1-1.patch:918:-    FLOGI(mPlayerInstansNo,"(%p) FlushVideoDecoding\n",this);
0001-mediahal-No-Video-Change-event-1-1.patch:931:-    FLOGI(mPlayerInstansNo,"(%p) FlushVideoDecoding response\n",this);
0001-mediahal-No-Video-Change-event-1-1.patch:940:     FLOGI(mPlayerInstansNo,"initCheck %d\n", mState == INITIALIZING);
0001-mediahal-No-Video-Change-event-1-1.patch:948:+    FLOGI(mPlayerInstansNo,"(%p) FlushVideoDecoding\n",this);
0001-mediahal-No-Video-Change-event-1-1.patch:959:+    FLOGI(mPlayerInstansNo,"(%p) FlushVideoDecoding response\n",this);
0001-mediahal-No-Video-Change-event-1-1.patch:971:     FLOGI(mPlayerInstansNo,"(%p) StopVideoDecoding\n",this);
0001-mediahal-No-Video-Change-event-1-1.patch:979:     FLOGI(mPlayerInstansNo,"(%p) StopVideoDecoding response\n",this);
0001-mediahal-No-Video-Change-event-1-1.patch:1007:+    // ALOGV("onEvent %d, mPlayerCallbackFn %p, param %p\n", event, mPlayerCallbackFn, param);
0001-mediahal-No-Video-Change-event-1-1.patch:1024:+                    FLOGI(mPlayerInstansNo,"AFD GOT afd 0x%" PRIX64, (int64_t)((uint8_t*)ev.event.mpeg_user_data.data));
0001-mediahal-No-Video-Change-event-1-1.patch:1026:+                    FLOGI(mPlayerInstansNo,"USERDATA param nullptr\n");
0001-mediahal-No-Video-Change-event-1-1.patch:1034:+                FLOGI(mPlayerInstansNo,"VIDEO FORMAT CHANGED [%d x %d] @%d, %d\n",
0001-mediahal-No-Video-Change-event-1-1.patch:1040:+                FLOGI(mPlayerInstansNo,"ASAPECT RATIO CHANGE SAR[%d x %d] DAR[%d x %d]\n",
0001-mediahal-No-Video-Change-event-1-1.patch:1048:+                FLOGI(mPlayerInstansNo,"VIDEO FORMAT param %p, paramsize %d\n",param, paramsize);
0001-mediahal-No-Video-Change-event-1-1.patch:1053:+                FLOGI(mPlayerInstansNo,"AUDIO FORMAT CHANGED ch=%u ch_mask=%u samplerate=%u\n",
0001-mediahal-No-Video-Change-event-1-1.patch:1059:+                FLOGE(mPlayerInstansNo,"AUDIO FORMAT param %p, paramsize %d\n", param, paramsize);
0001-mediahal-No-Video-Change-event-1-1.patch:1076:+            FLOGI(mPlayerInstansNo,"isStopVideo:%d,displayer first video\n",mStopVideo);
0001-mediahal-No-Video-Change-event-1-1.patch:1084:+            FLOGI(mPlayerInstansNo,"isStopVideo:%d,decodec first video\n",mStopVideo);
0001-mediahal-No-Video-Change-event-1-1.patch:1092:+            FLOGI(mPlayerInstansNo,"mStopAudio:%d,decodec first audio\n",mStopAudio);
0001-mediahal-No-Video-Change-event-1-1.patch:1099:+            FLOGI(mPlayerInstansNo,"isStopVideo:%d,mStopAudio:%d,av sync done!\n",mStopVideo,mStopAudio);
0001-mediahal-No-Video-Change-event-1-1.patch:1119:+            FLOGI(mPlayerInstansNo,"isStopVideo:%d,frame error count callback \n",mStopVideo);
0001-mediahal-No-Video-Change-event-1-1.patch:1125:+            FLOGI(mPlayerInstansNo,"isStopVideo:%d,videp unsupport \n",mStopVideo);
0001-mediahal-No-Video-Change-event-1-1.patch:1132:+            //FLOGI(mPlayerInstansNo,"video overflow\n");
0001-mediahal-No-Video-Change-event-1-1.patch:1138:+            //FLOGI(mPlayerInstansNo,"video underflow\n");
0001-mediahal-No-Video-Change-event-1-1.patch:1144:+            //FLOGI(mPlayerInstansNo,"audio overflow\n");
0001-mediahal-No-Video-Change-event-1-1.patch:1150:+            //FLOGI(mPlayerInstansNo,"audio underflow\n");
0001-mediahal-No-Video-Change-event-1-1.patch:1155:+            //FLOGI(mPlayerInstansNo,"video invalid timestamp!\n");
0001-mediahal-No-Video-Change-event-1-1.patch:1159:+            //FLOGI(mPlayerInstansNo,"video invalid data!\n");
0001-mediahal-No-Video-Change-event-1-1.patch:1163:+            //FLOGI(mPlayerInstansNo,"audio invalid timestamp!\n");
0001-mediahal-No-Video-Change-event-1-1.patch:1167:+            //FLOGI(mPlayerInstansNo,"audio invalid data!\n");
0001-mediahal-No-Video-Change-event-1-1.patch:1171:+            FLOGV(mPlayerInstansNo,"instance was preempted!\n");
0001-mediahal-No-Video-Change-event-1-1.patch:1185:     ALOGE("onError\n");
0001-mediahal-No-Video-Change-event-1-1.patch:1191:+        FLOGI(mPlayerInstansNo,"not register renderevent callback\n");
0001-mediahal-No-Video-Change-event-1-1.patch:1220:+    ALOGE("packCallBackDataAndSend");
0001-mediahal-No-Video-Change-event-1-1.patch:1224:+        ALOGE("fury send data !");
0001-mediahal-No-Video-Change-event-1-1.patch:1230:+    ALOGE("packCallBackData");
0001-mediahal-No-Video-Change-event-1-1.patch:1256:+            ALOGE("SAR value:%d, report_width:%f, report_height:%f", value, report_width, report_height);
0001-mediahal-No-Video-Change-event-1-1.patch:1269:+                ALOGE("SAR value:%d, dar:%f, report_width:%f, report_height:%f", value, dar, report_width, report_height);
0001-mediahal-No-Video-Change-event-1-1.patch:1277:+        // ALOGE("afd raw data:%llx", (uint32_t)(*(uint32_t *)ev.event.mpeg_user_data.data));
0001-mediahal-No-Video-Change-event-1-1.patch:1291:+        ALOGE("not support video info type:%d", messageType);
0001-mediahal-No-Video-Change-event-1-1.patch:1300:+    ALOGI("playload:%" PRIX64, mVideoInfoValue.payload);
0001-mediahal-No-Video-Change-event-1-1.patch:1305:     FLOGI(mPlayerInstansNo,"StartFast scale:%f\n",scale);
0001-mediahal-No-Video-Change-event-1-1.patch:1312:+    FLOGI(mPlayerInstansNo,"SetRenderCallBackEventFlag flag:%" PRIX64, eventflag);
0001-mediahal-No-Video-Change-event-1-1.patch:1626:+        ALOGI("input parameter was NULL, SetTraceInfo failed! \n");
0001-mediahal-No-Video-Change-event-1-1.patch:1633:     ALOGI("onUpdateDecInfo info %p, size %d\n", info, isize);
0001-mediahal-No-Video-Change-event-1-1.patch:1638:     ALOGV("onEvent event %d, param %p, paramsize %d\n", event, param, paramsize);
0001-mediahal-No-Video-Change-event-1-1.patch:1652:+            ALOGV("VIDEO FORMAT CHANGED [%d x %d] @%d fps\n",
0001-mediahal-No-Video-Change-event-1-1.patch:1674:     ALOGV("VideodecSurfaceWrapper::registerCallback \n");
example/AmTsPlayerMultiExample/AmAnalyseConfigFile.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
example/AmTsPlayerMultiExample/AmTsPlayerMultiExample.cpp:3: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
example/AmTsPlayerMultiExample/AmTsPlayerMultiExample.cpp:42:#include <amlogic/am_gralloc_ext.h>
example/AmTsPlayerMultiExample/Android.mk:43:                    $(TOP)/hardware/amlogic/gralloc
example/AmTsPlayerMultiExample/AmAnalyseConfigFile.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
example/EsVideoDecPlayer/EsVideoDecPlayer.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
example/AmEsModePlayerExample/Android.bp_bk:59:        "hardware/amlogic/gralloc",
example/AmEsModePlayerExample/Android.bp_bk:60:        "vendor/amlogic/common/frameworks/services/systemcontrol",
example/AmEsModePlayerExample/Android.bp_bk:61:        "vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include"
example/AmEsModePlayerExample/Android.bp_bk:76:        "//hardware/amlogic:libamgralloc_ext",
example/AmEsModePlayerExample/AmEsModePlayerExample.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
example/AmEsModePlayerExample/AmEsModePlayerExample.cpp:93:#include <amlogic/am_gralloc_ext.h>
example/AmTsPlayerExample/systemlib_u.go.in:26:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext")
example/AmTsPlayerExample/systemlib_u.go.in:30:        includePath = append(includePath,"vendor/amlogic/common/frameworks/services/systemcontrol","vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include","hardware/amlogic/gralloc")
example/AmTsPlayerExample/systemlib_u.go.in:43:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext@2")
example/AmTsPlayerExample/systemlib_u.go.in:47:        includePath = append(includePath,"hardware/amlogic/gralloc")
example/AmTsPlayerExample/systemlib.go.in:26:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext")
example/AmTsPlayerExample/systemlib.go.in:30:        includePath = append(includePath,"vendor/amlogic/common/frameworks/services/systemcontrol","vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include","hardware/amlogic/gralloc")
example/AmTsPlayerExample/systemlib.go.in:43:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext@2")
example/AmTsPlayerExample/systemlib.go.in:47:        includePath = append(includePath,"hardware/amlogic/gralloc")
example/AmTsPlayerExample/systemLib.go:51:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext")
example/AmTsPlayerExample/systemLib.go:55:        includePath = append(includePath,"hardware/amlogic/gralloc")
example/AmTsPlayerExample/systemLib.go:57:		    includePath = append(includePath,"vendor/amlogic/common/frameworks/services/systemcontrol","vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include")
example/AmTsPlayerExample/systemLib.go:59:		    includePath = append(includePath,"vendor/amlogic/common/frameworks/services/systemcontrol/aidl","vendor/amlogic/common/frameworks/services/systemcontrol/aidl/PQ/include")
example/AmTsPlayerExample/systemLib.go:73:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext@2")
example/AmTsPlayerExample/systemLib.go:77:        includePath = append(includePath,"hardware/amlogic/gralloc")
example/AmTsPlayerExample/Android_p.bp.in:58:        "vendor/amlogic/common/mediahal_sdk/include",
example/AmTsPlayerExample/Android_p.bp.in:79:        "vendor/amlogic/common/mediahal_sdk/include",
example/AmTsPlayerExample/AmTsPlayerExample.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
example/AmTsPlayerExample/AmTsPlayerExample.cpp:42:#include <amlogic/am_gralloc_ext.h>
example/AmTsPlayerExample/AmTsPlayerExample.cpp:107:     int    enablelog;
example/AmTsPlayerExample/AmTsPlayerExample.cpp:222:        sevinfo.enablelog = 0;
example/AmTsPlayerExample/Android.bp.in:7:    // all of the 'license_kinds' from "vendor_amlogic_common_license"
example/AmTsPlayerExample/Android.bp.in:12:    default_applicable_licenses: ["vendor_amlogic_common_license"],
example/AmTsPlayerExample/Android.bp.in:62:        "vendor/amlogic/common/mediahal_sdk/include",
example/AmTsPlayerExample/Android.bp.in:83:        "vendor/amlogic/common/mediahal_sdk/include",
example/AmTsPlayerExample/AndroidVersion.go:48:        p.Include_dirs = append(p.Include_dirs, "vendor/amlogic/common/media_hal/AmTsplayer/include")
example/BootTsPlayerExample/bootlib.go.in:26:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext")
example/BootTsPlayerExample/bootlib.go.in:30:                includePath = append(includePath,"vendor/amlogic/common/frameworks/services/systemcontrol","vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include","hardware/amlogic/gralloc")
example/BootTsPlayerExample/bootlib.go.in:43:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext@2")
example/BootTsPlayerExample/bootlib.go.in:47:        includePath = append(includePath,"hardware/amlogic/gralloc")
example/BootTsPlayerExample/Android.bp:49:        "liblog"
example/BootTsPlayerExample/Android.bp:53:        "vendor/amlogic/common/mediahal_sdk/include",
example/BootTsPlayerExample/BootTsPlayerExample.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
example/BootTsPlayerExample/BootTsPlayerExample.cpp:32:#include <utils/Log.h>
example/BootTsPlayerExample/BootTsPlayerExample.cpp:39:#include <amlogic/am_gralloc_ext.h>
example/BootTsPlayerExample/bootLib.go:49:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext")
example/BootTsPlayerExample/bootLib.go:53:        includePath = append(includePath,"hardware/amlogic/gralloc")
example/BootTsPlayerExample/bootLib.go:55:                includePath = append(includePath,"vendor/amlogic/common/frameworks/services/systemcontrol","vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include")
example/BootTsPlayerExample/bootLib.go:57:                 includePath = append(includePath,"vendor/amlogic/common/frameworks/services/systemcontrol/aidl","vendor/amlogic/common/frameworks/services/systemcontrol/aidl/PQ/include")
example/BootTsPlayerExample/bootLib.go:71:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext@2")
example/BootTsPlayerExample/bootLib.go:75:        includePath = append(includePath,"hardware/amlogic/gralloc")
example/BootTsPlayerExample/bootlib_u.go.in:26:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext")
example/BootTsPlayerExample/bootlib_u.go.in:30:                includePath = append(includePath,"vendor/amlogic/common/frameworks/services/systemcontrol","vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include","hardware/amlogic/gralloc")
example/BootTsPlayerExample/bootlib_u.go.in:43:        sharedlib = append(sharedlib,"//hardware/amlogic:libamgralloc_ext@2")
example/BootTsPlayerExample/bootlib_u.go.in:47:        includePath = append(includePath,"hardware/amlogic/gralloc")
example/BootTsPlayerExample/Android.bp.in:7:    // all of the 'license_kinds' from "vendor_amlogic_common_license"
example/BootTsPlayerExample/Android.bp.in:12:    default_applicable_licenses: ["vendor_amlogic_common_license"],
example/BootTsPlayerExample/Android.bp.in:76:        "vendor/amlogic/common/mediahal_sdk/include",
example/vesplayer/vesplayer.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
example/vesplayer/vesplayer.cpp:224:            //ALOGE("unable to dlopen libmediahal_videodec.so: %s", dlerror());
example/vesplayer/vesplayer.cpp:238:        //ALOGE("can not create AmVideoDec\n");
example/vesplayer/vesplayer.cpp:243:    //ALOGI("getAmVideoDec ok\n");
release_tool.sh:23:GIT_LOG_NUM=10
release_tool.sh:25:GIT_COMMIT_FULL=$(git log -$GIT_LOG_NUM | sed 's/^[ \t]*//g')
release_tool.sh:27:#SOURCE_COMMIT_SHORT=$(git log --oneline -$GIT_LOG_NUM)
release_tool.sh:30:while [ $i -le $GIT_LOG_NUM ]
release_tool.sh:32:  SOURCE_COMMIT_SHORT+="$(git log --oneline -$GIT_LOG_NUM |sed -n "${i}p" | cut -c 1-80)"
release_tool.sh:33:  if [ $i != $GIT_LOG_NUM ];then
release_tool.sh:42:GIT_CHANGED_ID=$(git log -1 | grep Change-Id | awk '{print $2}' | cut -c 1-6)
release_tool.sh:49:#COMMIT_NUMS=$(git log | grep Change-Id | grep -n ${VERSION_FILE} | awk '{print $1-1}')
release_tool.sh:51:COMMIT_NUMS=$(git log | grep "Change-Id: " | grep -n ${BASE_CHANGE_ID} | awk -F ":" '{printf "%d", $1-1}' )
release_tool.sh:55:#    COMMIT_NUMS=$(git log --oneline ${GIT_COMMIT} ^${BASE_COMMIT_ID} | wc -l)
release_tool.sh:66:CUR_COMMIT_MSG=$(git log -1| grep -e '^\s' | sed 's/^[ ]*//g' | grep -v "Change-Id" | grep -v "Signed-off-by")
release_tool.sh:67:#CUR_COMMIT_MSG=$(git log -1 | sed '/Change-Id:/,$d' | sed '/Signed-off-by/,$d'  | sed '/Verify:/,$d' | sed -n '/^$/,$p' |  sed '/^$/d' | sed 's/^[ \t]*//g' | tac | awk 'NF>0 {x=1} x' | tac)
release_tool.sh:68:#CUR_COMMIT_MSG_END=$(git log -1 | sed '/Change-Id:/,$d' | sed '/Signed-off-by/,$d' | sed -n '/^$/,$p' |  sed '/^$/d' | sed 's/^[ \t]*//g' | sed -n '/Verify:/,$p' | tac | awk 'NF>0 {x=1} x' | tac )
release_tool.sh:492:    SDK_COMMIT_MSG=$(git log -1| grep -e '^\s' | sed 's/^[ ]*//g' | grep -v "Change-Id" | grep -v "Signed-off-by")
videoTunnelRenderer/utils/VideoTunnelRendererProperty.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/utils/VideoTunnelRendererProperty.h:15:#define PROPERTY_VIDEOTUNNELRENDERER_LOGlEVELS_OLD  "vendor.mediahal.loglevels"
videoTunnelRenderer/utils/VideoTunnelRendererProperty.h:16:#define PROPERTY_VIDEOTUNNELRENDERER_LOGlEVELS      "vendor.media.mediahal.videotunnelrenderer.loglevels"
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:9:#define LOG_NDEBUG 0
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:10:#define LOG_TAG "VideoSyncFRAC"
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:11:#include <utils/Log.h>
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:25:#include "log_debug.h"
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:30:#define VSFRACLog(level, f,s...) VDLog(level, "[%d##%d]"#f, vsf->playerInfo.instID, vsf->playerInfo.decoderID, ##s)
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:175:        ALOGE("[%s:%d]no videoSyncFrac_priv", __func__, __LINE__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:186:    ALOGI("[%s:%d]", __func__, __LINE__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:187:    videoTunnelRenderer_propertyGetInt(PROPERTY_VIDEOTUNNELRENDERER_LOGlEVELS, PROPERTY_VIDEOTUNNELRENDERER_LOGlEVELS_OLD, (int*)&gloglevel);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:190:        ALOGE("malloc error");
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:203:        VSFRACLog(LOG_INFO, "[%s:%d]", __func__, __LINE__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:212:        ALOGE("[%s:%d]no videoSyncFrac_priv", __func__, __LINE__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:218:        VSFRACLog(LOG_INFO, "[%s] framerate:%d", __func__, framerate);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:220:        VSFRACLog(LOG_ERR, "[%s]invalid framerate:%d", __func__, framerate);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:229:        ALOGE("[%s:%d]no videoSyncFrac_priv", __func__, __LINE__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:233:        VSFRACLog(LOG_DEBUG_LEVEL1, "patten enable from %d to %d", vsf->enable_pattern, enablePattern);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:254:        ALOGE("[%s:%d]no videoSyncFrac_priv", __func__, __LINE__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:268:                    VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]hwcvsync:%lld, prevsync:%lld syncdiff:%lld, synccntdiff:%lld vsyncinc:%d, vsynccnt:%lld",
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:277:                    VSFRACLog(LOG_ERR, "invalid vsync info, never should enter here, need hwc check  soft vsync");
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:283:                VSFRACLog(LOG_INFO, "[%s]hdmi frequency changed from %d->%d",
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:297:                    VSFRACLog(LOG_DEBUG_LEVEL1, "hwc dispmode: %s", vsf->dispinfo.modestr);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:301:                    VSFRACLog(LOG_DEBUG_LEVEL1, "hwc %s support pattern check", vsf->dispinfo.modestr);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:317:                VSFRACLog(LOG_DEBUG_LEVEL1, "hwc dispmode: %s", vsf->dispinfo.modestr);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:321:                VSFRACLog(LOG_DEBUG_LEVEL1, "hwc %s support pattern check", vsf->dispinfo.modestr);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:324:            VSFRACLog(LOG_DEBUG_LEVEL1, "first hwcvsync:%lld, vsyncinc:%d", (long long)vSyncTimeUs, vsyncInc);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:327:        VSFRACLog(LOG_ERR, "[%s]invalid hwc vsync info, vsynctime:%lld, vsyncinc:%d", __func__, (long long)vSyncTimeUs, vsyncInc);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:337:        ALOGE("[%s]no videoSyncFrac_priv", __func__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:346:    VSFRACLog(LOG_DEBUG_LEVEL2, "[%s] %s", __func__, pattern2Str(pattern));
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:370:                    VSFRACLog(LOG_INFO, "[%s]4:1 pattern detected", __func__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:386:                VSFRACLog(LOG_INFO, "[%s]4:1 pattern broken", __func__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:399:            VSFRACLog(LOG_INFO, "[%s]4:1 pattern broken", __func__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:416:                VSFRACLog(LOG_INFO, "[%s]%d:%d pattern detected", __func__, factor1, factor2);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:423:        VSFRACLog(LOG_INFO, "[%s] pattern %s broken", __func__, pattern2Str(pattern));
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:435:        ALOGE("[%s]no videoSyncFrac_priv", __func__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:466:        VSFRACLog(LOG_DEBUG_LEVEL1, "[%s] NO:%d vsynctime:[%lld-%lld] alignrealtime:%lld, aligndiff=%lld  mediatimeus:%lld vsyncnt:%lld, repeatVsyncCnt:%d",
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:505:            VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]first vsynctime:[%lld-%lld] alignrealtime:%lld, aligndiff=%lld alignoffset=%lld,  mediatimeus:%lld vsyncnt:%lld, repeatVsyncCnt:%d",
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:519:            VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]first hwcvsync have not get,  %lld not calculate pattern", __func__, (long long)mediaTimeUS);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:530:        ALOGE("[%s:%d]no videoSyncFrac_priv", __func__, __LINE__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:582:        ALOGE("[%s:%d]no videoSyncFrac_priv", __func__, __LINE__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:589:        VSFRACLog(LOG_DEBUG_LEVEL2, "[%s]No:%d rate change from %.2f to %.2f", __func__,
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:621:                VSFRACLog(LOG_DEBUG_LEVEL1, "[%s:%d] pattern %s No:%d slight adjust realtime from %lld to %lld for suitable hit hwc vsync", __func__, __LINE__,
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:635:                    VSFRACLog(LOG_DEBUG_LEVEL1, "[%s] pattern %s No:%d will occur one short frame or drop", __func__,
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:646:                    VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]pattern %s hold one frame", __func__, pattern2Str(vsf->pattern_detected));
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:649:                VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]pattern %s No:%d diff is too large[%d->%d], cannot hold frame, broken",
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:659:                VSFRACLog(LOG_DEBUG_LEVEL1, "[%s:%d]pattern %s No:%d slight adjust realtime from %lld to %lld for suitable hit hwc vsync", __func__, __LINE__,
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:673:                    VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]pattern %s No:%d will occur one freeze frame", __func__,
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:683:                    VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]pattern %s pull one frame", __func__,
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:687:                VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]pattern %s No:%d diff is too large[%d->%d], cannot pull frame, broken",
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:697:                VSFRACLog(LOG_DEBUG_LEVEL1, "[%s:%d] pattern %s No:%d slight adjust realtime from %lld to %lld for suitable hit hwc vsync", __func__, __LINE__,
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:713:            VSFRACLog(LOG_DEBUG_LEVEL2, "[%s] check first frame when rate change", __func__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:742:                VSFRACLog(LOG_DEBUG_LEVEL2, "[%s]adjust alignoffset from %lld to %lld to incase %s when rate from %.2f to %.2f", __func__,
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:754:            VSFRACLog(LOG_DEBUG_LEVEL1, "[%s]No:%d hit same vsync with prev frame", __func__, curSyncFrame->frameNo);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:760:                VSFRACLog(LOG_DEBUG_LEVEL1, "[%s:%d] no pattern No:%d also slight adjust realtime from %lld to %lld for suitable hit hwc vsync", __func__, __LINE__,
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:775:        ALOGE("[%s:%d]no videoSyncFrac_priv", __func__, __LINE__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:781:        VSFRACLog(LOG_BUFFER, "[%s]pattern %s No:%d mediatime:%lld, final repeatcnt:%d vsynccnt:%lld, vsynctime[%lld-%lld], diffvsync:%lld, diffnow:%lld", __func__, pattern2Str(vsf->pattern_detected),
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:791:        VSFRACLog(LOG_BUFFER, "[%s] NO:%d mediatime:%lld, final repeatcnt:%d vsynccnt:%lld, vsynctime[%lld-%lld], diffvsync:%lld, diffnow:%lld", __func__,
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:821:        ALOGE("[%s:%d]no videoSyncFrac_priv", __func__, __LINE__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:825:    VSFRACLog(LOG_DEBUG_LEVEL1, "[%s] reset FRAC", __func__);
videoTunnelRenderer/utils/VideoSyncFRAC.cpp:846:        ALOGE("[%s:%d]no videoSyncFrac_priv", __func__, __LINE__);
videoTunnelRenderer/utils/VideoTunnelRendererProperty.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/utils/VideoTunnelRendererProperty.cpp:15:#include <utils/Log.h>
videoTunnelRenderer/utils/VideoTunnelRendererProperty.cpp:29:        ALOGE("input parameter was NULL, videoTunnelRenderer_propertyGetInt failed!");
videoTunnelRenderer/utils/VideoTunnelRendererProperty.cpp:35:        ALOGI("%s set = %d\n", newStr, *def);
videoTunnelRenderer/utils/VideoTunnelRendererProperty.cpp:40:            ALOGI("%s set = %d\n", oldStr, *def);
videoTunnelRenderer/utils/VideoTunnelRendererProperty.cpp:42:            ALOGI("%s is not set used def = %d\n", oldStr, *def);
videoTunnelRenderer/utils/VideoRenderedMetrics.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/utils/VideoSyncFRAC.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/utils/ThreadUtil.cpp:1:// #define LOG_NDEBUG 0
videoTunnelRenderer/utils/ThreadUtil.cpp:2:#define LOG_TAG "ThreadUtil"
videoTunnelRenderer/utils/ThreadUtil.cpp:3:#include <utils/Log.h>
videoTunnelRenderer/utils/ThreadUtil.cpp:46:                ALOGE("pthread on exit wait clean\n");
videoTunnelRenderer/utils/ThreadUtil.cpp:57:        ALOGE("Worker is already running igonore start.");
videoTunnelRenderer/utils/ThreadUtil.cpp:63:        ALOGE("pthread_create failed (err=%d)", ret);
videoTunnelRenderer/utils/ThreadUtil.cpp:76:            ALOGW("pthread_join failed (err=%d)", ret);
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:9:#define LOG_NDEBUG 0
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:10:#define LOG_TAG "VideoRenderedMetrics"
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:12:#include <utils/Log.h>
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:24:#include "log_debug.h"
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:31:#define VRMLog(level, f,s...) VDLog(level, f, ##s)
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:57:            VDLog(LOG_ERR, "not find initialize symbol, may need check!");
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:63:            VDLog(LOG_ERR, "not find registerMsgType symbol, may need check!");
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:69:            VDLog(LOG_ERR, "not find readData symbol, may need check!");
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:75:            VDLog(LOG_ERR, "not find readMultiData symbol, may need check!");
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:81:            VDLog(LOG_ERR, "not find pollInfo symbol, may need check!");
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:87:            VDLog(LOG_ERR, "not find initialize symbol, may need check!");
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:90:        VDLog(LOG_ERR, "dlopen libmediaproxy_consumer.so error: %s", dlerror());
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:131:            VRMLog(LOG_ERR, "media_proxy initialize failed, please check");
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:136:        VRMLog(LOG_ERR, "%s media_proxy initialize or registerMsgType symbol not found, please check", __func__);
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:159:        VRMLog(LOG_ERR, "media_proxy destroy symbol not found, please check");
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:174:        VRMLog(LOG_ERR, "receive error message %#x, please check!", userdata->message_type);
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:181:        VRMLog(LOG_DEBUG_LEVEL1, "[warning] sessid %d maybe have unregistered, ignore", msgInfo->decoder_instid);
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:184:    VDLog(LOG_DEBUG_LEVEL1,"[%d##%d]read msgtype:%s decoderid:%d bitstreamdId:%lld",
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:196:        VRMLog(LOG_ERR, "[%d##%d] not found frame record bitstreamdId:%lld, please check!",
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:215:        VRMLog(LOG_BUFFER, "[%d##%d] notify rendertime:%lld, renderUs:%lld",
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:230:        VDLog(LOG_ERR, "sessid %d not registered, please check!!", sessionid);
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:253:        VDLog(LOG_ERR, "sessid %d not registered, please check!!", sessionid);
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:279:                //VDLog(LOG_DEBUG_LEVEL1, "read packets:%d(%d/%d)", readpackets, readSize, sizeof(struct aml_video_user_data));
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:292:    videoTunnelRenderer_propertyGetInt(PROPERTY_VIDEOTUNNELRENDERER_LOGlEVELS, PROPERTY_VIDEOTUNNELRENDERER_LOGlEVELS_OLD, (int*)&gloglevel);
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:296:        VRMLog(LOG_DEBUG_LEVEL1, "[warning] sessid %d have registered!!", sessionid);
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:299:    VRMLog(LOG_INFO, "[%d##%d] %s", info->instID, info->decoderID, __func__);
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:321:        VRMLog(LOG_DEBUG_LEVEL1, "[warning] sessid %d have unregistered or not registered, not need unregister", sessionid);
videoTunnelRenderer/utils/VideoRenderedMetrics.cpp:324:    VRMLog(LOG_INFO, "[%d##%d] %s", rendereddata->second.playerinfo.instID, rendereddata->second.playerinfo.decoderID, __func__);
videoTunnelRenderer/Android.bp:62:        "liblog",
videoTunnelRenderer/wrapper/VideoTunnelWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/wrapper/VideoTunnelWrapper.h:21:#include <utils/Log.h>
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:10:#define LOG_NDEBUG 0
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:11:#define LOG_TAG "VideoTunnelWrapper"
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:34:#include "log_debug.h"
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:38:#define MTWLog(level, f,s...) VDLog(level, "[%d##%d]"#f, mPlayerInfo.instID, mPlayerInfo.decoderID, ##s)
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:79:        ALOGE("fstat error:%d:%s", fd, strerror(errno));
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:89:    ALOGI("ctor videotunnel_ops\n");
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:95:    ALOGI("videotunnel_ops leave\n");
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:103:        ALOGI("videoTunnelLibInit has inited\n");
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:110:            ALOGE("unable to dlopen libvideotunnel.so: %s", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:119:        ALOGE("dlsym meson_vt_open failed, err=%s \n", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:127:        ALOGE("dlsym meson_vt_close failed, err=%s \n", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:135:        ALOGE("dlsym meson_vt_alloc_id failed, err=%s \n", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:143:        ALOGE("dlsym meson_vt_free_id failed, err=%s \n", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:151:        ALOGE("dlsym meson_vt_connect failed, err=%s \n", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:159:        ALOGE("dlsym meson_vt_disconnect failed, err=%s \n", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:167:        ALOGE("dlsym meson_vt_send_cmd failed, err=%s \n", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:176:        ALOGE("dlsym meson_vt_queue_buffer failed, err=%s \n", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:184:        ALOGE("dlsym meson_vt_dequeue_buffer failed, err=%s \n", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:194:        ALOGE("meson_vt_getDisplayVsyncAndPeriod failed, err=%s \n", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:202:        ALOGE("dlsym meson_vt_cancel_buffer failed, err=%s \n", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:210:        ALOGE("dlsym meson_vt_set_solid_color failed, err=%s \n", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:217:        ALOGE("dlsym meson_vt_set_sourceCrop failed, err=%s \n", dlerror());
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:220:    ALOGI("videoTunnelLibInit ok\n");
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:234:    ALOGI("videoTunnelLibRelease\n");
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:246:    videoTunnelRenderer_propertyGetInt(PROPERTY_VIDEOTUNNELRENDERER_LOGlEVELS, PROPERTY_VIDEOTUNNELRENDERER_LOGlEVELS_OLD, (int*)&gloglevel);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:254:                MTWLog(LOG_ERR, "meson_vt_open failed! %s", strerror(errno));
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:263:        MTWLog(LOG_ERR, "Poll interruptfd error");
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:266:    MTWLog(LOG_INFO, "ctor VideoTunnelWrapper mVideoTunnelFd %d", mVideoTunnelFd);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:277:    MTWLog(LOG_INFO, "~VideoTunnelWrapper, mConnected = %d", mConnected);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:288:        MTWLog(LOG_INFO, "ctor VideoTunnelWrapper meson_vt_close mVideoTunnelFd %d",  mVideoTunnelFd);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:292:            MTWLog(LOG_ERR, "meson_vt_close nullptr!");
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:293:        MTWLog(LOG_INFO, "meson_vt_close done! ret:%d", ret);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:309:        MTWLog(LOG_INFO, "single vt id %d", mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:315:            MTWLog(LOG_ERR, "meson_vt_alloc_id failed! %s", strerror(errno));
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:318:            MTWLog(LOG_INFO, "meson_vt_alloc_id success. mTunnelId:%d", mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:321:        MTWLog(LOG_ERR, "meson_vt_alloc_id failed, mVideoTunnelFd:%d, mTunnelId:%d", mVideoTunnelFd, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:333:        MTWLog(LOG_INFO, "single vt id %d, no need free", mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:339:            MTWLog(LOG_ERR, "meson_vt_free_id %d failed! %s", mTunnelId, strerror(errno));
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:342:            MTWLog(LOG_INFO, "meson_vt_free_id success. mTunnelId:%d",  mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:346:        MTWLog(LOG_ERR, "meson_vt_free_id failed, mVideoTunnelFd:%d, mTunnelId:%d", mVideoTunnelFd, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:361:            MTWLog(LOG_ERR, "meson_vt_connect %d failed with %d", mTunnelId, ret);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:365:            MTWLog(LOG_INFO, "meson_vt_connect %d success!",  mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:368:        MTWLog(LOG_ERR, "meson_vt_connect failed, mVideoTunnelFd:%d, mTunnelId:%d", mVideoTunnelFd, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:381:    MTWLog(LOG_INFO, "with mVideoTunnelFd:%d mTunnelId:%d, color:%d", mVideoTunnelFd, mTunnelId, color);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:385:            MTWLog(LOG_ERR, "setScreenColor failed with %d mVideoTunnelFd:%d mTunnelId:%d", ret, mVideoTunnelFd, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:388:            MTWLog(LOG_INFO, "setScreenColor success! mVideoTunnelFd:%d mTunnelId:%d", mVideoTunnelFd, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:399:    MTWLog(LOG_INFO, "(%s)with mVideoTunnelFd:%d mTunnelId:%d",  Status == true ? "VIDEOSHOW" : "VIDEOHIDE",mVideoTunnelFd, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:407:            MTWLog(LOG_ERR, "VideoShow failed with %d mVideoTunnelFd:%d mTunnelId:%d", ret,mVideoTunnelFd, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:410:            MTWLog(LOG_INFO, "VideoShow success! mVideoTunnelFd:%d mTunnelId:%d", mVideoTunnelFd, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:423:    MTWLog(LOG_INFO, "current queuedCount:%d", queuedCount);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:435:        MTWLog(LOG_INFO, "current queuedCount:%d", queuedCount);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:440:        MTWLog(LOG_INFO,"in,clearlastframe:%d, mLastFrameColor:%d",clearlastframe, mLastFrameColor);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:447:                MTWLog(LOG_INFO, "meson_vt_send_cmd with ret:%d mVideoTunnelFd:%d mTunnelId:%d", ret,mVideoTunnelFd, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:453:            MTWLog(LOG_ERR, "meson_vt_disconnect %d failed with %d", mTunnelId, ret);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:456:            MTWLog(LOG_INFO, "meson_vt_disconnect %d success!", mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:472:        MTWLog(LOG_DEBUG_LEVEL2, "%s:%d, mQueuedCount:%d", __FUNCTION__, __LINE__, queuedCount);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:489:            MTWLog(LOG_DEBUG_LEVEL2, "meson_vt_dequeue_buffer failed with %d, mTunnelId: %d, need deq again", ret, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:492:            MTWLog(LOG_DEBUG_LEVEL1, "dequeueBuffer %d(ino:%lld) %d",*qfd, (long long)getINodeFromFd(*qfd), fence_fd);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:498:                            MTWLog(LOG_DEBUG_LEVEL1, "File was deleted!");
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:502:                        MTWLog(LOG_DEBUG_LEVEL1, "fstat error : %s (%d)!\n", strerror(-errno), errno);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:506:                    MTWLog(LOG_DEBUG_LEVEL1, "fcntl error : %s (%d)!\n", strerror(-errno), errno);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:514:                    MTWLog(LOG_INFO, "Failed to wait for fence: fd: %d fence_fd %d err : %s (%d)", *qfd, fence_fd, strerror(-ret_status), ret_status);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:523:                MTWLog(LOG_DEBUG_LEVEL1, "dequeueBuffer count:%d", queuedCount);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:528:        MTWLog(LOG_ERR, "%s video tunnel dequeueBuffer failed, mVideoTunnelFd:%d, mTunnelId:%d", __FUNCTION__, mVideoTunnelFd, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:581:        MTWLog(LOG_ERR, "[%s:%d] write error", __FUNCTION__, __LINE__);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:584:    MTWLog(LOG_DEBUG_LEVEL1, "[%s:%d]", __FUNCTION__, __LINE__);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:594:            MTWLog(LOG_ERR, "[%s:%d] read error", __FUNCTION__, __LINE__);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:598:    MTWLog(LOG_DEBUG_LEVEL1, "[%s:%d]", __FUNCTION__, __LINE__);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:612:            MTWLog(LOG_ERR, "meson_vt_queue_buffer failed with %d, mTunnelId:%d", ret, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:614:            MTWLog(LOG_DEBUG_LEVEL1, "queueBuffer %d %lld",  qfd, (long long)timestampNs);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:618:                MTWLog(LOG_DEBUG_LEVEL1, "queueBuffer %d %lld, count:%d", qfd, (long long)timestampNs, queuedCount);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:623:        MTWLog(LOG_ERR, "%s video tunnel queueBuffer failed, mVideoTunnelFd:%d, mTunnelId:%d", __FUNCTION__, mVideoTunnelFd, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:637:            MTWLog(LOG_ERR, "meson_vt_getDisplayVsyncAndPeriod failed with %d, mTunnelId:%d", ret, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:640:            MTWLog(LOG_DEBUG_LEVEL2, "getDisplayVsyncAndPeriod vsyncTimestamp:%lld, vsyncPeriod:%d",
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:651:    MTWLog(LOG_INFO,"%s in, mVideoTunnelFd: %d, mTunnelId: %d",
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:657:            MTWLog(LOG_INFO, "clearLastFrame %d failed, ret: %d", mTunnelId, ret);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:660:            MTWLog(LOG_INFO, "clearLastFrame %d success", mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:668:    MTWLog(LOG_INFO,"%s in, mVideoTunnelFd: %d, mTunnelId: %d",
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:673:            MTWLog(LOG_INFO, "%s %d failed, ret: %d", __FUNCTION__, mTunnelId, ret);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:676:            MTWLog(LOG_INFO, "%s %d success", __FUNCTION__, mTunnelId);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:693:            MTWLog(LOG_INFO, "%s %d failed, ret: %d", __FUNCTION__, mTunnelId, ret);
videoTunnelRenderer/wrapper/VideoTunnelWrapper.cpp:696:            MTWLog(LOG_INFO, "%s %d success", __FUNCTION__, mTunnelId);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:9:#define LOG_NDEBUG 0
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:10:#define LOG_TAG "VideoSyncWrapper"
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:12:#include <utils/Log.h>
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:26:#include "log_debug.h"
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:28:#define VSWLog(level, f,s...) VDLog(level, "[%d##%d]"#f, mPlayerInfo.instID, mPlayerInfo.decoderID, ##s)
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:35:    videoTunnelRenderer_propertyGetInt(PROPERTY_VIDEOTUNNELRENDERER_LOGlEVELS, PROPERTY_VIDEOTUNNELRENDERER_LOGlEVELS_OLD, (int*)&gloglevel);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:54:    VSWLog(LOG_INFO, "[%s]SessionId:%d(%s)", __func__, sessionId, (mPlayerInfo.passthroughMode ? "playerInsNumber" : "decoderId"));
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:56:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:64:    VSWLog(LOG_INFO, "[%s] SyncInsId:%d, streamtype:%d", __func__, SyncInsId, streamtype);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:66:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:74:    VSWLog(LOG_INFO, "[%s] SyncInsId:%d, streamtype:%d\n", __func__, SyncInsId, streamtype);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:76:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:83:    VSWLog(LOG_INFO, "[%s]mode:%d", __func__, mode);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:86:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:95:    VSWLog(LOG_DEBUG_LEVEL2, "[%s]mode:%d", __func__, *mode);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:97:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:105:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:113:        ALOGE("[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:128:    VSWLog(LOG_DEBUG_LEVEL1, "[%s]anchorTimeMediaUs:%lld, anchorTimeRealUs:%lld, maxTimeMediaUs:%lld",
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:132:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:141:        ALOGE("[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:151:        ALOGE("[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:161:    //VSWLog(LOG_DEBUG_LEVEL2, "[%s]realUs:%lld, outMediaUs:%lld, allowPastMaxTime:%lld", __func__, (long long)realUs, (long long)(*outMediaUs), (long long)allowPastMaxTime);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:163:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:172:    //VSWLog(LOG_DEBUG_LEVEL2, "[%s]targetMediaUs:%lld, outRealUs:%lld", __func__, (long long)targetMediaUs, (long long)(*outRealUs));
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:174:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:188:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:203:    VSWLog(LOG_DEBUG_LEVEL2, "[%s:%d]trackMediatime:%lld, anchorTime(%lld:%lld), syncMode:%d, rate:%.2f", __func__, __LINE__,
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:233:    VSWLog(LOG_DEBUG_LEVEL2, "[%s]outRealUs:%lld\n", __func__, (long long)(*outRealUs));
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:235:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:247:    //VSWLog(LOG_DEBUG_LEVEL2, "[%s]Anchortime:%lld", __func__, (long long)(*outMediaUs));
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:249:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:256:    VSWLog(LOG_INFO, "[%s]", __func__);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:259:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:266:    VSWLog(LOG_INFO, "[%s]", __func__);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:267:    mediasync_result ret = mMediaSync->allocInstance(LOG_ERR, 0, syncId);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:269:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:278:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:287:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:296:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:305:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:312:    VSWLog(LOG_INFO, "[%s]", __func__);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:315:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:322:    VSWLog(LOG_INFO, "[%s]", __func__);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:325:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:334:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:343:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:351:    VSWLog(LOG_DEBUG_LEVEL1, "%s status %d", __func__, status);
videoTunnelRenderer/wrapper/VideoSyncWrapper.cpp:353:        VSWLog(LOG_ERR, "[%s]err:%d", __func__, ret);
videoTunnelRenderer/wrapper/MediaProxyWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:2:* Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:9:#define LOG_NDEBUG 0
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:10:#define LOG_TAG "MediaProxyWrapper"
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:13:#include <utils/Log.h>
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:22:#include "log_debug.h"
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:25:#define MPLog(level, f,s...) VDLog(level, f, ##s)
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:28:#define PROPERTY_MEDIAMETRICS_LOGLEVELS "vendor.mediahal.metrics.loglevels"
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:50:            MPLog(LOG_ERR, "not find initialize symbol, may need check!");
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:55:            MPLog(LOG_ERR, "not find registerMsgType symbol, may need check!");
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:60:            MPLog(LOG_ERR, "not find readData symbol, may need check!");
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:65:            MPLog(LOG_ERR, "not find initialize symbol, may need check!");
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:68:        MPLog(LOG_ERR, "dlopen libmediaproxy_consumer.so error: %s", dlerror());
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:97:            MPLog(LOG_ERR, "not find initialize symbol, may need check!");
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:102:            MPLog(LOG_ERR, "not find writeData symbol, may need check!");
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:107:            MPLog(LOG_ERR, "not find initialize symbol, may need check!");
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:110:        MPLog(LOG_ERR, "dlopen libmediaproxy_producer.so error: %s", dlerror());
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:128:    gloglevel = property_get_int32(PROPERTY_MEDIAMETRICS_LOGLEVELS, 1);
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:134:            MPLog(LOG_ERR, "producer symbol not load normal, need check");
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:142:            MPLog(LOG_ERR, "consumer symbol not load normal, need check");
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:147:        MPLog(LOG_ERR, "error role type %d", type);
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:152:        MPLog(LOG_ERR, "role %d initialize failed", type);
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:175:            MPLog(LOG_DEBUG_LEVEL2, "readData timeout");
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:179:        MPLog(LOG_ERR, "readData symbol error,fd:%d,readData:%p", mProxy_fd, gMediaConsumer.readData);
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:188:            MPLog(LOG_ERR, "writeData error");
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:191:        MPLog(LOG_ERR, "writeData symbol error,fd:%d,readData:%p", mProxy_fd, gMediaProducer.writeData);
videoTunnelRenderer/wrapper/MediaProxyWrapper.cpp:201:        MPLog(LOG_ERR, "registermsgtype error");
videoTunnelRenderer/wrapper/VideoSyncWrapper.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/include/AmlMessageBase.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/include/VideoTunnelRenderer.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/include/log_debug.h:1:#ifndef _LOG_DEBUG_H
videoTunnelRenderer/include/log_debug.h:2:#define _LOG_DEBUG_H
videoTunnelRenderer/include/log_debug.h:6:#include <utils/Log.h>
videoTunnelRenderer/include/log_debug.h:11:// #define PROPERTY_LOGLEVELS              "vendor.mediahal.loglevels"
videoTunnelRenderer/include/log_debug.h:14:#define LOG_ERR 0
videoTunnelRenderer/include/log_debug.h:15:#define LOG_INFO 1
videoTunnelRenderer/include/log_debug.h:16:#define LOG_BUFFER 2
videoTunnelRenderer/include/log_debug.h:17:#define LOG_DEBUG_LEVEL1 4
videoTunnelRenderer/include/log_debug.h:18:#define LOG_DEBUG_LEVEL2 8
videoTunnelRenderer/include/log_debug.h:19:#define LOG_TRACE 16
videoTunnelRenderer/include/log_debug.h:21:static unsigned int gloglevel = 1;
videoTunnelRenderer/include/log_debug.h:22:#define VDLog(level, f, s...) \
videoTunnelRenderer/include/log_debug.h:24:    if (level & gloglevel) {\
videoTunnelRenderer/include/log_debug.h:25:        if (level == LOG_INFO)\
videoTunnelRenderer/include/log_debug.h:26:            ALOGI(f, ##s);\
videoTunnelRenderer/include/log_debug.h:27:        else if (level == LOG_BUFFER || level == LOG_DEBUG_LEVEL1 || level == LOG_DEBUG_LEVEL2) \
videoTunnelRenderer/include/log_debug.h:28:            ALOGD(f, ##s);\
videoTunnelRenderer/include/log_debug.h:31:            ALOGD(f, ##s);\
videoTunnelRenderer/include/log_debug.h:38:    if (gloglevel & LOG_TRACE) {\
videoTunnelRenderer/include/log_debug.h:45:    if (gloglevel & LOG_TRACE) {\
videoTunnelRenderer/include/VideoTunnelRendererBase.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/VideoTunnelRenderer.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
videoTunnelRenderer/VideoTunnelRenderer.cpp:9:#define LOG_NDEBUG 0
videoTunnelRenderer/VideoTunnelRenderer.cpp:10:#define LOG_TAG "Mediahal_VideoTunnelRenderer"
videoTunnelRenderer/VideoTunnelRenderer.cpp:18:#include <utils/Log.h>
videoTunnelRenderer/VideoTunnelRenderer.cpp:26:#include "log_debug.h"
videoTunnelRenderer/VideoTunnelRenderer.cpp:37:#define MVRLog(level, f,s...) VDLog(level, "[%d##%d]"#f, mPlayerInfo.instID, mPlayerInfo.decoderID, ##s)
videoTunnelRenderer/VideoTunnelRenderer.cpp:117:    videoTunnelRenderer_propertyGetInt(PROPERTY_VIDEOTUNNELRENDERER_LOGlEVELS, PROPERTY_VIDEOTUNNELRENDERER_LOGlEVELS_OLD, (int*)&gloglevel);
videoTunnelRenderer/VideoTunnelRenderer.cpp:129:    MVRLog(LOG_INFO, "[%s] mFreeRun:%d mVideoSyncMode:%d\n", __func__, mFreeRun, mVideoSyncMode);
videoTunnelRenderer/VideoTunnelRenderer.cpp:179:        MVRLog(LOG_ERR,"[%s:%d] open file failed, error=%s", __func__, __LINE__, strerror(errno));
videoTunnelRenderer/VideoTunnelRenderer.cpp:184:    MVRLog(LOG_INFO, "[%s]\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:224:        MVRLog(LOG_INFO, "[%s]non-video case: hwsyncid:0x%x tunerpassthrough:%d\n",
videoTunnelRenderer/VideoTunnelRenderer.cpp:248:        MVRLog(LOG_INFO, "[%s]mHwSyncId:0x%x tunerpassthrough:%d\n", __func__, mHwSyncId, isTunerPassthrough());
videoTunnelRenderer/VideoTunnelRenderer.cpp:252:            MVRLog(LOG_ERR, "[%s]new VideoSyncWrapper err\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:271:                MVRLog(LOG_INFO, "[%s] alloc mediasync instance should error in audio, static bind in video", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:296:        MVRLog(LOG_ERR, "[%s]new VideoSyncFRAC err\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:304:    MVRLog(LOG_INFO, "[%s]\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:307:        MVRLog(LOG_INFO, "[%s]have started\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:331:    MVRLog(LOG_INFO, "[%s] done\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:373:    MVRLog(LOG_INFO, "[%s:%d]\n", __func__, __LINE__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:420:    MVRLog(LOG_INFO, "[%s] done\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:425:    MVRLog(LOG_INFO, "[%s:%d]\n", __func__, __LINE__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:460:    MVRLog(LOG_INFO, "[%s:%d]\n", __func__, __LINE__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:465:    MVRLog(LOG_INFO, "[%s]\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:469:        MVRLog(LOG_INFO, "[%s]mVideoFrameInputQueue.size():%d\n", __func__, (int)mVideoFrameInputQueue.size());
videoTunnelRenderer/VideoTunnelRenderer.cpp:480:                MVRLog(LOG_BUFFER, "[%s] flush early notify rendertime:%lld, renderUs:%lld", __func__, (long long)rendertime.mediaUs, (long long)rendertime.renderUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:493:            MVRLog(LOG_DEBUG_LEVEL1, "[%s]queue:%d\n", __func__, (int)mVideoFrameInputQueue.size());
videoTunnelRenderer/VideoTunnelRenderer.cpp:518:    MVRLog(LOG_INFO, "[%s] done\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:586:        VDLog(LOG_DEBUG_LEVEL2, "[%d##%d] %s fence wait time:%d us", renderer->mPlayerInfo.instID, renderer->mPlayerInfo.decoderID ,__func__,waitUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:637:    MVRLog(LOG_DEBUG_LEVEL1, "[%s]wait audio start\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:651:    MVRLog(LOG_INFO, "[%s]audio have started\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:660:        MVRLog(LOG_ERR, "[%s] video mediasync has exited\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:664:        MVRLog(LOG_ERR, "[%s] Parameters error!\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:671:            MVRLog(LOG_DEBUG_LEVEL2, "[%s/%d]mediaTimeUs:%lld videopolicy:%d\n", __func__, __LINE__, (long long)mediaTimeUs, mVideoPolicy.videopolicy);
videoTunnelRenderer/VideoTunnelRenderer.cpp:686:                    MVRLog(LOG_INFO, "MEDIASYNC_VIDEO_HOLD mVideoHoldCount:%d mediaTimeUs:%lld\n", mVideoHoldCount, (long long)mediaTimeUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:691:            MVRLog(LOG_INFO, "MEDIASYNC_VIDEO_DROP mediaTimeUs:%lld\n", (long long)mediaTimeUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:694:            MVRLog(LOG_INFO, "MEDIASYNC_VIDEO_EXIT mediaTimeUs:%lld\n", (long long)mediaTimeUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:702:                MVRLog(LOG_DEBUG_LEVEL2, "[%s/%d]mediaTimeUs:%lld videopolicy:%d\n", __func__, __LINE__, (long long)mediaTimeUs, mVideoPolicy.videopolicy);
videoTunnelRenderer/VideoTunnelRenderer.cpp:705:            MVRLog(LOG_INFO,"--->FirstPostDrainVideoQueue\n");
videoTunnelRenderer/VideoTunnelRenderer.cpp:710:            MVRLog(LOG_DEBUG_LEVEL2, "seek next and hold this frame\n");
videoTunnelRenderer/VideoTunnelRenderer.cpp:717:    MVRLog(LOG_DEBUG_LEVEL2, "(%s) mediaTimeUs:%lld(%lld) NowUsDiff:%lld us finalRealtimeUs:%lld\n",
videoTunnelRenderer/VideoTunnelRenderer.cpp:757:            MVRLog(LOG_DEBUG_LEVEL1, "frame with mediatime %lld need retry to calculated realtime", (long long)rframe.timestampUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:786:        MVRLog(LOG_ERR, "get display vsync error, please check");
videoTunnelRenderer/VideoTunnelRenderer.cpp:822:        MVRLog(LOG_DEBUG_LEVEL1, "[%s]resume playback need realign vsync, audio startpts change from %lld to %lld\n", __func__, (long long)mAudioStartPTS, (long long)audiostartpts);
videoTunnelRenderer/VideoTunnelRenderer.cpp:833:        MVRLog(LOG_INFO, "need realign vsync, anchor time changed from (%lld, %lld) to (%lld, %lld)",
videoTunnelRenderer/VideoTunnelRenderer.cpp:870:        MVRLog(LOG_INFO, "[%s]wait audio start\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:885:                MVRLog(LOG_INFO, "[%s] change status to pause.\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:905:        MVRLog(LOG_INFO, "[%s]wait video start\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:924:        MVRLog(LOG_DEBUG_LEVEL2, "[%s]drop frame for sync audio:%lld\n", __func__, (long long)rframe.timestampUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:937:            MVRLog(LOG_DEBUG_LEVEL2, "[%s]audio may mediatime have not updated, need wait\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:943:                MVRLog(LOG_DEBUG_LEVEL2, "[%s] flush after need update firstvpts\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:956:                    MVRLog(LOG_DEBUG_LEVEL2, "[%s]audio update first pts after underflow\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:962:                        MVRLog(LOG_DEBUG_LEVEL2, "[%s] audio not update first pts, no need fast catch up wih audio after underflow, diff=%lld",
videoTunnelRenderer/VideoTunnelRenderer.cpp:971:                        MVRLog(LOG_DEBUG_LEVEL2, "[%s] video have catch up wih audio after underflow\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1022:                MVRLog(LOG_INFO, "notify underflow event");
videoTunnelRenderer/VideoTunnelRenderer.cpp:1038:                        MVRLog(LOG_DEBUG_LEVEL1, "notify underflow event");
videoTunnelRenderer/VideoTunnelRenderer.cpp:1071:        VDLog(LOG_BUFFER, "[%d##%d] VideoFrameInputQueue.size():%d, mediatimeUs:%lld", renderer->mPlayerInfo.instID, renderer->mPlayerInfo.decoderID,
videoTunnelRenderer/VideoTunnelRenderer.cpp:1103:    MVRLog(LOG_DEBUG_LEVEL2, "[%s] %lld\n", __func__, (long long)timeUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1114:    MVRLog(LOG_BUFFER, "[%s] pts:%lld, realTime:%lld\n", __func__, (long long)rframe.timestampUs, (long long)realTime);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1117:        MVRLog(LOG_DEBUG_LEVEL1, "[%s]do not show, need return frame\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1138:    MVRLog(LOG_BUFFER, "[%s] drop pts:%lld\n", __func__, (long long)rframe.timestampUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1157:    MVRLog(LOG_BUFFER, "[%s] pts:%lld\n", __func__, (long long)rframe.timestampUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1160:        MVRLog(LOG_DEBUG_LEVEL1, "[%s]do not show, need return frame\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1189:    MVRLog(LOG_BUFFER, "[%s] drop pts:%lld\n", __func__, (long long)rframe.timestampUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1225:            MVRLog(LOG_ERR, "video show:%d\n", videoshow);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1241:                MVRLog(LOG_ERR, "AM_VT_PARAM_SCREEN_COLOR mode :%d not support\n", screenMode);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1244:            MVRLog(LOG_ERR, "screen color:%d\n", screenColor);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1259:            MVRLog(LOG_ERR, "AM_VT_PARAM_TRANSITION_MODE_BEFORE:blackout:%d\n", blackout);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1274:            MVRLog(LOG_ERR, "AM_VT_PARAM_TRANSITION_MODE_AFTER: mode:%d\n", mode);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1286:            MVRLog(LOG_ERR, "AM_VT_PARAM_TRANSITION_PREROLL_RATE:%f\n", rate);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1298:            MVRLog(LOG_ERR, "AM_VT_PARAM_TRANSITION_PREROLL_AV_TOLERANCE:%d\n", tolerance);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1309:            MVRLog(LOG_ERR, "AM_VT_PARAM_PAUSE\n");
videoTunnelRenderer/VideoTunnelRenderer.cpp:1320:            MVRLog(LOG_ERR, "AM_VT_PARAM_SYNC_MODE\n");
videoTunnelRenderer/VideoTunnelRenderer.cpp:1331:            MVRLog(LOG_ERR, "AM_VT_PARAM_RESET_VIDEO_PATH\n");
videoTunnelRenderer/VideoTunnelRenderer.cpp:1340:            MVRLog(LOG_ERR, "AM_VT_PARAM_DROP_PTS\n");
videoTunnelRenderer/VideoTunnelRenderer.cpp:1349:            MVRLog(LOG_ERR, "setting not support in this version\n");
videoTunnelRenderer/VideoTunnelRenderer.cpp:1371:        MVRLog(LOG_INFO, "[%s] decoderID:%d\n", __func__, mPlayerInfo.decoderID);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1380:        MVRLog(LOG_INFO, "[%s] callerinstandid:%d", __func__, mPlayerInfo.instID);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1391:        MVRLog(LOG_INFO,"mFreeRun: %d, mHaveAudio:%d\n", mFreeRun, mHaveAudio);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1399:            MVRLog(LOG_INFO,"Always show the solid black color frame");
videoTunnelRenderer/VideoTunnelRenderer.cpp:1402:            MVRLog(LOG_INFO,"Disable show the solid black color frame");
videoTunnelRenderer/VideoTunnelRenderer.cpp:1410:        MVRLog(LOG_INFO,"mLowLatency: %d, mHaveAudio:%d\n", mLowLatency, mHaveAudio);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1417:        MVRLog(LOG_INFO,"mPushBlankBuffersOnShutdown: %d\n", mPushBlankBuffersOnShutdown);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1462:        MVRLog(LOG_INFO, "[%s] priority:%d\n", __func__, priority);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1520:        MVRLog(LOG_ERR, "[%s] mTunnel is null!\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1526:    MVRLog(LOG_INFO, "[%s] mTunnelId:%d\n", __func__, mTunnelId);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1535:        MVRLog(LOG_ERR, "[%s] mTunnel is null!\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1549:        MVRLog(LOG_ERR, "[%s] mTunnel is null!\n", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1561:    MVRLog(LOG_BUFFER, "[%s] ==in== [%d] fd:%d, timestampUs:%lld\n", __func__, mInFrameCount, fd, (long long)timestampUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1574:    MVRLog(LOG_BUFFER, "VideoFrameInputQueue.size():%d\n",(int)mVideoFrameInputQueue.size());
videoTunnelRenderer/VideoTunnelRenderer.cpp:1582:    MVRLog(LOG_BUFFER, "[%s] ==in== [%d] fd:%d, timestampUs:%lld, bitstreamId:%lld", __func__, mInFrameCount, rframe->fd, (long long)rframe->timestampUs, (long long)rframe->bitstreamId);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1591:    MVRLog(LOG_BUFFER, "VideoFrameInputQueue.size():%d\n",(int)mVideoFrameInputQueue.size());
videoTunnelRenderer/VideoTunnelRenderer.cpp:1602:            MVRLog(LOG_DEBUG_LEVEL2, "[%s:%d] wait for input frame timeout\n", __func__,  __LINE__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1642:            MVRLog(LOG_DEBUG_LEVEL2, "[%s]poll wait error", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1645:            MVRLog(LOG_DEBUG_LEVEL2, "[%s]poll wait timeout(%d ms)", __func__, poll_timems);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1648:            MVRLog(LOG_INFO, "[%s]poll exit", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1652:            MVRLog(LOG_DEBUG_LEVEL2, "[%s]no consumer connect", __func__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1677:        MVRLog(LOG_BUFFER, "[%s]==out== [%d], fd:%d, inRenderer[%d]\n", __func__, mOutFrameCount, fd, (mInFrameCount - mOutFrameCount));
videoTunnelRenderer/VideoTunnelRenderer.cpp:1692:                MVRLog(LOG_BUFFER, "[%s] notify rendertime:%lld, renderUs:%lld", __func__, (long long)rendertime.mediaUs, (long long)rendertime.renderUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1710:                MVRLog(LOG_DEBUG_LEVEL1, "notify underflow event:%d", mVideoUnderflow);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1745:            MVRLog(LOG_DEBUG_LEVEL1, "notifyevent register");
videoTunnelRenderer/VideoTunnelRenderer.cpp:1774:    MVRLog(LOG_INFO,"mVideoTrickMode:%d\n",mVideoTrickMode);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1782:    MVRLog(LOG_DEBUG_LEVEL2, "[%s:%d]\n", __func__,  __LINE__);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1784:        MVRLog(LOG_DEBUG_LEVEL2, "scale:%f\n",scale);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1799:            MVRLog(LOG_BUFFER, "[%s]%sframeNo:%d, mediatimeus:%lld, nowUs:%lld, realTimeUs:%lld, finalrealtime:%lld, diff=%lld\n",
videoTunnelRenderer/VideoTunnelRenderer.cpp:1816:                MVRLog(LOG_DEBUG_LEVEL1, "[%s]may occur drop pts:%lld\n", __func__, (long long)rframe.timestampUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1819:                    MVRLog(LOG_DEBUG_LEVEL1, "[%s]may need catch drop pts:%lld\n", __func__, (long long)rframe.timestampUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1829:            MVRLog(LOG_BUFFER, "[%s]%sdrop = frameNo:%d, mediatimeus:%lld, nowUs:%lld, realTimeUs:%lld, finalrealtime:%lld, diff=%lld\n",
videoTunnelRenderer/VideoTunnelRenderer.cpp:1842:                MVRLog(LOG_DEBUG_LEVEL1, "[%s]need catch drop pts:%lld\n", __func__, (long long)rframe.timestampUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1850:            MVRLog(LOG_DEBUG_LEVEL1, "underflow recovery!");
videoTunnelRenderer/VideoTunnelRenderer.cpp:1854:        MVRLog(LOG_DEBUG_LEVEL1, "[%s] wait for frame(mediatimeus:%lld nowUs:%lld, finalrealtime:%lld) %lld us", __func__,
videoTunnelRenderer/VideoTunnelRenderer.cpp:1867:        MVRLog(LOG_DEBUG_LEVEL1, "vmaster update mediatime %lld", (long long)rframe.timestampUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1876:            MVRLog(LOG_BUFFER, "[%s]frameNo:%d, mediatimeus:%lld, nowUs:%lld, realTimeUs:%lld, finalrealtime:%lld, diff=%lld\n",
videoTunnelRenderer/VideoTunnelRenderer.cpp:1894:           MVRLog(LOG_BUFFER, "[%s]drop = frameNo:%d, mediatimeus:%lld, nowUs:%lld, realTimeUs:%lld, finalrealtime:%lld, diff=%lld\n", __func__,
videoTunnelRenderer/VideoTunnelRenderer.cpp:1905:                MVRLog(LOG_DEBUG_LEVEL1, "[%s]need catch drop pts:%lld\n", __func__, (long long)rframe.timestampUs);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1911:        MVRLog(LOG_DEBUG_LEVEL1, "[%s] wait for frame(mediatimeus:%lld nowUs:%lld, finalrealtime:%lld) %lld us", __func__,
videoTunnelRenderer/VideoTunnelRenderer.cpp:1918:    MVRLog(LOG_BUFFER, "[%s]frameNo:%d, mediatimeus:%lld, finalrealtime:%lld\n",
videoTunnelRenderer/VideoTunnelRenderer.cpp:1928:    MVRLog(LOG_INFO, "[KPI-FCC]mVideoWorkMode:%d, workMode:%d\n", lastWorkMode, workmode);
videoTunnelRenderer/VideoTunnelRenderer.cpp:1933:            MVRLog(LOG_INFO, "normal to cache clearLastFrame true");
videoTunnelRenderer/VideoTunnelRenderer.cpp:1937:            MVRLog(LOG_INFO, "cache to normal keep frame");
videoTunnelRenderer/VideoTunnelRenderer.cpp:1949:       MVRLog(LOG_DEBUG_LEVEL1, "same av sync status %s, ignore it", playStatus2Str(currentPlayStatus));
videoTunnelRenderer/VideoTunnelRenderer.cpp:1982:                MVRLog(LOG_ERR, "invalid status map %s to mediasync, may need a new map", playStatus2Str(new_status));
videoTunnelRenderer/VideoTunnelRenderer.cpp:2003:            MVRLog(LOG_INFO, "play status change %s(%lld us) to %s",
videopassthrough/TunerPassthrough.cpp:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthrough.cpp:10:#define LOG_NDEBUG 0
videopassthrough/TunerPassthrough.cpp:11:#define LOG_TAG "TunerPassthrough"
videopassthrough/TunerPassthrough.cpp:13:#include <utils/Log.h>
videopassthrough/TunerPassthrough.cpp:19:    ALOGI("[%s/%d] V4L2:%d\n", __FUNCTION__, __LINE__, mUseV4L2);
videopassthrough/TunerPassthrough.cpp:30:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthrough.cpp:40:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthrough.cpp:52:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthrough.cpp:64:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthrough.cpp:76:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthrough.cpp:89:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthrough.cpp:103:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthrough.cpp:116:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthrough.cpp:129:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthrough.cpp:142:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthrough.cpp:155:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthrough.cpp:168:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthrough.cpp:181:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthrough.cpp:195:    ALOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthroughCallback.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthroughStbTrace.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videopassthrough/TunerVideoDecUtils.h:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerVideoDecUtils.h:102:	 *            "linear", "log100", "log316", "iec61966-2-4",
videopassthrough/TunerPassthroughVideo.cpp:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthroughVideo.cpp:10:#define LOG_NDEBUG 0
videopassthrough/TunerPassthroughVideo.cpp:11:#define LOG_TAG "TunerPassthroughVideo"
videopassthrough/TunerPassthroughVideo.cpp:37:#define FLOGV(fmt,...) ALOGV("[No-%d]-[%d] " fmt, mSyncPlayerInstanceNo, mPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerPassthroughVideo.cpp:38:#define FLOGD(fmt,...) ALOGD("[No-%d]-[%d] " fmt, mSyncPlayerInstanceNo, mPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerPassthroughVideo.cpp:39:#define FLOGI(fmt,...) ALOGI("[No-%d]-[%d] " fmt, mSyncPlayerInstanceNo, mPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerPassthroughVideo.cpp:40:#define FLOGE(fmt,...) ALOGE("[No-%d]-[%d] " fmt, mSyncPlayerInstanceNo, mPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerPassthroughVideo.cpp:47:    FLOGI("\n[KPI-FCC]--------------------------------\n"
videopassthrough/TunerPassthroughVideo.cpp:130:    mDebugServer->addModuleLogLevel(this, PROPERTY_VIDEOPASSTHROUGH_DEBUGLEVEL, debuglevel);
videopassthrough/TunerPassthroughVideo.cpp:137:    FLOGI("[KPI-FCC]~TunerPassthroughVideo %p \n",this);
videopassthrough/TunerPassthroughVideo.cpp:140:    FLOGI("(%p) mDemuxWrap.AmDemuxWrapperStop(vpid:0x%x)",this,mVideoCfg.vpid);
videopassthrough/TunerPassthroughVideo.cpp:145:        FLOGI("(%p) mEsDataHandler->StopVideoFilter \n",this);
videopassthrough/TunerPassthroughVideo.cpp:159:    FLOGI("[KPI-FCC]~TunerPassthroughVideo return %p\n",this);
videopassthrough/TunerPassthroughVideo.cpp:165:    FLOGI("[KPI-FCC] TunerPassthroughVideo Init\n");
videopassthrough/TunerPassthroughVideo.cpp:178:    FLOGI("[%s/%d] mime:%s dmx_id:%d video_pid:0x%x hw_sync_id:0x%x secure_mode:%d tunnel_renderer:%p",
videopassthrough/TunerPassthroughVideo.cpp:185:    FLOGI("[%s/%d] playerInstanceNo: %d, syncInstanceNo: %d, finalInstanceNo: %d",
videopassthrough/TunerPassthroughVideo.cpp:210:            FLOGI("[%s/%d] decoder feature info data_len:%zu actual_len:%zu",
videopassthrough/TunerPassthroughVideo.cpp:221:        FLOGI("[%s/%d] is support 4K:%d",
videopassthrough/TunerPassthroughVideo.cpp:235:    FLOGI("vcodecType:%d\n", mVideoCfg.vcodecType);
videopassthrough/TunerPassthroughVideo.cpp:249:    FLOGI("[KPI-FCC] TunerPassthroughVideo Init end\n");
videopassthrough/TunerPassthroughVideo.cpp:258:    FLOGI("mEnableFlowCtl:%d\n", mEnableFlowCtl);
videopassthrough/TunerPassthroughVideo.cpp:310:        FLOGE("Do not support this format %s\n", mime);
videopassthrough/TunerPassthroughVideo.cpp:322:            FLOGE("SEC_TVP resource busy\n");
videopassthrough/TunerPassthroughVideo.cpp:333:        FLOGI("mDemuxWrap.reset(new AmHwMultiDemuxWrapper())");
videopassthrough/TunerPassthroughVideo.cpp:353:    FLOGI("(%p) EsDataHandlerInit\n",this);
videopassthrough/TunerPassthroughVideo.cpp:372:    FLOGI("[KPI-FCC](%p) StartVideoDecoding\n",this);
videopassthrough/TunerPassthroughVideo.cpp:381:            FLOGI("(%p) --->StartVideoDecoding busy\n",this);
videopassthrough/TunerPassthroughVideo.cpp:403:        FLOGI("new mVideoDecoder\n");
videopassthrough/TunerPassthroughVideo.cpp:412:                FLOGI("mVideoDecoder->SetRender\n");
videopassthrough/TunerPassthroughVideo.cpp:417:        FLOGI("non tunnel mode\n");
videopassthrough/TunerPassthroughVideo.cpp:420:        FLOGI("post kWhatStartVideo\n");
videopassthrough/TunerPassthroughVideo.cpp:432:    FLOGI("initCheck %d\n", mState == INITIALIZING);
videopassthrough/TunerPassthroughVideo.cpp:437:    FLOGI("release %p\n",this);
videopassthrough/TunerPassthroughVideo.cpp:457:        FLOGI("mDemuxWrap.reset %p\n",this);
videopassthrough/TunerPassthroughVideo.cpp:470:    FLOGI("release return %p\n",this);
videopassthrough/TunerPassthroughVideo.cpp:480:    FLOGI("%s SetInstanceNo: %d\n", __FUNCTION__, numb);
videopassthrough/TunerPassthroughVideo.cpp:521:    FLOGI("(%p) SetSyncMode : %d \n",this,mode);
videopassthrough/TunerPassthroughVideo.cpp:535:    FLOGI("(%p)SetSyncMode is:%d, force mode:%d\n",this,mode,force_tsync_mode);
videopassthrough/TunerPassthroughVideo.cpp:559:    FLOGI("(%p)SetPcrPid : 0x%x\n",this,mPcrpid);
videopassthrough/TunerPassthroughVideo.cpp:570:    //FLOGI("SetVideoParams\n");
videopassthrough/TunerPassthroughVideo.cpp:572:        FLOGI("(%p) SetVideoParams error! (pParams == NULL) \n",this);
videopassthrough/TunerPassthroughVideo.cpp:579:    FLOGI("(%p) SetVideoParams vpid:0x%x vcodecType:%d\n",this,mVideoCfg.vpid,mVideoCfg.vcodecType);
videopassthrough/TunerPassthroughVideo.cpp:617:    FLOGI("(%p) PauseVideoDecoding\n",this);
videopassthrough/TunerPassthroughVideo.cpp:625:    FLOGI("(%p) PauseVideoDecoding finished\n",this);
videopassthrough/TunerPassthroughVideo.cpp:632:    FLOGI("(%p) ResumeVideoDecoding\n",this);
videopassthrough/TunerPassthroughVideo.cpp:639:    FLOGI("(%p) ResumeVideoDecoding finished\n",this);
videopassthrough/TunerPassthroughVideo.cpp:648:    FLOGI("(%p) FlushVideoDecoding\n",this);
videopassthrough/TunerPassthroughVideo.cpp:659:    FLOGI("(%p) FlushVideoDecoding response\n",this);
videopassthrough/TunerPassthroughVideo.cpp:668:    FLOGI("(%p) StopVideoDecoding,workmode:%d\n",this, mPlayerCtrl.workMode);
videopassthrough/TunerPassthroughVideo.cpp:690:    FLOGI("(%p) StopVideoDecoding response\n",this);
videopassthrough/TunerPassthroughVideo.cpp:695:    debuglevel = mDebugServer->getModuleLogLevel(this);
videopassthrough/TunerPassthroughVideo.cpp:714:                    FLOGI("(%p)onMessageReceived dmx_buf_phy_start:0x%x dmx_total_size:%d\n",
videopassthrough/TunerPassthroughVideo.cpp:719:                    FLOGI("(%p) kWhatStartVideo mWriteEs->OnWriteEsStart Video\n",this);
videopassthrough/TunerPassthroughVideo.cpp:754:                FLOGI("%s:%d dispMode:%d\n", __FUNCTION__, __LINE__, pram.dispMode);
videopassthrough/TunerPassthroughVideo.cpp:787:                FLOGI("[KPI-FCC](%p) StartVideoDecoding end\n",this);
videopassthrough/TunerPassthroughVideo.cpp:815:                FLOGI("(%p) mEsDataHandler->StopVideoFilter \n",this);
videopassthrough/TunerPassthroughVideo.cpp:840:            FLOGI("(%p) mDemuxWrap.AmDemuxWrapperStop(vpid:0x%x)",this,mVideoCfg.vpid);
videopassthrough/TunerPassthroughVideo.cpp:845:                FLOGI("(%p) mEsDataHandler->StopVideoFilter \n",this);
videopassthrough/TunerPassthroughVideo.cpp:858:                FLOGI("(%p) --->FlushVideoDecoding busy\n",this);
videopassthrough/TunerPassthroughVideo.cpp:874:                FLOGI("non tunnel mode\n");
videopassthrough/TunerPassthroughVideo.cpp:876:                FLOGI("post kWhatStartVideo\n");
videopassthrough/TunerPassthroughVideo.cpp:883:                FLOGI("(%p)onMessageReceived dmx_buf_phy_start:0x%x dmx_total_size:%d\n",
videopassthrough/TunerPassthroughVideo.cpp:887:                FLOGI("(%p) kWhatStartVideo mWriteEs->OnWriteEsStart Video\n",this);
videopassthrough/TunerPassthroughVideo.cpp:921:            FLOGI("%s:%d dispMode:%d\n", __FUNCTION__, __LINE__, pram.dispMode);
videopassthrough/TunerPassthroughVideo.cpp:984:            debuglevel = mDebugServer->getModuleLogLevel(this);
videopassthrough/TunerPassthroughVideo.cpp:991:        FLOGI("kWhatResetDVESPath");
videopassthrough/TunerPassthroughVideo.cpp:1003:    FLOGI("(%p) typeinplayer:%d)",this,typeinplayer);
videopassthrough/TunerPassthroughVideo.cpp:1056:    FLOGI("(%p) %s at # %d type %d fmt %d\n",this,__FUNCTION__,__LINE__,typeinplayer,vfmt);
videopassthrough/TunerPassthroughVideo.cpp:1062:    // ALOGV("onEvent %d, mPlayerCallbackFn %p, param %p\n", event, mPlayerCallbackFn, param);
videopassthrough/TunerPassthroughVideo.cpp:1079:                    FLOGI("AFD GOT afd 0x%" PRIX64, (int64_t)((uint8_t*)ev.event.mpeg_user_data.data));
videopassthrough/TunerPassthroughVideo.cpp:1081:                    FLOGI("USERDATA param nullptr\n");
videopassthrough/TunerPassthroughVideo.cpp:1089:                FLOGI("VIDEO FORMAT CHANGED [%d x %d] @%d, %d\n",
videopassthrough/TunerPassthroughVideo.cpp:1095:                FLOGI("ASAPECT RATIO CHANGE SAR[%d x %d] DAR[%d x %d]\n",
videopassthrough/TunerPassthroughVideo.cpp:1103:                FLOGI("VIDEO FORMAT param %p, paramsize %d\n",param, paramsize);
videopassthrough/TunerPassthroughVideo.cpp:1119:            FLOGI("isStopVideo:%d,displayer first video\n",mStopVideo);
videopassthrough/TunerPassthroughVideo.cpp:1127:            FLOGI("isStopVideo:%d,decodec first video\n",mStopVideo);
videopassthrough/TunerPassthroughVideo.cpp:1141:            FLOGI("DECODER_STAT INFO\n");
videopassthrough/TunerPassthroughVideo.cpp:1146:                FLOGI("DECODER STAT INFO:\n vf_type:0x%x\n",
videopassthrough/TunerPassthroughVideo.cpp:1151:                FLOGI("DECODER STAT param %p, paramsize %d\n",param, paramsize);
videopassthrough/TunerPassthroughVideo.cpp:1154:            FLOGI("mStopAudio:%d,decodec first audio\n",mStopAudio);
videopassthrough/TunerPassthroughVideo.cpp:1161:            FLOGI("isStopVideo:%d,mStopAudio:%d,av sync done!\n",mStopVideo,mStopAudio);
videopassthrough/TunerPassthroughVideo.cpp:1181:            FLOGI("isStopVideo:%d,frame error count callback \n",mStopVideo);
videopassthrough/TunerPassthroughVideo.cpp:1187:            FLOGI("isStopVideo:%d,videp unsupport \n",mStopVideo);
videopassthrough/TunerPassthroughVideo.cpp:1194:            //FLOGI("video overflow\n");
videopassthrough/TunerPassthroughVideo.cpp:1200:            //FLOGI("video underflow\n");
videopassthrough/TunerPassthroughVideo.cpp:1206:            //FLOGI("audio overflow\n");
videopassthrough/TunerPassthroughVideo.cpp:1212:            //FLOGI("audio underflow\n");
videopassthrough/TunerPassthroughVideo.cpp:1217:            //FLOGI("video invalid timestamp!\n");
videopassthrough/TunerPassthroughVideo.cpp:1221:            //FLOGI("video invalid data!\n");
videopassthrough/TunerPassthroughVideo.cpp:1225:            //FLOGI("audio invalid timestamp!\n");
videopassthrough/TunerPassthroughVideo.cpp:1229:            //FLOGI("audio invalid data!\n");
videopassthrough/TunerPassthroughVideo.cpp:1233:            FLOGV("instance was preempted!\n");
videopassthrough/TunerPassthroughVideo.cpp:1240:                FLOGI("change decoder to dv path\n");
videopassthrough/TunerPassthroughVideo.cpp:1245:            FLOGV("EOS event post!\n");
videopassthrough/TunerPassthroughVideo.cpp:1251:            FLOGI("invalid msg type\n");
videopassthrough/TunerPassthroughVideo.cpp:1262:    FLOGE("onError\n");
videopassthrough/TunerPassthroughVideo.cpp:1269:    FLOGI("(%p) typeinplayer:%d",this,iCodecType);
videopassthrough/TunerPassthroughVideo.cpp:1286:        FLOGI("unsupport dv fmt, need port more");
videopassthrough/TunerPassthroughVideo.cpp:1301:        FLOGI("(%p) resetDVPath post\n",this);
videopassthrough/TunerPassthroughVideo.cpp:1311:        FLOGI("not register renderevent callback\n");
videopassthrough/TunerPassthroughVideo.cpp:1344:    FLOGE("packCallBackDataAndSend");
videopassthrough/TunerPassthroughVideo.cpp:1348:        FLOGE("fury send data !");
videopassthrough/TunerPassthroughVideo.cpp:1354:    FLOGE("packCallBackData");
videopassthrough/TunerPassthroughVideo.cpp:1380:                FLOGE("SAR value:%d, report_width:%f, report_height:%f", value, report_width, report_height);
videopassthrough/TunerPassthroughVideo.cpp:1390:                    FLOGE("video has no sar and dar info, no report!, type:%d", messageType);
videopassthrough/TunerPassthroughVideo.cpp:1398:                FLOGE("SAR value:%d, dar:%f, report_width:%f, report_height:%f", value, dar, report_width, report_height);
videopassthrough/TunerPassthroughVideo.cpp:1406:        // FLOGE("afd raw data:%llx", (uint32_t)(*(uint32_t *)ev.event.mpeg_user_data.data));
videopassthrough/TunerPassthroughVideo.cpp:1421:        FLOGE("TUNER_PASSTHROUGH_CB_EVENT_INDEX_VIDEO_VF_TYPE value:0x%x", value);
videopassthrough/TunerPassthroughVideo.cpp:1426:        FLOGE("TUNER_PASSTHROUGH_CB_EVENT_INDEX_VIDEO_EOS value:0x%x", value);
videopassthrough/TunerPassthroughVideo.cpp:1430:        FLOGE("not support video info type:%d", messageType);
videopassthrough/TunerPassthroughVideo.cpp:1439:    FLOGI("playload:%" PRIX64, mVideoInfoValue.payload);
videopassthrough/TunerPassthroughVideo.cpp:1444:    FLOGI("SetTrickSpeed scale:%f\n",scale);
videopassthrough/TunerPassthroughVideo.cpp:1465:    FLOGI("SetRenderCallBackEventFlag flag:%" PRIX64, eventflag);
videopassthrough/TunerPassthroughVideo.cpp:1471:        FLOGI("enable post afd info, need open userdata, may affect cc");
videopassthrough/TunerPassthroughVideo.cpp:1484:    FLOGI("SetPassthroughParams type:%" PRId32 ", param1:%" PRId64 ", param2:%" PRId64 ", param3:%" PRId64,
videopassthrough/TunerPassthroughVideo.cpp:1490:            FLOGI("AM_PASSTHROUGH_PARAM_MUTE:%" PRId64, param1);
videopassthrough/TunerPassthroughVideo.cpp:1501:            FLOGI("AM_PASSTHROUGH_PARAM_SCREEN_COLOR:color:%" PRId64 ", mode:%" PRId64, param1, param2);
videopassthrough/TunerPassthroughVideo.cpp:1512:            FLOGI("AM_PASSTHROUGH_PARAM_TRANSITION_MODE_BEFORE:%" PRId64, param1);
videopassthrough/TunerPassthroughVideo.cpp:1522:            FLOGI("AM_PASSTHROUGH_PARAM_TRANSITION_MODE_AFTER:%" PRId64, param1);
videopassthrough/TunerPassthroughVideo.cpp:1532:            FLOGI("AM_PASSTHROUGH_PARAM_TRANSITION_PREROLL_RATE:%" PRId64, param1);
videopassthrough/TunerPassthroughVideo.cpp:1544:            FLOGI("AM_PASSTHROUGH_PARAM_TRANSITION_PREROLL_AV_TOLERANCE:%" PRId64, param1);
videopassthrough/TunerPassthroughVideo.cpp:1556:            FLOGI("AM_PASSTHROUGH_PARAM_PLAYBACK_STATUS:%" PRId64, param1);
videopassthrough/TunerPassthroughVideo.cpp:1566:            FLOGI("AM_PASSTHROUGH_PARAM_AVSYNC_PROPERTY_SYNCMODE:%" PRId64, param1);
videopassthrough/TunerPassthroughVideo.cpp:1576:            FLOGI("AM_PASSTHROUGH_PARAM_INJECT_DONE_WAIT_EOS:%" PRId64, param1);
videopassthrough/TunerPassthroughVideo.cpp:1589:            FLOGI("AM_PASSTHROUGH_PARAM_VIDEO_DROP_PTS:%" PRId64, param1);
videopassthrough/TunerPassthroughVideo.cpp:1598:            FLOGI("setting not support in this version\n");
videopassthrough/TunerPassthroughVideo.cpp:1610:    FLOGI("VDA_SET_VIDEO_BLACKOUT:%d\n",VDA_SET_VIDEO_BLACKOUT);
videopassthrough/TunerPassthroughVideo.cpp:1645:    FLOGI("[KPI-FCC][%s/%d] workMode: %d", __FUNCTION__, __LINE__, workMode);
videopassthrough/TunerPassthroughVideo.cpp:1648:        FLOGI("[%s/%d] workMode: %d", __FUNCTION__, __LINE__, workMode);
videopassthrough/TunerPassthroughVideo.cpp:1651:        FLOGI("[%s/%d] workMode: %d, mRender is NULL", __FUNCTION__, __LINE__, workMode);
videopassthrough/TunerPassthroughVideo.cpp:1657:        FLOGI("[%s/%d] workMode: %d, mVideoDecoder is NULL", __FUNCTION__, __LINE__, workMode);
videopassthrough/TunerPassthroughVideo.cpp:1685:    FLOGI("EsDataHandler(%p) dmx:%p\n", this, mDemuxWrap->get());
videopassthrough/TunerPassthroughVideo.cpp:1693:    FLOGI("~EsDataHandler\n");
videopassthrough/TunerPassthroughVideo.cpp:1711:    FLOGI("EsDataHandler StartVideoFilter\n");
videopassthrough/TunerPassthroughVideo.cpp:1719:    FLOGI("EsDataHandler StopVideoFilter\n");
videopassthrough/TunerPassthroughVideo.cpp:1725:        ALOGD("reset presize:%d", presize);
videopassthrough/TunerPassthroughVideo.cpp:1727:    ALOGI("EsDataHandler StopVideoFilter\n");
videopassthrough/TunerPassthroughVideo.cpp:1733:    ALOGI("EsDataHandler SetVideoLoopEnable:%d\n", mVideoLoop);
videopassthrough/TunerPassthroughVideo.cpp:1738:    FLOGI("EsDataHandler PauseVideoFilter\n");
videopassthrough/TunerPassthroughVideo.cpp:1756:            FLOGE("decoder not ready need retry\n");
videopassthrough/TunerPassthroughVideo.cpp:1778:                    // FLOGI("video write error\n");
videopassthrough/TunerPassthroughVideo.cpp:1788:        FLOGI("EsDataHandler ReadBuffer Video Stop!!\n");
videopassthrough/TunerPassthroughVideo.cpp:1801:        FLOGE("[%s/%d] Parameter error!", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthroughVideo.cpp:1818:        FLOGD("NewPts:%" PRId64 " RendmediaTimeUs:%" PRId64 " FirstPtsUs:%" PRId64 " diff:%" PRId64 " diff2:%" PRId64 "\n",
videopassthrough/TunerPassthroughVideo.cpp:1833:        //ALOGI("mVideoFirstPtsUs:%lld \n",mVideoFirstPtsUs);
videopassthrough/TunerPassthroughVideo.cpp:1847:        FLOGD("mVideoCacheTime:%" PRId64 " ms\n", *mVideoCacheTime);
videopassthrough/TunerPassthroughVideo.cpp:1865:        FLOGE("[%s/%d] Parameter error!", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthroughVideo.cpp:1869:        FLOGE("[%s/%d] Invalid vpid:0x%x!", __FUNCTION__, __LINE__, vpid);
videopassthrough/TunerPassthroughVideo.cpp:1914:       //FLOGD("wp:0x%x rp:0x%x size:%d\n",writeDecoder_stbuf_wp,stbuf_rp,writeDataLen);
videopassthrough/TunerPassthroughVideo.cpp:1927:        FLOGD("[%s/%d] start:0x%x end:0x%x wp:0x%x rp:0x%x writeDataLen:%d free_percentage:%" PRId64 " free_len:%d data_len:%d\n",
videopassthrough/TunerPassthroughVideo.cpp:1943:            ALOGD("update presize:%d", presize);
videopassthrough/TunerPassthroughVideo.cpp:1962:        FLOGE("[%s/%d] GetVideoBufferLevel failed! size:%d ret:0x%x\n", __FUNCTION__, __LINE__, mDecBufStatus.size, -ret);
videopassthrough/TunerPassthroughVideo.cpp:1988:        FLOGD("[%s/%d] stbuf_rp:0x%x", __FUNCTION__, __LINE__, stbuf_rp);
videopassthrough/TunerPassthroughVideo.cpp:2009:                FLOGD("GetDecoderBufferFreePercentage ret:%d free percentage:%" PRId64 "", -ret, decoderBufFreePercentage);
videopassthrough/TunerPassthroughVideo.cpp:2035:    //FLOGD("EsDataHandler::Ammh_onMessageReceived what:%d\n", msg->what());
videopassthrough/TunerPassthroughVideo.cpp:2037:        FLOGE("EsDataHandler Ammh_onMessageReceived handler has not started!\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:10:#define LOG_NDEBUG 0
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:11:#define LOG_TAG "TunerVideoDecV4L2Wrapper"
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:12:#include <amlogic/am_gralloc_ext.h>
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:43:#define FLOGV(fmt,...) ALOGV("[No-%d] " fmt, mSyncPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:44:#define FLOGD(fmt,...) ALOGD("[No-%d] " fmt, mSyncPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:45:#define FLOGI(fmt,...) ALOGI("[No-%d] " fmt, mSyncPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:46:#define FLOGE(fmt,...) ALOGE("[No-%d] " fmt, mSyncPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:118:    FLOGI("[%s/%d] %p mVideoTunnel:%d, mNumMargin:%d\n", __FUNCTION__, __LINE__, this, mVideoTunnel, mNumMargin);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:125:    FLOGI("[%s/%d] in %p\n", __FUNCTION__, __LINE__, this);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:131:        FLOGV("release mVideoDecNonTunneLooper.clear\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:133:    FLOGI("[%s/%d] done\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:162:        FLOGE("show old buffer [%s/%d] index:%d %d\n", __FUNCTION__, __LINE__, i, mLastFdStatus[i].mDmaBufFd);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:164:            FLOGE("need reset vdec now, close:%d\n", mLastFdStatus[i].mDmaBufFd);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:176:    FLOGI("[%s/%d] mLastOutputBufferNum %d\n",__FUNCTION__, __LINE__,mLastOutputBufferNum);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:183:                FLOGI("[%s/%d] toBeClosed render index:%d %d\n",
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:188:                FLOGI("[%s/%d] toBeClosed close index:%d %d\n",
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:195:    FLOGI("[%s/%d] mLastRenderUseFdCount %d\n",__FUNCTION__, __LINE__,mLastRenderUseFdCount);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:201:    FLOGE("CancelInvalidBufferfd [%s/%d] num:%d\n", __FUNCTION__, __LINE__, mLastOutputBufferNum);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:203:        FLOGE("CancelInvalidBufferfd [%s/%d] %d\n", __FUNCTION__, __LINE__, mLastFdStatus[i].mDmaBufFd);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:207:            FLOGE("CancelInvalidBufferfd [%s/%d]close now index:%d %d\n", __FUNCTION__, __LINE__, i, mLastFdStatus[i].mDmaBufFd);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:211:            FLOGE("CancelInvalidBufferfd [%s/%d] toBeClosed index:%d %d\n", __FUNCTION__, __LINE__, i, mLastFdStatus[i].mDmaBufFd);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:216:        FLOGE("[%s/%d] now fd:%d\n", __FUNCTION__, __LINE__, mFdStatus[i].mDmaBufFd);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:225:        FLOGV("[%s/%d] dqslot:%d %d\n", __FUNCTION__, __LINE__,
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:255:    FLOGI("[%s/%d] vpid:0x%x\n", __FUNCTION__, __LINE__, vpid);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:266:    FLOGI("[KPI-FCC][%s/%d] mode:%d\n", __FUNCTION__, __LINE__, mode);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:280:    ALOGI("%s end  \n",__FUNCTION__);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:360:       /// FLOGD("fd trace:queueOutputBuffer output buffer success dqslot:%d pictureId:%d metafd:%d\n", dqslot, pictureId, metafd);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:367:        FLOGI("[%s/%d] mOutputBufferNum:%d mCreateOutputBufferCount:%d\n",
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:374:                    FLOGE("[%s/%d] toBeClosed close old index:%d %d\n",
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:390:                                FLOGE("alloc image size:%d, width:%d, height:%d", imagineSize, mDqWidth, mDqHeight);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:400:                               FLOGD("fd trace: createOutputBuffer slot:%d i:%d, fd:%d\n",
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:411:                    FLOGD("not normal,why old fd not recycle in dequeue metafd:%d\n", metafd);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:418:        //     FLOGE("DequeueSurfaceBuffer printf old buffer [%s/%d] index:%d %d\n", __FUNCTION__, __LINE__, i, mLastFdStatus[i].mDmaBufFd);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:427:    FLOGD("[%s] pictureId:%d slot:%d timestampUs%" PRId64 "\n",__FUNCTION__,pictureId, slot, timestampUs);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:438:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:442:            FLOGI("[%s/%d] %p work mode normal, start render: %p\n", __FUNCTION__, __LINE__, this, mRender.get());
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:446:        FLOGI("[%s/%d] %p work mode cache, not start render: %p\n", __FUNCTION__, __LINE__, this, mRender.get());
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:451:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:457:    FLOGI("[%s/%d]", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:463:    FLOGI("FlushOutputBuffer in OnFlush mQueuedSlot.size():%d",(int)mQueuedSlot.size());
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:470:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:472:        FLOGE("mState is STOPPED!\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:478:        FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:499:    FLOGI("[%s/%d]", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:507:        FLOGI("wait for flush callback\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:512:            FLOGI("dma fd map size %zu need close\n", input_fd_map_.size());
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:532:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:534:        ALOGE("mState is STOPPED!\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:548:        FLOGI("dma fd map size %zu need close\n", input_fd_map_.size());
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:552:                FLOGI("fd:%d", fd);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:586:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:625:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:634:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:641:    FLOGD("TunerVideoDecV4L2Wrapper::Ammh_onMessageReceived what:%d\n", msg->what());
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:697:                    FLOGI("---->onOutputBufferDone Drop frame mediaTimeUs:%" PRId64 " mRendTimeUs:%" PRId64 " nowTimeUs:%" PRId64 "\n",mediaTimeUs, timestamp, AmmhLooper::GetNowUs());
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:700:                FLOGE("kWhatQueueOutPutNotify NoFind,timestampNs(%" PRId64 ") index(%d) BufferSlot.size(%d)\n",timestamp,pictureId,(int)mOutputBufferSlot.size());
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:708:                FLOGD("Ammh_onMessageReceived kWhatStop mState:%d return\n", mState);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:720:            FLOGD("Ammh_onMessageReceived kWhatFlush vpid:%d\n",mVPid);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:725:               FLOGD("Ammh_onMessageReceived kWhatFlush mState > STARTED\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:736:            FLOGD("Ammh_onMessageReceived kWhatReset vpid:%d\n",mVPid);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:822:                FLOGE("fmt not support, use default dw value:-1");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:826:        FLOGI("fmt:%d, dw:%d", vformat, doublewrite);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:850:    FLOGI("mVPid:0x%x vFmt:%d mDisplayMode:%dpram.dmx_player_id %d \n", pram.vpid, pram.vFmt, mDisplayMode, pram.dmx_player_id);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:914:       FLOGE("TunerVideoDecV4L2Wrapper::Write return not mInit\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:919:        FLOGE("TunerVideoDecV4L2Wrapper::Write return not STARTED mState:%d\n",mState);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:937:        // FLOGI("fd trace In:dma fd %d length %zu fd_dup %d mInputQueueCount:%d\n", fd, input_fd_map_.size(), fd_dup, mInputQueueCount);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:954:        ALOGE(" mMedia == NULL");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:965:    FLOGE("onOutputFormatChanged bufnum %d, width %d, height %d,mDqWidth:%d,mDqHeight:%d\n",
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:968:        ALOGE(" mMedia == NULL");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:975:        FLOGE("%s, msg == NULL",__func__);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1028:            FLOGE("double write mode:%d replaceBuffer:%d", mDoublewrite, replaceBuffer);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1035:            FLOGE("double write mode: %d, need / 4", mDoublewrite);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1042:            FLOGE("double write mode:%d replaceBuffer:%d", mDoublewrite, replaceBuffer);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1050:    FLOGE("alloc image size:%d, width:%d, height:%d", imagineSize, width, height);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1053:        FLOGE("outof buf DMA buffer size\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1079:                FLOGD("createOutputBuffer slot:%d i:%d, fd:%d\n", slot,i, mFdStatus[i].mDmaBufFd);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1088:        //         FLOGD("queueOutputBuffer slot:%d i:%d \n", slot,i);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1115:        FLOGD("requestedNumOfBuffers:%d mOutputBufferNum:%d mLastRenderUseFdCount:%d", requestedNumOfBuffers,mOutputBufferNum,mLastRenderUseFdCount);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1134:                FLOGD("fd trace: createOutputBuffer slot:%d i:%d, fd:%d\n", slot,i, mFdStatus[i].mDmaBufFd);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1138:        FLOGD("mCreateOutputBufferDoneCount:%d \n", mCreateOutputBufferDoneCount);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1147:        //         FLOGD("queueOutputBuffer slot:%d i:%d \n", slot,i);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1163:    FLOGI("onOutputFormatChanged ok this %p>>>>>\n", this);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1196:        ALOGI("onOutputBufferDone param NULL pointer\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1208:        ALOGI("pictureBufferId invalid\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1239:            // FLOGI("fd trace Out: mInputQueueCount %d dmabuf_wrapper_export %d, ret:%d\n", bitstreamId, fd, ret);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1279:        FLOGI("input parameter was NULL, SetTraceInfo failed! \n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1286:    FLOGI("onUpdateDecInfo info %p, size %d\n", info, isize);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1291:        FLOGI("onFlushDone info\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1299:        FLOGI("onResetDone info\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1311:        FLOGI("onEvent interlaced:%d\n", mInterlace);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1323:        FLOGI("onEvent interlaced:%d\n", mInterlace);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1335:        // FLOGI("onEvent framerate:%d\n", mFrameRate);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1346:        FLOGI("onEvent V4L2_VIDEO_CHANGE:[%d x %d] @%d\n", mVidFmt.frame_width, mVidFmt.frame_height,mVidFmt.frame_rate);
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1355:        FLOGI("onEvent V4L2_VIDEO_RESET: decoder need reset\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1358:        FLOGI("onEvent V4L2_STREAM_EOF: decoder send eof\n");
videopassthrough/TunerVideoDecV4L2Wrapper.cpp:1382:    FLOGV("VideodecSurfaceWrapper::registerCallback \n");
videopassthrough/TunerPassthroughRenderer.h:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthroughV4L2Video.cpp:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthroughV4L2Video.cpp:11:#define LOG_NDEBUG 0
videopassthrough/TunerPassthroughV4L2Video.cpp:12:#define LOG_TAG "TunerPassthroughV4L2Video"
videopassthrough/TunerPassthroughV4L2Video.cpp:34:#define FLOGV(fmt,...) ALOGV("[No-%d]-[%d] " fmt, mSyncPlayerInstanceNo, mPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerPassthroughV4L2Video.cpp:35:#define FLOGD(fmt,...) ALOGD("[No-%d]-[%d] " fmt, mSyncPlayerInstanceNo, mPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerPassthroughV4L2Video.cpp:36:#define FLOGI(fmt,...) ALOGI("[No-%d]-[%d] " fmt, mSyncPlayerInstanceNo, mPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerPassthroughV4L2Video.cpp:37:#define FLOGE(fmt,...) ALOGE("[No-%d]-[%d] " fmt, mSyncPlayerInstanceNo, mPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerPassthroughV4L2Video.cpp:43:    FLOGI("\n[KPI-FCC]--------------------------------\n"
videopassthrough/TunerPassthroughV4L2Video.cpp:113:    mDebugServer->addModuleLogLevel(this, PROPERTY_VIDEOPASSTHROUGH_DEBUGLEVEL, debuglevel);
videopassthrough/TunerPassthroughV4L2Video.cpp:119:    FLOGI("[KPI-FCC]~TunerPassthroughV4L2Video %p \n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:124:        FLOGI("(%p) mDemuxWrap.AmDemuxWrapperStop(vpid:0x%x)",this,mVideoCfg.vpid);
videopassthrough/TunerPassthroughV4L2Video.cpp:128:        FLOGI("(%p) mEsDataHandler->StopVideoFilter \n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:139:    FLOGI("[KPI-FCC]~TunerPassthroughV4L2Video return %p\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:145:    FLOGI("[KPI-FCC] TunerPassthroughV4L2Video Init\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:154:    FLOGI("[%s/%d] mime:%s dmx_id:%d video_pid:0x%x hw_sync_id:0x%x secure_mode:%d tunnel_renderer:%p",
videopassthrough/TunerPassthroughV4L2Video.cpp:161:    FLOGI("[%s/%d] playerInstanceNo: %d, syncInstanceNo: %d, finalInstanceNo: %d",
videopassthrough/TunerPassthroughV4L2Video.cpp:186:            FLOGI("[%s/%d] decoder feature info data_len:%zu actual_len:%zu",
videopassthrough/TunerPassthroughV4L2Video.cpp:197:        FLOGI("[%s/%d] is support 4K:%d",
videopassthrough/TunerPassthroughV4L2Video.cpp:213:    FLOGI("vcodecType:%d\n", mVideoCfg.vcodecType);
videopassthrough/TunerPassthroughV4L2Video.cpp:227:    FLOGI("[KPI-FCC] TunerPassthroughV4L2Video Init end\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:290:        FLOGE("Do not support this format %s\n", mime);
videopassthrough/TunerPassthroughV4L2Video.cpp:301:        ALOGE("renderEventHandle invalid param %p %p\n", thiz, args);
videopassthrough/TunerPassthroughV4L2Video.cpp:307:        ALOGE("renderEventHandle invalid param %p\n", param);
videopassthrough/TunerPassthroughV4L2Video.cpp:313:        ALOGI("V4l2 stream mode underflow:%d\n", underflow);
videopassthrough/TunerPassthroughV4L2Video.cpp:338:            FLOGE("SEC_TVP resource busy\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:349:        FLOGI("mDemuxWrap.reset(new AmHwMultiDemuxWrapper())");
videopassthrough/TunerPassthroughV4L2Video.cpp:369:    FLOGI("(%p) EsDataHandlerInit\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:389:    FLOGI("[KPI-FCC](%p) StartVideoDecoding\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:398:            FLOGI("(%p) --->StartVideoDecoding busy\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:419:        FLOGI("new mVideoDecoder\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:428:                FLOGI("mVideoDecoder->SetRender\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:433:        FLOGI("non tunnel mode\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:436:        FLOGI("post kWhatStartVideo\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:449:    FLOGI("release %p\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:468:        FLOGI("mDemuxWrap.reset %p\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:480:    FLOGI("release return %p\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:490:    FLOGI("%s SetInstanceNo: %d\n", __FUNCTION__, numb);
videopassthrough/TunerPassthroughV4L2Video.cpp:507:    FLOGI("(%p)SetPcrPid : 0x%x\n",this,mPcrpid);
videopassthrough/TunerPassthroughV4L2Video.cpp:513:    //FLOGI("SetVideoParams\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:515:        FLOGI("(%p) SetVideoParams error! (pParams == NULL) \n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:522:    FLOGI("(%p) SetVideoParams vpid:0x%x vcodecType:%d\n",this,mVideoCfg.vpid,mVideoCfg.vcodecType);
videopassthrough/TunerPassthroughV4L2Video.cpp:560:    FLOGI("(%p) PauseVideoDecoding\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:567:    FLOGI("(%p) PauseVideoDecoding finished\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:572:    FLOGI("(%p) ResumeVideoDecoding\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:578:    FLOGI("(%p) ResumeVideoDecoding finished\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:585:    FLOGI("(%p) FlushVideoDecoding\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:596:    FLOGI("(%p) FlushVideoDecoding response\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:605:    FLOGI("(%p) ResetVideoDecoding\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:616:    FLOGI("(%p) ResetVideoDecoding response\n", this);
videopassthrough/TunerPassthroughV4L2Video.cpp:626:    FLOGI("(%p) StopVideoDecoding,workmode:%d\n",this, mPlayerCtrl.workMode);
videopassthrough/TunerPassthroughV4L2Video.cpp:646:    FLOGI("(%p) StopVideoDecoding response\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:651:    debuglevel = mDebugServer->getModuleLogLevel(this);
videopassthrough/TunerPassthroughV4L2Video.cpp:669:                    FLOGI("(%p)onMessageReceived dmx_buf_phy_start:0x%x dmx_total_size:%d\n",
videopassthrough/TunerPassthroughV4L2Video.cpp:674:                    FLOGI("(%p) kWhatStartVideo mWriteEs->OnWriteEsStart Video\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:706:                FLOGI("%s:%d mPlayerInstanceNo:%d Initialize Para.player_id %d \n",
videopassthrough/TunerPassthroughV4L2Video.cpp:731:                FLOGI("[KPI-FCC](%p) StartVideoDecoding end\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:758:            FLOGI("(%p) mDemuxWrap.AmDemuxWrapperStop(vpid:0x%x)",this,mVideoCfg.vpid);
videopassthrough/TunerPassthroughV4L2Video.cpp:760:                FLOGI("(%p) mEsDataHandler->StopVideoFilter \n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:784:            FLOGI("(%p) mDemuxWrap.AmDemuxWrapperStop(vpid:0x%x)",this,mVideoCfg.vpid);
videopassthrough/TunerPassthroughV4L2Video.cpp:789:                FLOGI("(%p) mEsDataHandler->StopVideoFilter \n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:814:                FLOGI("(%p)onMessageReceived dmx_buf_phy_start:0x%x dmx_total_size:%d\n",
videopassthrough/TunerPassthroughV4L2Video.cpp:818:                FLOGI("(%p) kWhatStartVideo mWriteEs->OnWriteEsStart Video\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:842:            FLOGI("%s:%d dispMode:%d\n", __FUNCTION__, __LINE__, pram.dispMode);
videopassthrough/TunerPassthroughV4L2Video.cpp:868:            FLOGI("(%p) mDemuxWrap.AmDemuxWrapperStop(vpid:0x%x)",this,mVideoCfg.vpid);
videopassthrough/TunerPassthroughV4L2Video.cpp:873:                FLOGI("(%p) mEsDataHandler->StopVideoFilter \n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:898:                FLOGI("(%p)onMessageReceived dmx_buf_phy_start:0x%x dmx_total_size:%d\n",
videopassthrough/TunerPassthroughV4L2Video.cpp:902:                FLOGI("(%p) kWhatStartVideo mWriteEs->OnWriteEsStart Video\n",this);
videopassthrough/TunerPassthroughV4L2Video.cpp:926:            FLOGI("%s:%d dispMode:%d\n", __FUNCTION__, __LINE__, pram.dispMode);
videopassthrough/TunerPassthroughV4L2Video.cpp:977:                // FLOGD("GetDecoderBufferFreePercentage ret:%d free percentage:%" PRId64 "", -ret, decoderBufFreePercentage);
videopassthrough/TunerPassthroughV4L2Video.cpp:988:                    FLOGD("get decoder status reset flag:%d", decoderStatus);
videopassthrough/TunerPassthroughV4L2Video.cpp:1003:            debuglevel = mDebugServer->getModuleLogLevel(this);
videopassthrough/TunerPassthroughV4L2Video.cpp:1031:    FLOGI("(%p) typeinplayer:%d)",this,typeinplayer);
videopassthrough/TunerPassthroughV4L2Video.cpp:1084:    FLOGI("(%p) %s at # %d type %d fmt %d\n",this,__FUNCTION__,__LINE__,typeinplayer,vfmt);
videopassthrough/TunerPassthroughV4L2Video.cpp:1104:                // FLOGI("USERDATA GOT len:%d", ev.event.mpeg_user_data.len);
videopassthrough/TunerPassthroughV4L2Video.cpp:1106:                    FLOGI("USERDATA param nullptr\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1113:                FLOGI("VIDEO FORMAT CHANGED [%d x %d] @%d, %d\n",
videopassthrough/TunerPassthroughV4L2Video.cpp:1119:                FLOGI("ASPECT RATIO CHANGE SAR[%d x %d] DAR[%d x %d]\n",
videopassthrough/TunerPassthroughV4L2Video.cpp:1127:                FLOGI("VIDEO FORMAT param %p, paramsize %d, event:%d\n",param, paramsize, event);
videopassthrough/TunerPassthroughV4L2Video.cpp:1133:            FLOGI("displayer first video\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1137:            FLOGI("decodec first video\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1146:            FLOGI("DECODER_STAT INFO\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1150:                FLOGI("DECODER STAT INFO:\n vf_type:0x%x\n", ev.event.vdec_stat.vf_type);
videopassthrough/TunerPassthroughV4L2Video.cpp:1153:                FLOGI("DECODER STAT param %p, paramsize %d\n",param, paramsize);
videopassthrough/TunerPassthroughV4L2Video.cpp:1158:            FLOGI("av sync done!\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1166:            FLOGI("frame error count callback \n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1170:            FLOGI("video unsupport \n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1176:            FLOGI("video overflow:%d\n", video_overflow_num);
videopassthrough/TunerPassthroughV4L2Video.cpp:1182:            FLOGI("video underflow：%d\n", video_underflow_num);
videopassthrough/TunerPassthroughV4L2Video.cpp:1186:            FLOGI("video invalid timestamp!\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1191:            FLOGI("video invalid data!\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1195:            FLOGV("instance was preempted!\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1199:            FLOGI("EOS event post!\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1221:    FLOGE("onError\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1227:        FLOGI("not register renderevent callback\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1260:    FLOGE("packCallBackDataAndSend");
videopassthrough/TunerPassthroughV4L2Video.cpp:1266:    FLOGE("packCallBackData");
videopassthrough/TunerPassthroughV4L2Video.cpp:1292:                FLOGE("SAR value:%d, report_width:%f, report_height:%f", value, report_width, report_height);
videopassthrough/TunerPassthroughV4L2Video.cpp:1302:                    FLOGE("video has no sar and dar info, no report!, type:%d", messageType);
videopassthrough/TunerPassthroughV4L2Video.cpp:1310:                FLOGE("SAR value:%d, dar:%f, report_width:%f, report_height:%f", value, dar, report_width, report_height);
videopassthrough/TunerPassthroughV4L2Video.cpp:1318:        // FLOGE("afd raw data:%llx", (uint32_t)(*(uint32_t *)ev.event.mpeg_user_data.data));
videopassthrough/TunerPassthroughV4L2Video.cpp:1333:            FLOGE("TUNER_PASSTHROUGH_CB_EVENT_INDEX_VIDEO_VF_TYPE value:0x%x", value);
videopassthrough/TunerPassthroughV4L2Video.cpp:1338:            FLOGE("TUNER_PASSTHROUGH_CB_EVENT_INDEX_VIDEO_EOS value:0x%x", value);
videopassthrough/TunerPassthroughV4L2Video.cpp:1342:            FLOGE("not support video info type:%d", messageType);
videopassthrough/TunerPassthroughV4L2Video.cpp:1351:    FLOGI("playload:%" PRIX64, mVideoInfoValue.payload);
videopassthrough/TunerPassthroughV4L2Video.cpp:1356:    FLOGI("SetTrickSpeed scale:%f\n",scale);
videopassthrough/TunerPassthroughV4L2Video.cpp:1369:    FLOGI("SetRenderCallBackEventFlag flag:%" PRIX64, eventflag);
videopassthrough/TunerPassthroughV4L2Video.cpp:1387:    FLOGI("SetPassthroughParams type:%" PRId32 ", param1:%" PRId64 ", param2:%" PRId64 ", param3:%" PRId64,
videopassthrough/TunerPassthroughV4L2Video.cpp:1393:            FLOGI("AM_PASSTHROUGH_PARAM_MUTE:%" PRId64, param1);
videopassthrough/TunerPassthroughV4L2Video.cpp:1404:            FLOGI("AM_PASSTHROUGH_PARAM_SCREEN_COLOR:color:%" PRId64 ", mode:%" PRId64, param1, param2);
videopassthrough/TunerPassthroughV4L2Video.cpp:1415:            FLOGI("AM_PASSTHROUGH_PARAM_TRANSITION_MODE_BEFORE:%" PRId64, param1);
videopassthrough/TunerPassthroughV4L2Video.cpp:1425:            FLOGI("AM_PASSTHROUGH_PARAM_TRANSITION_MODE_AFTER:%" PRId64, param1);
videopassthrough/TunerPassthroughV4L2Video.cpp:1435:            FLOGI("AM_PASSTHROUGH_PARAM_TRANSITION_PREROLL_RATE:%" PRId64, param1);
videopassthrough/TunerPassthroughV4L2Video.cpp:1447:            FLOGI("AM_PASSTHROUGH_PARAM_TRANSITION_PREROLL_AV_TOLERANCE:%" PRId64, param1);
videopassthrough/TunerPassthroughV4L2Video.cpp:1459:            FLOGI("AM_PASSTHROUGH_PARAM_PLAYBACK_STATUS:%" PRId64, param1);
videopassthrough/TunerPassthroughV4L2Video.cpp:1469:            FLOGI("AM_PASSTHROUGH_PARAM_AVSYNC_PROPERTY_SYNCMODE:%" PRId64, param1);
videopassthrough/TunerPassthroughV4L2Video.cpp:1479:            FLOGI("AM_PASSTHROUGH_PARAM_INJECT_DONE_WAIT_EOS:%" PRId64, param1);
videopassthrough/TunerPassthroughV4L2Video.cpp:1492:            FLOGI("AM_PASSTHROUGH_PARAM_VIDEO_DROP_PTS:%" PRId64, param1);
videopassthrough/TunerPassthroughV4L2Video.cpp:1501:            FLOGI("setting not support in this version\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1521:    FLOGI("[KPI-FCC][%s/%d] workMode: %d", __FUNCTION__, __LINE__, workMode);
videopassthrough/TunerPassthroughV4L2Video.cpp:1524:        FLOGI("[%s/%d] workMode: %d", __FUNCTION__, __LINE__, workMode);
videopassthrough/TunerPassthroughV4L2Video.cpp:1527:        FLOGI("[%s/%d] workMode: %d, mRender is NULL", __FUNCTION__, __LINE__, workMode);
videopassthrough/TunerPassthroughV4L2Video.cpp:1533:        FLOGI("[%s/%d] workMode: %d, mVideoDecoder is NULL", __FUNCTION__, __LINE__, workMode);
videopassthrough/TunerPassthroughV4L2Video.cpp:1548:        FLOGE("[%s/%d] Parameter error!", __FUNCTION__, __LINE__);
videopassthrough/TunerPassthroughV4L2Video.cpp:1552:        FLOGE("[%s/%d] Invalid vpid:0x%x!", __FUNCTION__, __LINE__, mVideoCfg.vpid);
videopassthrough/TunerPassthroughV4L2Video.cpp:1571:        FLOGD("[%s/%d] start:0x%x end:0x%x free_percentage:%" PRId64 " free_len:%d total_size:%d\n",
videopassthrough/TunerPassthroughV4L2Video.cpp:1594:        FLOGE("[%s/%d] GetVideoBufferLevel failed! size:%d ret:0x%x\n", __FUNCTION__, __LINE__, mDecBufStatus.size, -ret);
videopassthrough/TunerPassthroughV4L2Video.cpp:1599:        FLOGE("need reset \n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1618:    FLOGI("EsDataHandler(%p) dmx:%p\n", this, mDemuxWrap->get());
videopassthrough/TunerPassthroughV4L2Video.cpp:1626:    FLOGI("~EsDataHandler\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1639:    FLOGI("EsDataHandler StartVideoFilter\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1646:    FLOGI("EsDataHandler StopVideoFilter\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1652:    ALOGI("EsDataHandler SetVideoLoopEnable:%d\n", mVideoLoop);
videopassthrough/TunerPassthroughV4L2Video.cpp:1657:    FLOGI("EsDataHandler PauseVideoFilter\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1671:            FLOGE("decoder not ready need retry\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1704:        FLOGI("EsDataHandler ReadBuffer Video Stop!!\n");
videopassthrough/TunerPassthroughV4L2Video.cpp:1720:        FLOGD("[%s/%d] stbuf_rp:0x%x", __FUNCTION__, __LINE__, stbuf_rp);
videopassthrough/TunerPassthroughV4L2Video.cpp:1750:        FLOGE("EsDataHandler Ammh_onMessageReceived handler has not started!\n");
videopassthrough/Android.mk:24:    $(TOP)/hardware/amlogic/gralloc \
videopassthrough/Android.mk:29:        liblog \
videopassthrough/Android.mk:33:GIT_VERSION="$(shell cd $(LOCAL_PATH);git log | grep commit -m 1 | cut -d' ' -f 2)"
videopassthrough/Android.mk:35:LAST_CHANGED="$(shell cd $(LOCAL_PATH);git log | grep Date -m 1)"
videopassthrough/Android.mk:37:BUILD_NAME=" $(shell echo ${LOGNAME})"
videopassthrough/Android.mk:41:COMMIT_PD="$(shell cd $(LOCAL_PATH);git log | grep PD# -m 1)"
videopassthrough/Android.mk:42:COMMIT_CHANGEID="$(shell cd $(LOCAL_PATH);git log | grep Change-Id -m 1)"
videopassthrough/Android.mk:66:    $(TOP)/vendor/amlogic/common/frameworks/services/systemcontrol \
videopassthrough/Android.mk:67:    $(TOP)/vendor/amlogic/common/frameworks/services/systemcontrol/PQ/include
videopassthrough/Android.mk:70:    vendor.amlogic.hardware.systemcontrol@1.0 \
videopassthrough/Android.mk:71:    vendor.amlogic.hardware.systemcontrol@1.1
videopassthrough/Android.mk:74:    $(TOP)/vendor/amlogic/common/frameworks/services/systemcontrol/aidl \
videopassthrough/Android.mk:75:    $(TOP)/vendor/amlogic/common/frameworks/services/systemcontrol/aidl/PQ/include \
videopassthrough/Android.mk:76:    $(TOP)/vendor/amlogic/common/interfaces/droidaudio/default/libdroidaudioclient
videopassthrough/Android.mk:80:    vendor.amlogic.hardware.systemcontrol-V1-ndk \
videopassthrough/VideoDecSpace.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthroughV4L2Video.h:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthroughBase.h:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerVideoDecWrapper.cpp:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerVideoDecWrapper.cpp:10:#define LOG_NDEBUG 0
videopassthrough/TunerVideoDecWrapper.cpp:11:#define LOG_TAG "TunerVideoDecWrapper"
videopassthrough/TunerVideoDecWrapper.cpp:12:#include <amlogic/am_gralloc_ext.h>
videopassthrough/TunerVideoDecWrapper.cpp:34:#define FLOGV(fmt,...) ALOGV("[No-%d] " fmt, mSyncPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerVideoDecWrapper.cpp:35:#define FLOGD(fmt,...) ALOGD("[No-%d] " fmt, mSyncPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerVideoDecWrapper.cpp:36:#define FLOGI(fmt,...) ALOGI("[No-%d] " fmt, mSyncPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerVideoDecWrapper.cpp:37:#define FLOGE(fmt,...) ALOGE("[No-%d] " fmt, mSyncPlayerInstanceNo, ##__VA_ARGS__)
videopassthrough/TunerVideoDecWrapper.cpp:77:    FLOGI("[%s/%d] %p mVideoTunnel:%d\n", __FUNCTION__, __LINE__, this, mVideoTunnel);
videopassthrough/TunerVideoDecWrapper.cpp:81:    FLOGI("[%s/%d] in %p\n", __FUNCTION__, __LINE__, this);
videopassthrough/TunerVideoDecWrapper.cpp:88:        FLOGV("release mVideoDecNonTunneLooper.clear\n");
videopassthrough/TunerVideoDecWrapper.cpp:90:    FLOGI("[%s/%d] done\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecWrapper.cpp:116:        FLOGV("[%s/%d] dqslot:%d %d\n", __FUNCTION__, __LINE__,
videopassthrough/TunerVideoDecWrapper.cpp:150:    FLOGI("[%s/%d] vpid:0x%x\n", __FUNCTION__, __LINE__, vpid);
videopassthrough/TunerVideoDecWrapper.cpp:161:    FLOGI("[KPI-FCC][%s/%d] mode:%d\n", __FUNCTION__, __LINE__, mode);
videopassthrough/TunerVideoDecWrapper.cpp:176:    ALOGI("%s end  \n",__FUNCTION__);
videopassthrough/TunerVideoDecWrapper.cpp:248:    //FLOGD("[%s] mState:%d metafd:%d dqslot:%d\n",__FUNCTION__, mState, metafd, dqslot);
videopassthrough/TunerVideoDecWrapper.cpp:254:        //FLOGD("DequeueSurfaceBuffer success dqslot:%d pictureId:%d metafd:%d\n", dqslot, pictureId, metafd);
videopassthrough/TunerVideoDecWrapper.cpp:261:    FLOGD("[%s] pictureId:%d slot:%d timestampUs%" PRId64 "\n",__FUNCTION__,pictureId, slot, timestampUs);
videopassthrough/TunerVideoDecWrapper.cpp:273:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecWrapper.cpp:277:            FLOGI("[%s/%d] %p work mode normal, start render: %p\n", __FUNCTION__, __LINE__, this, mRender.get());
videopassthrough/TunerVideoDecWrapper.cpp:281:        FLOGI("[%s/%d] %p work mode cache, not start render: %p\n", __FUNCTION__, __LINE__, this, mRender.get());
videopassthrough/TunerVideoDecWrapper.cpp:286:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecWrapper.cpp:292:    FLOGI("[%s/%d]", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecWrapper.cpp:302:    FLOGI("FlushOutputBuffer in OnFlush mQueuedSlot.size():%d",(int)mQueuedSlot.size());
videopassthrough/TunerVideoDecWrapper.cpp:309:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecWrapper.cpp:311:        FLOGE("mState is STOPPED!\n");
videopassthrough/TunerVideoDecWrapper.cpp:337:    FLOGI("[%s/%d]", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecWrapper.cpp:356:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecWrapper.cpp:358:        ALOGE("mState is STOPPED!\n");
videopassthrough/TunerVideoDecWrapper.cpp:394:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecWrapper.cpp:433:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecWrapper.cpp:442:    FLOGI("[%s/%d]\n", __FUNCTION__, __LINE__);
videopassthrough/TunerVideoDecWrapper.cpp:449:    FLOGD("TunerVideoDecWrapper::Ammh_onMessageReceived what:%d\n", msg->what());
videopassthrough/TunerVideoDecWrapper.cpp:494:                        //FLOGI("---->onOutputBufferDone Render frame mediaTimeUs:%lld mRendTimeUs:%lld nowTimeUs:%lld\n",mediaTimeUs, timestamp, AmmhLooper::GetNowUs());
videopassthrough/TunerVideoDecWrapper.cpp:496:                        //FLOGI("---->onOutputBufferDone Render first frame mediaTimeUs:%lld mRendTimeUs:%lld nowTimeUs:%lld\n",mediaTimeUs, timestamp, AmmhLooper::GetNowUs());
videopassthrough/TunerVideoDecWrapper.cpp:508:                    FLOGI("---->onOutputBufferDone Drop frame mediaTimeUs:%" PRId64 " mRendTimeUs:%" PRId64 " nowTimeUs:%" PRId64 "\n",mediaTimeUs, timestamp, AmmhLooper::GetNowUs());
videopassthrough/TunerVideoDecWrapper.cpp:511:                FLOGE("kWhatQueueOutPutNotify NoFind,timestampNs(%" PRId64 ") index(%d) BufferSlot.size(%d)\n",timestamp,pictureId,(int)mOutputBufferSlot.size());
videopassthrough/TunerVideoDecWrapper.cpp:519:                FLOGD("Ammh_onMessageReceived kWhatStop mState:%d return\n", mState);
videopassthrough/TunerVideoDecWrapper.cpp:531:            FLOGD("Ammh_onMessageReceived kWhatFlush vpid:%d\n",mVPid);
videopassthrough/TunerVideoDecWrapper.cpp:536:               FLOGD("Ammh_onMessageReceived kWhatFlush mState > STARTED\n");
videopassthrough/TunerVideoDecWrapper.cpp:547:            FLOGD("Ammh_onMessageReceived kWhatFlushSeekTrickMode vpid:%d\n",mVPid);
videopassthrough/TunerVideoDecWrapper.cpp:580:    FLOGI("mVPid:0x%x vFmt:%d mDisplayMode:%d", pram.vpid, pram.vFmt, mDisplayMode);
videopassthrough/TunerVideoDecWrapper.cpp:595:       FLOGE("TunerVideoDecWrapper::Write return not mInit\n");
videopassthrough/TunerVideoDecWrapper.cpp:600:        FLOGE("TunerVideoDecWrapper::Write return not STARTED mState:%d\n",mState);
videopassthrough/TunerVideoDecWrapper.cpp:625:        ALOGE(" mMedia == NULL");
videopassthrough/TunerVideoDecWrapper.cpp:637:    FLOGD("onOutputFormatChanged bufnum %d, width %d, height %d,mDqWidth:%d,mDqHeight:%d\n",
videopassthrough/TunerVideoDecWrapper.cpp:640:        ALOGE(" mMedia == NULL");
videopassthrough/TunerVideoDecWrapper.cpp:669:            FLOGD("createOutputBuffer slot:%d i:%d\n", slot,i);
videopassthrough/TunerVideoDecWrapper.cpp:678:            FLOGD("queueOutputBuffer slot:%d i:%d \n", slot,i);
videopassthrough/TunerVideoDecWrapper.cpp:682:    FLOGI("onOutputFormatChanged ok this %p>>>>>\n", this);
videopassthrough/TunerVideoDecWrapper.cpp:724:            FLOGI("onInputBufferDone can not find bitstreamId %d\n", bitstreamId);
videopassthrough/TunerVideoDecWrapper.cpp:771:        FLOGI("input parameter was NULL, SetTraceInfo failed! \n");
videopassthrough/TunerVideoDecWrapper.cpp:778:    FLOGI("onUpdateDecInfo info %p, size %d\n", info, isize);
videopassthrough/TunerVideoDecWrapper.cpp:789:    FLOGD("onResetDone\n");
videopassthrough/TunerVideoDecWrapper.cpp:797:    FLOGV("onEvent event %d, param %p, paramsize %d\n", event, param, paramsize);
videopassthrough/TunerVideoDecWrapper.cpp:810:            FLOGV("VIDEO FORMAT CHANGED [%d x %d] @%d fps\n",
videopassthrough/TunerVideoDecWrapper.cpp:842:    FLOGV("VideodecSurfaceWrapper::registerCallback \n");
videopassthrough/TunerPassthrough.h:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthroughUtils.h:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthroughProperty.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthroughProperty.cpp:29:        ALOGE("input parameter was NULL, VideoPassThrough_getPropertyInt failed!");
videopassthrough/TunerPassthroughProperty.cpp:54:        ALOGE("input parameter was NULL, VideoPassThrough_propertyGet failed!");
videopassthrough/TunerPassthroughProperty.cpp:79:        ALOGE("input parameter was NULL, VideoPassThrough_propertySet failed!");
videopassthrough/TunerPassthroughVideo.h:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthroughProperty.h:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videopassthrough/TunerVideoDecWrapper.h:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerVideoDecV4L2Wrapper.h:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthroughStbTrace.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthroughStbTrace.cpp:10:#define LOG_TAG "TIME_TRACE"
videopassthrough/TunerPassthroughStbTrace.cpp:17:    // ALOGI("init_stb_trace\n");
videopassthrough/TunerPassthroughStbTrace.cpp:19:        ALOGE("input parameter was NULL, init_stb_trace failed!\n");
videopassthrough/TunerPassthroughStbTrace.cpp:28:        ALOGE("input parameter was NULL, stb_trace_dbg failed!");
videopassthrough/TunerPassthroughStbTrace.cpp:33:    ALOGI("[%s][%d] step: No-%d %s, time: %u, consume: %u \n", trace_info->module_name, key_step, trace_info->player_instansNo, step_str, cur_step_time, interval);
videopassthrough/TunerPassthroughRenderer.cpp:2: * Copyright (c) 2021 Amlogic, Inc. All rights reserved.
videopassthrough/TunerPassthroughRenderer.cpp:9:#define LOG_NDEBUG 0
videopassthrough/TunerPassthroughRenderer.cpp:10:#define LOG_TAG "TunerPassthroughRenderer"
videopassthrough/TunerPassthroughRenderer.cpp:24:#define FLOGV(number,fmt,...) ALOGV("[No-%d] " fmt, number, ##__VA_ARGS__)
videopassthrough/TunerPassthroughRenderer.cpp:25:#define FLOGD(number,fmt,...) ALOGD("[No-%d] " fmt, number, ##__VA_ARGS__)
videopassthrough/TunerPassthroughRenderer.cpp:26:#define FLOGI(number,fmt,...) ALOGI("[No-%d] " fmt, number, ##__VA_ARGS__)
videopassthrough/TunerPassthroughRenderer.cpp:27:#define FLOGE(number,fmt,...) ALOGE("[No-%d] " fmt, number, ##__VA_ARGS__)
videopassthrough/TunerPassthroughRenderer.cpp:34:    FLOGD(mSyncPlayerInstanceNo, "Create TunerPassthroughRenderer\n");
videopassthrough/TunerPassthroughRenderer.cpp:44:    FLOGD(mSyncPlayerInstanceNo, "~TunerPassthroughRenderer ok\n");
videopassthrough/TunerPassthroughRenderer.cpp:53:        FLOGE(mSyncPlayerInstanceNo, "can not get TunnerPassthoughRenderer, init error\n");
videopassthrough/TunerPassthroughRenderer.cpp:65:            FLOGE(mSyncPlayerInstanceNo, "open /dev/v4lvideo failed!\n");
videopassthrough/TunerPassthroughRenderer.cpp:69:    FLOGE(mSyncPlayerInstanceNo, "alloc_v4l2video_file ==(%d).", mV4L2Fd);
videopassthrough/TunerPassthroughRenderer.cpp:73:        FLOGE(mSyncPlayerInstanceNo, "call V4L2 ioctl failed (%d).", err);
videopassthrough/TunerPassthroughRenderer.cpp:78:        FLOGE(mSyncPlayerInstanceNo, "V4LVIDEO_IOCTL_ALLOC_FD return invalid fd (%d).", fd);
videopassthrough/TunerPassthroughRenderer.cpp:89:        FLOGV(mSyncPlayerInstanceNo, "cannot open /dev/uvm (%d:%s)", errno, strerror(errno));
videopassthrough/TunerPassthroughRenderer.cpp:114:        FLOGE(mSyncPlayerInstanceNo, "call uvm ioctl failed (%d).", ret);
videopassthrough/TunerPassthroughRenderer.cpp:119:    FLOGD(mSyncPlayerInstanceNo, "ioctl uvm sharefd:%d\n", shared_fd);
videopassthrough/TunerPassthroughRenderer.cpp:126:    FLOGD(mSyncPlayerInstanceNo, "%s\n", __FUNCTION__);
videopassthrough/TunerPassthroughRenderer.cpp:135:    FLOGD(mSyncPlayerInstanceNo, "%s\n", __FUNCTION__);
videopassthrough/TunerPassthroughRenderer.cpp:164:    //ALOGD("%s metafd:%d timestampNs:%lld\n", __FUNCTION__, metafd, timestampNs);
Android.bp.in:7:    // all of the 'license_kinds' from "vendor_amlogic_common_license"
Android.bp.in:15:    default_applicable_licenses: ["vendor_amlogic_common_license"],
Android.bp.in:20:    pkgPath: "android/soong/vendor/amlogic/mediahal_sdk",
dhp_daemon/aml_dhp_library.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
dhp_daemon/aml_dhp_library.h:33:            LOG_ERROR("Function %s not found in library\n", #func); \
dhp_daemon/aml_dhp_daemon.c:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
dhp_daemon/aml_dhp_daemon.c:79: * that the application should stop running. It logs the received signal for
dhp_daemon/aml_dhp_daemon.c:86:        LOG_INFO("Received termination signal (%d), exiting...\n", sig);
dhp_daemon/aml_dhp_daemon.c:94:    LOG_TRACE("%s: DBUF mmap, fd:%d, len:%u, prot:%x, flags:%x, off:%u\n",
dhp_daemon/aml_dhp_daemon.c:99:        LOG_ERROR("dmabuf mmap failed: fd=%d len=%u offset=%u\n", fd, len, offset);
dhp_daemon/aml_dhp_daemon.c:107:    LOG_TRACE("%s: DBUF munmap, vaddr:%p, len:%u\n",
dhp_daemon/aml_dhp_daemon.c:111:        LOG_ERROR("dmabuf munmap failed: addr=%p len=%u\n", vaddr, len);
dhp_daemon/aml_dhp_daemon.c:119:    LOG_TRACE("%s: DBUF sync, flags:%x, len:%u\n",
dhp_daemon/aml_dhp_daemon.c:123:        LOG_ERROR("dmabuf sync failed: fd=%d\n", fd);
dhp_daemon/aml_dhp_daemon.c:136:    LOG_TRACE("%s: Page mmap, PFN:%lx, uncached:%u\n",
dhp_daemon/aml_dhp_daemon.c:140:        LOG_ERROR("page mmap failed: PFN=%x\n", pfn);
dhp_daemon/aml_dhp_daemon.c:157:    LOG_TRACE("%s: MEM mmap, addr:%llx, size:%u, uncached:%u\n",
dhp_daemon/aml_dhp_daemon.c:161:        LOG_ERROR("mem mmap failed: addr=%lx size=%u\n", addr, size);
dhp_daemon/aml_dhp_daemon.c:178:    LOG_TRACE("%s: MEM sync, addr:%llx, size:%u, flags:%x\n",
dhp_daemon/aml_dhp_daemon.c:182:        LOG_ERROR("mem sync failed: addr=%lx size=%u flags=%x\n", addr, size, flags);
dhp_daemon/aml_dhp_daemon.c:200:    LOG_TRACE("%s: SGT mmap, PFNs:%u, uncached:%u\n",
dhp_daemon/aml_dhp_daemon.c:204:        LOG_ERROR("SGT mmap failed: PFNs=%u\n", num);
dhp_daemon/aml_dhp_daemon.c:221:    LOG_TRACE("%s: SGT sync, PFNs:%u, flags:%x\n", __func__, num, flags);
dhp_daemon/aml_dhp_daemon.c:224:        LOG_ERROR("SGT sync failed: PFNs=%u flags=%x\n", num, flags);
dhp_daemon/aml_dhp_daemon.c:230:    LOG_TRACE("%s: MEM munmmap, vaddr:%p, len:%u\n",
dhp_daemon/aml_dhp_daemon.c:234:        LOG_ERROR("munmap failed: addr=%p len=%u\n", vaddr, len);
dhp_daemon/aml_dhp_daemon.c:245: * structure for polling events like data input, errors, and urgent data. It logs
dhp_daemon/aml_dhp_daemon.c:254:        LOG_ERROR("Failed to open device: %s\n", device_path);
dhp_daemon/aml_dhp_daemon.c:260:    LOG_VERBOSE("Device opened successfully: %s\n", device_path);
dhp_daemon/aml_dhp_daemon.c:270: * This function closes the file descriptor associated with the device and logs
dhp_daemon/aml_dhp_daemon.c:277:        LOG_VERBOSE("Device closed (fd: %d).\n", dev->fd);
dhp_daemon/aml_dhp_daemon.c:285:        LOG_ERROR("Invalid device (fd: %d).\n", dev ? dev->fd : -1);
dhp_daemon/aml_dhp_daemon.c:290:        LOG_ERROR("IOCTL operation failed: fd=%d, request=%d\n", dev->fd, request);
dhp_daemon/aml_dhp_daemon.c:303: * handling the received data, logging timing information, and closing the file descriptor.
dhp_daemon/aml_dhp_daemon.c:316:        LOG_ERROR("%s: IOCTL_DHP_GET_FD failed, unable to get FD\n", __func__);
dhp_daemon/aml_dhp_daemon.c:320:    // Process the fetched data based on its type and log the data type
dhp_daemon/aml_dhp_daemon.c:322:        LOG_ERROR("%s: Failed to handle data, type: %d\n", __func__, io.type);
dhp_daemon/aml_dhp_daemon.c:324:        LOG_INFO("%s: Successfully handled data, type: %d\n", __func__, io.type);
dhp_daemon/aml_dhp_daemon.c:329:    LOG_VERBOSE("%s: Total time elapsed: %lu ms\n",
dhp_daemon/aml_dhp_daemon.c:335:    LOG_DEBUG("%s: Event handling complete\n", __func__);
dhp_daemon/aml_dhp_daemon.c:357:        LOG_VERBOSE("Poll timed out.\n");
dhp_daemon/aml_dhp_daemon.c:394: * dhp_server_start() - Starts the DHP server logic by adding the poll task to the thread pool.
dhp_daemon/aml_dhp_daemon.c:398: * This function initializes the server by scheduling the polling logic (`dhp_poll`) as a task
dhp_daemon/aml_dhp_daemon.c:399: * in the thread pool. This allows the event handling logic to run continuously in the background.
dhp_daemon/aml_dhp_daemon.c:493:    printf("  -d | --debug       Set log debug level\n");
dhp_daemon/aml_dhp_daemon.c:533:            LOG_INFO("Set log level: %d\n", debugLevel);
dhp_daemon/aml_dhp_daemon.c:539:            LOG_INFO("Set dump data mode: %x\n", dump_data);
dhp_daemon/aml_dhp_daemon.c:543:            LOG_INFO("Set target index: %u\n", g_idx);
dhp_daemon/aml_dhp_daemon.c:553:    LOG_INFO("Using device: %s\n", DEVICE_FILE);
dhp_daemon/aml_dhp_daemon.c:582:            LOG_INFO("Key input detected: %d (quit: 'q')\n", chr);
dhp_daemon/aml_dhp_daemon.c:584:                LOG_INFO("Quit command received. Exiting...\n");
dhp_daemon/aml_dhp_library.c:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
dhp_daemon/aml_dhp_library.c:24:        LOG_ERROR("Invalid library config\n");
dhp_daemon/aml_dhp_library.c:29:        LOG_ERROR("Invalid library config: name or lib_path is NULL\n");
dhp_daemon/aml_dhp_library.c:34:        LOG_ERROR("Invalid library config: symbol_count or symbols is NULL\n");
dhp_daemon/aml_dhp_library.c:39:        LOG_ERROR("Invalid library type: %d\n", config->type);
dhp_daemon/aml_dhp_library.c:45:        LOG_ERROR("Failed to allocate memory for library entry\n");
dhp_daemon/aml_dhp_library.c:57:    LOG_INFO("Library %s registered\n", entry->config->name);
dhp_daemon/aml_dhp_library.c:76:            LOG_INFO("Library %s unregistered\n", entry->config->name);
dhp_daemon/aml_dhp_library.c:82:    LOG_WARNING("Library of type %d not found for unregistration\n", type);
dhp_daemon/aml_dhp_library.c:93:        LOG_ERROR("Invalid library entry\n");
dhp_daemon/aml_dhp_library.c:99:        LOG_ERROR("Invalid library config\n");
dhp_daemon/aml_dhp_library.c:105:        LOG_ERROR("Failed to load library %s: %s\n", entry->config->lib_path, dlerror());
dhp_daemon/aml_dhp_library.c:116:            LOG_ERROR("Failed to resolve symbol %s: %s\n", symbol_name, dlsym_error);
dhp_daemon/aml_dhp_library.c:124:        LOG_INFO("Successfully resolved symbol %s at %p for library %s\n",
dhp_daemon/aml_dhp_library.c:138:        LOG_ERROR("Invalid library manager\n");
dhp_daemon/aml_dhp_library.c:149:            LOG_INFO("Successfully loaded and resolved all symbols for %s\n", entry->config->name);
dhp_daemon/aml_dhp_library.c:151:            LOG_ERROR("Failed to resolve symbols for %s\n", entry->config->name);
dhp_daemon/aml_dhp_library.c:165:        LOG_ERROR("Invalid library manager\n");
dhp_daemon/aml_dhp_library.c:174:        LOG_INFO("Library %s unloaded\n", entry->config->name);
dhp_daemon/aml_dhp_library.c:180:    LOG_INFO("Unregistered all libraries\n");
dhp_daemon/aml_dhp_common.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
dhp_daemon/aml_dhp_common.h:91: * Logging macros for each debug level.
dhp_daemon/aml_dhp_common.h:93: * These macros wrap the debug_printf function, providing an easy way to log messages
dhp_daemon/aml_dhp_common.h:97:/* Logs messages at the critical level. */
dhp_daemon/aml_dhp_common.h:98:#define LOG_CRITICAL(...)   debug_printf(DEBUG_LEVEL_CRITICAL, __VA_ARGS__)
dhp_daemon/aml_dhp_common.h:100:/* Logs messages at the error level. */
dhp_daemon/aml_dhp_common.h:101:#define LOG_ERROR(...)      debug_printf(DEBUG_LEVEL_ERROR, __VA_ARGS__)
dhp_daemon/aml_dhp_common.h:103:/* Logs messages at the warning level. */
dhp_daemon/aml_dhp_common.h:104:#define LOG_WARNING(...)    debug_printf(DEBUG_LEVEL_WARNING, __VA_ARGS__)
dhp_daemon/aml_dhp_common.h:106:/* Logs messages at the notice level (less severe than warnings). */
dhp_daemon/aml_dhp_common.h:107:#define LOG_NOTICE(...)     debug_printf(DEBUG_LEVEL_NOTICE, __VA_ARGS__)
dhp_daemon/aml_dhp_common.h:109:/* Logs informational messages (typically high-level events). */
dhp_daemon/aml_dhp_common.h:110:#define LOG_INFO(...)       debug_printf(DEBUG_LEVEL_INFO, __VA_ARGS__)
dhp_daemon/aml_dhp_common.h:112:/* Logs verbose messages for detailed system behavior. */
dhp_daemon/aml_dhp_common.h:113:#define LOG_VERBOSE(...)    debug_printf(DEBUG_LEVEL_VERBOSE, __VA_ARGS__)
dhp_daemon/aml_dhp_common.h:115:/* Logs messages useful for developers (debugging). */
dhp_daemon/aml_dhp_common.h:116:#define LOG_DEBUG(...)      debug_printf(DEBUG_LEVEL_DEBUG, __VA_ARGS__)
dhp_daemon/aml_dhp_common.h:118:/* Logs trace-level messages, ideal for tracking detailed execution flow. */
dhp_daemon/aml_dhp_common.h:119:#define LOG_TRACE(...)      debug_printf(DEBUG_LEVEL_TRACE, __VA_ARGS__)
dhp_daemon/aml_dhp_common.h:164: * LOG_XXX() - Macro to log an XXX message.
dhp_daemon/aml_dhp_common.h:166: * A wrapper around debug_printf() that simplifies logging XXX-level messages.
dhp_daemon/aml_common_list.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
dhp_daemon/aml_symbol_define.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
dhp_daemon/aml_symbol_define.h:32:            LOG_WARNING("Failed to register %s library\n",     \
dhp_daemon/prebuild/include/avbc_interface.h:2: * Copyright (c) 2016 Amlogic, Inc. All rights reserved.
dhp_daemon/aml_image_info.h:3: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
dhp_daemon/aml_image_info.h:12:/* AVBC: Amlogic Video Buffer Compression Data. */
dhp_daemon/aml_dhp_core.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
dhp_daemon/aml_dhp_core.c:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
dhp_daemon/aml_dhp_core.c:65:    LOG_INFO("%s, %s, width: %d, height: %d, wstride: %d, hstride: %d size:%u\n",
dhp_daemon/aml_dhp_core.c:92:    LOG_DEBUG("AVBCD handle: wxh: %dx%d, dep: %d, pts:%u\n",
dhp_daemon/aml_dhp_core.c:118:        LOG_ERROR("IOCTL_DHP_MMAP failed, addr:%llx\n", iomem.mem.addr);
dhp_daemon/aml_dhp_core.c:126:    LOG_DEBUG("Mapping Header buffer:%p, size:%u\n", header, avbcd->hsize);
dhp_daemon/aml_dhp_core.c:127:    LOG_DEBUG("Mapping YUV buffer:%p, size:%u\n", dst_yuv, dst_size);
dhp_daemon/aml_dhp_core.c:153:    LOG_DEBUG("SRC-parms: fmt:%s, dep:%u, uncache:%u, Rect[x:%u,y:%u,w:%u,h:%u]\n",
dhp_daemon/aml_dhp_core.c:156:    LOG_DEBUG("DST-parms: fmt:%s, dep:%u, uncache:%u, Rect[x:%u,y:%u,w:%u,h:%u]\n",
dhp_daemon/aml_dhp_core.c:159:    LOG_DEBUG("DISP-parms: fmt:%s, dep:%u, uncache:%u, Rect[x:%u,y:%u,w:%u,h:%u]\n",
dhp_daemon/aml_dhp_core.c:171:        LOG_ERROR("AVBC decoding fail.\n");
dhp_daemon/aml_dhp_core.c:175:    LOG_VERBOSE("%s, Total elapse: %lu ms.\n",
dhp_daemon/aml_dhp_types.h:2: * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
dhp_daemon/aml_dhp_types.h:38: * AML_DHP_TYPE_AVBCD: Represents amlogic video buffer compression decoding tasks.
dhp_daemon/aml_dhp_types.h:39: * AML_DHP_TYPE_AVBCE: Represents amlogic video buffer compression encoding tasks.
dhp_daemon/aml_dhp_common.c:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
dhp_daemon/aml_dhp_common.c:201:        LOG_ERROR("Task function is NULL\n");
dhp_daemon/aml_dhp_common.c:259:        LOG_ERROR("Invalid file handle.\n");
dhp_daemon/aml_dhp_daemon.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
dhp_daemon/aml_dhp_daemon.h:90: * process's virtual address space using an IOCTL call. It logs an error if the IOCTL
dhp_daemon/aml_dhp_daemon.h:177: * IOCTL operation on the device. It logs errors if the device is not valid or if
dhp_daemon/aml_dhp_if.h:2: * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
dhp_daemon/sepolicy/sepolicy.mk:7:BOARD_SEPOLICY_DIRS += vendor/amlogic/common/mediahal_sdk/sepolicy/dhp_daemon
OTT-49080_mediasync_release.diff:2:Author: “sining.huang” <sining.huang@amlogic.com>
OTT-49080_mediasync_release.diff:13:    optimize the logic of startplay offset
OTT-49080_mediasync_release.diff:19:    Signed-off-by: “sining.huang” <sining.huang@amlogic.com>
OTT-49080_mediasync_release.diff:30:     MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"fccenable:%d, a-cache:[%d ms, %" PRId64 " ms], "
OTT-45403_mediasync_alsaready.diff:10:     updateLogHead();
OTT-45403_mediasync_alsaready.diff:25:     //    MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"pa_diff %" PRId64 " ms.", pa_diff/90);
OTT-45403_mediasync_alsaready.diff:31:         MS_LOGI(MSYNC_DEBUG_LEVEL_0,mLogHead,"Alsa not ready, normal output.");
OTT-45403_mediasync_alsaready.diff:45:     void updateLogHead(int optional = 0);
Utils/AmmhMessage.cpp:17:#define LOG_TAG "AmmhMessage"
Utils/AmmhMessage.cpp:18://#define LOG_NDEBUG 0
Utils/AmmhMessage.cpp:37:        ALOGE("trying to post a duplicate reply");
Utils/AmmhMessage.cpp:41:        ALOGE("setReply return no memory");
Utils/AmmhMessage.cpp:135:        ALOGI("called findItemIx %zu times (for len=%.1f i=%.1f/%.1f mem) dup %zu times (for len=%.1f)",
Utils/AmmhMessage.cpp:379:        ALOGW("failed to deliver message as target handler %d is gone.", mTarget);
Utils/AmmhMessage.cpp:389:        ALOGW("failed to post message as target looper for handler %d is gone.", mTarget);
Utils/AmmhMessage.cpp:400:        ALOGW("failed to post message as target looper for handler %d is gone.", mTarget);
Utils/AmmhMessage.cpp:406:        ALOGE("failed to create reply token");
Utils/AmmhMessage.cpp:416:        ALOGW("failed to post reply to a NULL token");
Utils/AmmhMessage.cpp:421:        ALOGW("failed to post reply as target looper is gone.");
Utils/AmmhMessage.cpp:592:                ALOGE("Unknown type %d", item.mType);
Utils/AmmhProperties.c:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
Utils/AmmhHandler.cpp:17://#define LOG_NDEBUG 0
Utils/AmmhHandler.cpp:18:#define LOG_TAG "AmmhHandler"
Utils/AmmhThread.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
Utils/AmmhThread.cpp:10:#define LOG_NDEBUG 0
Utils/AmmhThread.cpp:11:#define LOG_TAG "libutils.threads"
Utils/AmmhThread.cpp:40:        /*ALOGE("androidCreateRawThreadEtc failed (entry=%p, res=%d, %s)\n",
Utils/AmmhThread.cpp:80:    //LOG_ALWAYS_FATAL_IF(name == nullptr, "thread name not provided to AmmhThread::run");
Utils/AmmhThread.cpp:194:        /*ALOGW(
Utils/AmmhThread.cpp:218:        /*ALOGW(
Utils/AmmhUnicode.cpp:17:#define LOG_TAG "unicode"
Utils/AmmhUnicode.cpp:202:        LOG_ALWAYS_FATAL_IF(dst_len < len, "%zu < %zu", dst_len, len);
Utils/AmmhUnicode.cpp:209:    LOG_ALWAYS_FATAL_IF(dst_len < 1, "dst_len < 1: %zu < 1", dst_len);
Utils/AmmhUnicode.cpp:384:        LOG_ALWAYS_FATAL_IF(dst_len < len, "%zu < %zu", dst_len, len);
Utils/AmmhUnicode.cpp:391:    LOG_ALWAYS_FATAL_IF(dst_len < 1, "%zu < 1", dst_len);
Utils/AmmhUnicode.cpp:585:                LOG_ALWAYS_FATAL("Attempt to overread computing length of utf8 string");
Utils/AmmhUnicode.cpp:612:    LOG_ALWAYS_FATAL_IF(u16len == 0 || u16len > SSIZE_MAX, "u16len is %zu", u16len);
Utils/AmmhUnicode.cpp:626:    LOG_ALWAYS_FATAL_IF(dstLen > SSIZE_MAX, "dstLen is %zu", dstLen);
Utils/AmmhSharedBuffer.cpp:17:#define LOG_TAG "sharedbuffer"
Utils/AmmhSharedBuffer.cpp:30:    LOG_ALWAYS_FATAL_IF((size >= (SIZE_MAX - sizeof(AmmhSharedBuffer))),
Utils/AmmhSharedBuffer.cpp:70:        LOG_ALWAYS_FATAL_IF((newSize >= (SIZE_MAX - sizeof(AmmhSharedBuffer))),
Utils/AmmhString16.cpp:87:    ALOG_ASSERT(buf, "Unable to allocate shared buffer");
Utils/AmmhString16.cpp:180:        LOG_ALWAYS_FATAL("Not implemented");
Utils/Android.bp:60:        "liblog",
Utils/Android.bp:85:        "liblog",
Utils/Android.bp:110:        "liblog",
Utils/common/avformat.cpp:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
Utils/common/avformat.cpp:12:#include <utils/Log.h>
Utils/common/avformat.cpp:90:                ALOGI("[INFO] Module:%s MaximumResolution:%s\n",
Utils/common/avformat.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
Utils/AmmhLooper.cpp:17://#define LOG_NDEBUG 0
Utils/AmmhLooper.cpp:18:#define LOG_TAG "AmmhLooper"
Utils/AmmhLooper.cpp:236:            ALOGE("awaitResponse mLock");
Utils/AmmhRefBase.cpp:17:#define LOG_TAG "AmmhRefBase"
Utils/AmmhRefBase.cpp:18:// #define LOG_NDEBUG 0
Utils/AmmhRefBase.cpp:42:// log all reference counting operations
Utils/AmmhRefBase.cpp:178:            ALOGE("Strong references remain:");
Utils/AmmhRefBase.cpp:182:                ALOGD("\t%c ID %p (ref %d):", inc, refs->id, refs->ref);
Utils/AmmhRefBase.cpp:184:                refs->stack.log(LOG_TAG);
Utils/AmmhRefBase.cpp:192:            ALOGE("Weak references remain!");
Utils/AmmhRefBase.cpp:196:                ALOGD("\t%c ID %p (ref %d):", inc, refs->id, refs->ref);
Utils/AmmhRefBase.cpp:198:                refs->stack.log(LOG_TAG);
Utils/AmmhRefBase.cpp:204:            ALOGE("above errors at:");
Utils/AmmhRefBase.cpp:205:            CallStack stack(LOG_TAG);
Utils/AmmhRefBase.cpp:210:        //ALOGD_IF(mTrackEnabled,
Utils/AmmhRefBase.cpp:216:        //ALOGD_IF(mTrackEnabled,
Utils/AmmhRefBase.cpp:226:        //ALOGD_IF(mTrackEnabled,
Utils/AmmhRefBase.cpp:281:                ALOGD("STACK TRACE for %p saved in %s", this, name);
Utils/AmmhRefBase.cpp:283:            else ALOGE("FAILED TO PRINT STACK TRACE for %p in %s: %s", this,
Utils/AmmhRefBase.cpp:335:            ALOGE("RefBase: removing id %p on RefBase %p"
Utils/AmmhRefBase.cpp:342:                ALOGD("\t%c ID %p (ref %d):", inc, ref->id, ref->ref);
Utils/AmmhRefBase.cpp:346:            CallStack stack(LOG_TAG);
Utils/AmmhRefBase.cpp:402:    ALOGD("incStrong of %p from %p: cnt=%d\n", this, id, c);
Utils/AmmhRefBase.cpp:419:    ALOGD("decStrong of %p from %p: cnt=%d\n", this, id, c);
Utils/AmmhRefBase.cpp:454:    ALOGD("forceIncStrong of %p from %p: cnt=%d\n", this, id, c);
Utils/AmmhRefBase.cpp:509:            // Thus we no longer do anything here.  We log this case, since it
Utils/AmmhRefBase.cpp:513:            // ALOGV("Freeing refs %p of old AmmhRefBase %p\n", this, impl->mBase);
Utils/AmmhRefBase.cpp:602:    ALOGD("attemptIncStrong of %p from %p: cnt=%d\n", this, id, curCount);
Utils/VectorImpl.cpp:17:#define LOG_TAG "Vector"
Utils/VectorImpl.cpp:56:    ALOGW_IF(mCount,
Utils/VectorImpl.cpp:65:    LOG_ALWAYS_FATAL_IF(mItemSize != rhs.mItemSize,
Utils/VectorImpl.cpp:93:            LOG_ALWAYS_FATAL_IF(editable == NULL);
Utils/VectorImpl.cpp:255:    ALOG_ASSERT(index<size(),
Utils/VectorImpl.cpp:278:    ALOG_ASSERT((index+count)<=size(),
Utils/VectorImpl.cpp:302:    ALOG_ASSERT(index<capacity(),
Utils/VectorImpl.cpp:317:    ALOG_ASSERT(index<capacity(),
Utils/VectorImpl.cpp:339:    LOG_ALWAYS_FATAL_IF(!AMMH_SAFE_MUL(&new_allocation_size, new_capacity, mItemSize));
Utils/VectorImpl.cpp:375://    ALOGV("_grow(this=%p, where=%d, amount=%d) count=%d, capacity=%d",
Utils/VectorImpl.cpp:378:    ALOG_ASSERT(where <= mCount,
Utils/VectorImpl.cpp:383:    LOG_ALWAYS_FATAL_IF(!AMMH_SAFE_ADD(&new_size, mCount, amount), "new_size overflow");
Utils/VectorImpl.cpp:394:        LOG_ALWAYS_FATAL_IF(!AMMH_SAFE_ADD(&new_capacity, new_size, (new_size / 2)),
Utils/VectorImpl.cpp:396:        LOG_ALWAYS_FATAL_IF(!AMMH_SAFE_ADD(&new_capacity, new_capacity, static_cast<size_t>(1u)),
Utils/VectorImpl.cpp:401:        LOG_ALWAYS_FATAL_IF(!AMMH_SAFE_MUL(&new_alloc_size, new_capacity, mItemSize),
Utils/VectorImpl.cpp:404://        ALOGV("grow vector %p, new_capacity=%d", this, (int)new_capacity);
Utils/VectorImpl.cpp:453://    ALOGV("_shrink(this=%p, where=%d, amount=%d) count=%d, capacity=%d",
Utils/VectorImpl.cpp:456:    ALOG_ASSERT(where + amount <= mCount,
Utils/VectorImpl.cpp:461:    LOG_ALWAYS_FATAL_IF(!AMMH_SAFE_SUB(&new_size, mCount, amount));
Utils/AmmhStrongPointer.cpp:17:#define LOG_TAG "Ammh_sp"
Utils/AmmhStrongPointer.cpp:21:void sp_report_race() { LOG_ALWAYS_FATAL("Ammh_sp<> assignment detected data race"); }
Utils/AmmhFileSystemIo.cpp:2: * Copyright (c) 2020 Amlogic, Inc. All rights reserved.
Utils/AmmhFileSystemIo.cpp:10:#define LOG_TAG "AmTsSystemControl"
Utils/AmmhFileSystemIo.cpp:11:#include <utils/Log.h>
Utils/AmmhFileSystemIo.cpp:28:    ALOGI("ammh_filesystem_create FileSystemCreateCount:%d\n",aMFileSystemCreateCount);
Utils/AmmhFileSystemIo.cpp:83:        ALOGI("ammh_filesystem_release mSystemControl == NULL FileSystemCreateCount:%d\n",aMFileSystemCreateCount);
Utils/AmmhFileSystemIo.cpp:87:    ALOGI("ammh_filesystem_release FileSystemCreateCount:%d\n",aMFileSystemCreateCount);
Utils/AmmhFileSystemIo.cpp:102:    ALOGV("open file \"%s\"\n", name);
Utils/AmmhFileSystemIo.cpp:107:        ALOGV("cannot open file \"%s\"", name);
Utils/AmmhFileSystemIo.cpp:116:        ALOGV("read failed file:\"%s\" cmd:\"%s\" error:\"%s\"\n", name, cmd, strerror(errno));
Utils/AmmhFileSystemIo.cpp:121:        ALOGV("read file:\"%s\" cmd:\"%s\" ok \n", name, cmd);
Utils/AmmhFileSystemIo.cpp:130:    ALOGV("open file \"%s\"\n", name);
Utils/AmmhFileSystemIo.cpp:135:        ALOGV("cannot open file \"%s\"", name);
Utils/AmmhFileSystemIo.cpp:144:        ALOGV("write failed file:\"%s\" cmd:\"%s\" error:\"%s\"\n", name, cmd, strerror(errno));
Utils/AmmhFileSystemIo.cpp:149:        ALOGV("write file:\"%s\" cmd:\"%s\" ok \n", name, cmd);
Utils/include/AmmhLog.h:17:#ifndef _AMMH_LOG_H
Utils/include/AmmhLog.h:18:#define _AMMH_LOG_H
Utils/include/AmmhLog.h:23:#define ALOGW(fmt,...)            printf(fmt,##__VA_ARGS__)
Utils/include/AmmhLog.h:24:#define ALOGE(fmt,...)            printf(fmt,##__VA_ARGS__)
Utils/include/AmmhLog.h:25:#define ALOGV(fmt,...)            printf(fmt,##__VA_ARGS__)
Utils/include/AmmhLog.h:31: * Normally we strip ALOGV (VERBOSE messages) from release builds.
Utils/include/AmmhLog.h:32: * You can modify this (for example with "#define LOG_NDEBUG 0"
Utils/include/AmmhLog.h:35:#ifndef LOG_NDEBUG
Utils/include/AmmhLog.h:37:#define LOG_NDEBUG 1
Utils/include/AmmhLog.h:39:#define LOG_NDEBUG 0
Utils/include/AmmhLog.h:45: * logging macros.  You can change this preprocessor definition
Utils/include/AmmhLog.h:48:#ifndef LOG_TAG
Utils/include/AmmhLog.h:49:#define LOG_TAG "AmmhLog"
Utils/include/AmmhLog.h:55: * Simplified macro to send a verbose log message using the current LOG_TAG.
Utils/include/AmmhLog.h:57:#ifndef ALOGV
Utils/include/AmmhLog.h:58:#if LOG_NDEBUG
Utils/include/AmmhLog.h:59:#define ALOGV(...)   ((void)0)
Utils/include/AmmhLog.h:61:#define ALOGV(...) ((void)ALOG(LOG_VERBOSE, LOG_TAG, __VA_ARGS__))
Utils/include/AmmhLog.h:67:#ifndef ALOGV_IF
Utils/include/AmmhLog.h:68:#if LOG_NDEBUG
Utils/include/AmmhLog.h:69:#define ALOGV_IF(cond, ...)   ((void)0)
Utils/include/AmmhLog.h:71:#define ALOGV_IF(cond, ...) \
Utils/include/AmmhLog.h:73:    ? ((void)ALOG(LOG_VERBOSE, LOG_TAG, __VA_ARGS__)) \
Utils/include/AmmhLog.h:79: * Simplified macro to send a debug log message using the current LOG_TAG.
Utils/include/AmmhLog.h:81:#ifndef ALOGD
Utils/include/AmmhLog.h:82:#define ALOGD(...) ((void)ALOG(LOG_DEBUG, LOG_TAG, __VA_ARGS__))
Utils/include/AmmhLog.h:85:#ifndef ALOGD_IF
Utils/include/AmmhLog.h:86:#define ALOGD_IF(cond, ...) \
Utils/include/AmmhLog.h:88:    ? ((void)ALOG(LOG_DEBUG, LOG_TAG, __VA_ARGS__)) \
Utils/include/AmmhLog.h:93: * Simplified macro to send an info log message using the current LOG_TAG.
Utils/include/AmmhLog.h:95:#ifndef ALOGI
Utils/include/AmmhLog.h:96:#define ALOGI(...) ((void)ALOG(LOG_INFO, LOG_TAG, __VA_ARGS__))
Utils/include/AmmhLog.h:99:#ifndef ALOGI_IF
Utils/include/AmmhLog.h:100:#define ALOGI_IF(cond, ...) \
Utils/include/AmmhLog.h:102:    ? ((void)ALOG(LOG_INFO, LOG_TAG, __VA_ARGS__)) \
Utils/include/AmmhLog.h:107: * Simplified macro to send a warning log message using the current LOG_TAG.
Utils/include/AmmhLog.h:109:#ifndef ALOGW
Utils/include/AmmhLog.h:110:#define ALOGW(...) ((void)ALOG(LOG_WARN, LOG_TAG, __VA_ARGS__))
Utils/include/AmmhLog.h:113:#ifndef ALOGW_IF
Utils/include/AmmhLog.h:114:#define ALOGW_IF(cond, ...) \
Utils/include/AmmhLog.h:116:    ? ((void)ALOG(LOG_WARN, LOG_TAG, __VA_ARGS__)) \
Utils/include/AmmhLog.h:121: * Simplified macro to send an error log message using the current LOG_TAG.
Utils/include/AmmhLog.h:123:#ifndef ALOGE
Utils/include/AmmhLog.h:124:#define ALOGE(...) ((void)ALOG(LOG_ERROR, LOG_TAG, __VA_ARGS__))
Utils/include/AmmhLog.h:127:#ifndef ALOGE_IF
Utils/include/AmmhLog.h:128:#define ALOGE_IF(cond, ...) \
Utils/include/AmmhLog.h:130:    ? ((void)ALOG(LOG_ERROR, LOG_TAG, __VA_ARGS__)) \
Utils/include/AmmhLog.h:137: * Conditional based on whether the current LOG_TAG is enabled at
Utils/include/AmmhLog.h:140:#ifndef IF_ALOGV
Utils/include/AmmhLog.h:141:#if LOG_NDEBUG
Utils/include/AmmhLog.h:142:#define IF_ALOGV() if (false)
Utils/include/AmmhLog.h:144:#define IF_ALOGV() IF_ALOG(LOG_VERBOSE, LOG_TAG)
Utils/include/AmmhLog.h:149: * Conditional based on whether the current LOG_TAG is enabled at
Utils/include/AmmhLog.h:152:#ifndef IF_ALOGD
Utils/include/AmmhLog.h:153:#define IF_ALOGD() IF_ALOG(LOG_DEBUG, LOG_TAG)
Utils/include/AmmhLog.h:157: * Conditional based on whether the current LOG_TAG is enabled at
Utils/include/AmmhLog.h:160:#ifndef IF_ALOGI
Utils/include/AmmhLog.h:161:#define IF_ALOGI() IF_ALOG(LOG_INFO, LOG_TAG)
Utils/include/AmmhLog.h:165: * Conditional based on whether the current LOG_TAG is enabled at
Utils/include/AmmhLog.h:168:#ifndef IF_ALOGW
Utils/include/AmmhLog.h:169:#define IF_ALOGW() IF_ALOG(LOG_WARN, LOG_TAG)
Utils/include/AmmhLog.h:173: * Conditional based on whether the current LOG_TAG is enabled at
Utils/include/AmmhLog.h:176:#ifndef IF_ALOGE
Utils/include/AmmhLog.h:177:#define IF_ALOGE() IF_ALOG(LOG_ERROR, LOG_TAG)
Utils/include/AmmhLog.h:183: * Log a fatal error.  If the given condition fails, this stops program
Utils/include/AmmhLog.h:188:#ifndef LOG_ALWAYS_FATAL_IF
Utils/include/AmmhLog.h:189:#define LOG_ALWAYS_FATAL_IF(cond, ...) \
Utils/include/AmmhLog.h:191:    ? ((void)android_printAssert(#cond, LOG_TAG, ## __VA_ARGS__)) \
Utils/include/AmmhLog.h:195:#ifndef LOG_ALWAYS_FATAL
Utils/include/AmmhLog.h:196:#define LOG_ALWAYS_FATAL(...) \
Utils/include/AmmhLog.h:197:    ( (void)(android_printAssert(NULL, LOG_TAG, ## __VA_ARGS__)) )
Utils/include/AmmhLog.h:201: * Versions of LOG_ALWAYS_FATAL_IF and LOG_ALWAYS_FATAL that
Utils/include/AmmhLog.h:204:#if LOG_NDEBUG
Utils/include/AmmhLog.h:206:#ifndef LOG_FATAL_IF
Utils/include/AmmhLog.h:207:#define LOG_FATAL_IF(cond, ...) ((void)0)
Utils/include/AmmhLog.h:209:#ifndef LOG_FATAL
Utils/include/AmmhLog.h:210:#define LOG_FATAL(...) ((void)0)
Utils/include/AmmhLog.h:215:#ifndef LOG_FATAL_IF
Utils/include/AmmhLog.h:216:#define LOG_FATAL_IF(cond, ...) LOG_ALWAYS_FATAL_IF(cond, ## __VA_ARGS__)
Utils/include/AmmhLog.h:218:#ifndef LOG_FATAL
Utils/include/AmmhLog.h:219:#define LOG_FATAL(...) LOG_ALWAYS_FATAL(__VA_ARGS__)
Utils/include/AmmhLog.h:225: * Assertion that generates a log message when the assertion fails.
Utils/include/AmmhLog.h:226: * Stripped out of release builds.  Uses the current LOG_TAG.
Utils/include/AmmhLog.h:228:#ifndef ALOG_ASSERT
Utils/include/AmmhLog.h:229:#define ALOG_ASSERT(cond, ...) LOG_FATAL_IF(!(cond), ## __VA_ARGS__)
Utils/include/AmmhLog.h:230://#define ALOG_ASSERT(cond) LOG_FATAL_IF(!(cond), "Assertion failed: " #cond)
Utils/include/AmmhProperties.h:29:#ifndef LOG_TAG
Utils/include/AmmhProperties.h:30:#define LOG_TAG "AmmhProperties"
Utils/include/AmmhProperties.h:79:#endif /* LOG_H_ */
Utils/include/SortedVector.h:197:    LOG_FATAL_IF(index>=size(),
Utils/include/KeyedVector.h:134:    LOG_ALWAYS_FATAL_IF(i<0, "%s: key not found", __PRETTY_FUNCTION__);
Utils/include/KeyedVector.h:156:    LOG_ALWAYS_FATAL_IF(i<0, "%s: key not found", __PRETTY_FUNCTION__);
Utils/include/AmmhUtils.h:24:// #include "AmmhLog.h"
Utils/include/AmmhThread.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
Utils/include/AmmhUnicode.h:150: * can ask to log a message and fail in case the invalid utf8 could have caused an override if no
Utils/include/AmmhPlatform.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
Utils/include/AmmhPlatform.h:14:#include "log/log.h"
Utils/include/AmmhPlatform.h:21:#include "log/log.h"
Utils/include/Vector.h:288:    LOG_FATAL_IF(index>=size(),
Utils/include/AmmhFileSystemIo.h:2: * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
Utils/AmmhLooperRoster.cpp:17://#define LOG_NDEBUG 0
Utils/AmmhLooperRoster.cpp:18:#define LOG_TAG "AmmhLooperRoster"
Utils/AmmhLooperRoster.cpp:57:        ALOGE("Attempted to unregister non-existent handler ID %d", handlerID);
Utils/AmmhLooperRoster.cpp:60:    ALOGE("unregisterHandler 1");
Utils/AmmhLooperRoster.cpp:62:    ALOGE("unregisterHandler 2");
Utils/AmmhLooperRoster.cpp:64:        ALOGE("unregisterHandler 3");
Utils/AmmhLooperRoster.cpp:83:                ALOGV("Unregistering stale handler %d", mHandlers.keyAt(i));
